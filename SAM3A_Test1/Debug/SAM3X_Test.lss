
SAM3X_Test.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000017d0  00080000  00080000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     0000043c  20000000  000817d0  00020000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000a180  20000440  00081c10  0002043c  2**3
                  ALLOC
  3 .stack        00000400  2000a5c0  0008bd90  0002043c  2**0
                  ALLOC
  4 .heap         00000200  2000a9c0  0008c190  0002043c  2**0
                  ALLOC
  5 .ARM.attributes 00000029  00000000  00000000  0002043c  2**0
                  CONTENTS, READONLY
  6 .comment      00000059  00000000  00000000  00020465  2**0
                  CONTENTS, READONLY
  7 .debug_info   00008a9e  00000000  00000000  000204be  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000018c0  00000000  00000000  00028f5c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    000020db  00000000  00000000  0002a81c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 000004c8  00000000  00000000  0002c8f7  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000408  00000000  00000000  0002cdbf  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  00013fa4  00000000  00000000  0002d1c7  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   00007215  00000000  00000000  0004116b  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0005a7ba  00000000  00000000  00048380  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00000c7c  00000000  00000000  000a2b3c  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00080000 <exception_table>:
   80000:	c0 a9 00 20 65 01 08 00 61 01 08 00 61 01 08 00     ... e...a...a...
   80010:	61 01 08 00 61 01 08 00 61 01 08 00 00 00 00 00     a...a...a.......
	...
   8002c:	41 04 08 00 61 01 08 00 00 00 00 00 c1 04 08 00     A...a...........
   8003c:	fd 04 08 00 61 01 08 00 61 01 08 00 61 01 08 00     ....a...a...a...
   8004c:	61 01 08 00 61 01 08 00 61 01 08 00 61 01 08 00     a...a...a...a...
   8005c:	61 01 08 00 61 01 08 00 61 01 08 00 00 00 00 00     a...a...a.......
   8006c:	61 01 08 00 61 01 08 00 61 01 08 00 61 01 08 00     a...a...a...a...
	...
   80084:	61 01 08 00 61 01 08 00 61 01 08 00 61 01 08 00     a...a...a...a...
   80094:	61 01 08 00 61 01 08 00 61 01 08 00 61 01 08 00     a...a...a...a...
   800a4:	00 00 00 00 61 01 08 00 61 01 08 00 61 01 08 00     ....a...a...a...
   800b4:	61 01 08 00 61 01 08 00 61 01 08 00 61 01 08 00     a...a...a...a...
   800c4:	61 01 08 00 61 01 08 00 61 01 08 00 61 01 08 00     a...a...a...a...
   800d4:	61 01 08 00 61 01 08 00 61 01 08 00 61 01 08 00     a...a...a...a...
   800e4:	61 01 08 00 61 01 08 00 61 01 08 00 61 01 08 00     a...a...a...a...

000800f4 <__do_global_dtors_aux>:
   800f4:	b510      	push	{r4, lr}
   800f6:	4c05      	ldr	r4, [pc, #20]	; (8010c <__do_global_dtors_aux+0x18>)
   800f8:	7823      	ldrb	r3, [r4, #0]
   800fa:	b933      	cbnz	r3, 8010a <__do_global_dtors_aux+0x16>
   800fc:	4b04      	ldr	r3, [pc, #16]	; (80110 <__do_global_dtors_aux+0x1c>)
   800fe:	b113      	cbz	r3, 80106 <__do_global_dtors_aux+0x12>
   80100:	4804      	ldr	r0, [pc, #16]	; (80114 <__do_global_dtors_aux+0x20>)
   80102:	f3af 8000 	nop.w
   80106:	2301      	movs	r3, #1
   80108:	7023      	strb	r3, [r4, #0]
   8010a:	bd10      	pop	{r4, pc}
   8010c:	20000440 	.word	0x20000440
   80110:	00000000 	.word	0x00000000
   80114:	000817d0 	.word	0x000817d0

00080118 <frame_dummy>:
   80118:	4b0c      	ldr	r3, [pc, #48]	; (8014c <frame_dummy+0x34>)
   8011a:	b143      	cbz	r3, 8012e <frame_dummy+0x16>
   8011c:	480c      	ldr	r0, [pc, #48]	; (80150 <frame_dummy+0x38>)
   8011e:	b510      	push	{r4, lr}
   80120:	490c      	ldr	r1, [pc, #48]	; (80154 <frame_dummy+0x3c>)
   80122:	f3af 8000 	nop.w
   80126:	480c      	ldr	r0, [pc, #48]	; (80158 <frame_dummy+0x40>)
   80128:	6803      	ldr	r3, [r0, #0]
   8012a:	b923      	cbnz	r3, 80136 <frame_dummy+0x1e>
   8012c:	bd10      	pop	{r4, pc}
   8012e:	480a      	ldr	r0, [pc, #40]	; (80158 <frame_dummy+0x40>)
   80130:	6803      	ldr	r3, [r0, #0]
   80132:	b933      	cbnz	r3, 80142 <frame_dummy+0x2a>
   80134:	4770      	bx	lr
   80136:	4b09      	ldr	r3, [pc, #36]	; (8015c <frame_dummy+0x44>)
   80138:	2b00      	cmp	r3, #0
   8013a:	d0f7      	beq.n	8012c <frame_dummy+0x14>
   8013c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   80140:	4718      	bx	r3
   80142:	4b06      	ldr	r3, [pc, #24]	; (8015c <frame_dummy+0x44>)
   80144:	2b00      	cmp	r3, #0
   80146:	d0f5      	beq.n	80134 <frame_dummy+0x1c>
   80148:	4718      	bx	r3
   8014a:	bf00      	nop
   8014c:	00000000 	.word	0x00000000
   80150:	000817d0 	.word	0x000817d0
   80154:	20000444 	.word	0x20000444
   80158:	000817d0 	.word	0x000817d0
   8015c:	00000000 	.word	0x00000000

00080160 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
   80160:	e7fe      	b.n	80160 <Dummy_Handler>
	...

00080164 <Reset_Handler>:
{
   80164:	b508      	push	{r3, lr}
        if (pSrc != pDest) {
   80166:	4b11      	ldr	r3, [pc, #68]	; (801ac <Reset_Handler+0x48>)
   80168:	4a11      	ldr	r2, [pc, #68]	; (801b0 <Reset_Handler+0x4c>)
   8016a:	429a      	cmp	r2, r3
   8016c:	d009      	beq.n	80182 <Reset_Handler+0x1e>
   8016e:	4b0f      	ldr	r3, [pc, #60]	; (801ac <Reset_Handler+0x48>)
   80170:	4a0f      	ldr	r2, [pc, #60]	; (801b0 <Reset_Handler+0x4c>)
   80172:	e003      	b.n	8017c <Reset_Handler+0x18>
                        *pDest++ = *pSrc++;
   80174:	6811      	ldr	r1, [r2, #0]
   80176:	6019      	str	r1, [r3, #0]
   80178:	3304      	adds	r3, #4
   8017a:	3204      	adds	r2, #4
                for (; pDest < &_erelocate;) {
   8017c:	490d      	ldr	r1, [pc, #52]	; (801b4 <Reset_Handler+0x50>)
   8017e:	428b      	cmp	r3, r1
   80180:	d3f8      	bcc.n	80174 <Reset_Handler+0x10>
                        *pDest++ = *pSrc++;
   80182:	4b0d      	ldr	r3, [pc, #52]	; (801b8 <Reset_Handler+0x54>)
   80184:	e002      	b.n	8018c <Reset_Handler+0x28>
                *pDest++ = 0;
   80186:	2200      	movs	r2, #0
   80188:	601a      	str	r2, [r3, #0]
   8018a:	3304      	adds	r3, #4
        for (pDest = &_szero; pDest < &_ezero;) {
   8018c:	4a0b      	ldr	r2, [pc, #44]	; (801bc <Reset_Handler+0x58>)
   8018e:	4293      	cmp	r3, r2
   80190:	d3f9      	bcc.n	80186 <Reset_Handler+0x22>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
   80192:	4b0b      	ldr	r3, [pc, #44]	; (801c0 <Reset_Handler+0x5c>)
   80194:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
   80198:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
   8019c:	4a09      	ldr	r2, [pc, #36]	; (801c4 <Reset_Handler+0x60>)
   8019e:	6093      	str	r3, [r2, #8]
        __libc_init_array();
   801a0:	4b09      	ldr	r3, [pc, #36]	; (801c8 <Reset_Handler+0x64>)
   801a2:	4798      	blx	r3
        main();
   801a4:	4b09      	ldr	r3, [pc, #36]	; (801cc <Reset_Handler+0x68>)
   801a6:	4798      	blx	r3
   801a8:	e7fe      	b.n	801a8 <Reset_Handler+0x44>
   801aa:	bf00      	nop
   801ac:	20000000 	.word	0x20000000
   801b0:	000817d0 	.word	0x000817d0
   801b4:	2000043c 	.word	0x2000043c
   801b8:	20000440 	.word	0x20000440
   801bc:	2000a5c0 	.word	0x2000a5c0
   801c0:	00080000 	.word	0x00080000
   801c4:	e000ed00 	.word	0xe000ed00
   801c8:	0008152d 	.word	0x0008152d
   801cc:	00080e25 	.word	0x00080e25

000801d0 <SystemInit>:
 * Initialize the System and update the SystemFrequency variable.
 */
void SystemInit( void )
{
  /* Set FWS according to SYS_BOARD_MCKR configuration */
  EFC0->EEFC_FMR = EEFC_FMR_FWS(4);
   801d0:	f44f 6380 	mov.w	r3, #1024	; 0x400
   801d4:	4a20      	ldr	r2, [pc, #128]	; (80258 <SystemInit+0x88>)
   801d6:	6013      	str	r3, [r2, #0]
  EFC1->EEFC_FMR = EEFC_FMR_FWS(4);
   801d8:	f502 7200 	add.w	r2, r2, #512	; 0x200
   801dc:	6013      	str	r3, [r2, #0]

  /* Initialize main oscillator */
  if ( !(PMC->CKGR_MOR & CKGR_MOR_MOSCSEL) )
   801de:	4b1f      	ldr	r3, [pc, #124]	; (8025c <SystemInit+0x8c>)
   801e0:	6a1b      	ldr	r3, [r3, #32]
   801e2:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
   801e6:	d107      	bne.n	801f8 <SystemInit+0x28>
  {
    PMC->CKGR_MOR = CKGR_MOR_KEY_PASSWD | SYS_BOARD_OSCOUNT | CKGR_MOR_MOSCRCEN | CKGR_MOR_MOSCXTEN;
   801e8:	4a1d      	ldr	r2, [pc, #116]	; (80260 <SystemInit+0x90>)
   801ea:	4b1c      	ldr	r3, [pc, #112]	; (8025c <SystemInit+0x8c>)
   801ec:	621a      	str	r2, [r3, #32]
    while ( !(PMC->PMC_SR & PMC_SR_MOSCXTS) )
   801ee:	4b1b      	ldr	r3, [pc, #108]	; (8025c <SystemInit+0x8c>)
   801f0:	6e9b      	ldr	r3, [r3, #104]	; 0x68
   801f2:	f013 0f01 	tst.w	r3, #1
   801f6:	d0fa      	beq.n	801ee <SystemInit+0x1e>
    {
    }
  }

  /* Switch to 3-20MHz Xtal oscillator */
  PMC->CKGR_MOR = CKGR_MOR_KEY_PASSWD | SYS_BOARD_OSCOUNT | CKGR_MOR_MOSCRCEN | CKGR_MOR_MOSCXTEN | CKGR_MOR_MOSCSEL;
   801f8:	4a1a      	ldr	r2, [pc, #104]	; (80264 <SystemInit+0x94>)
   801fa:	4b18      	ldr	r3, [pc, #96]	; (8025c <SystemInit+0x8c>)
   801fc:	621a      	str	r2, [r3, #32]

  while ( !(PMC->PMC_SR & PMC_SR_MOSCSELS) )
   801fe:	4b17      	ldr	r3, [pc, #92]	; (8025c <SystemInit+0x8c>)
   80200:	6e9b      	ldr	r3, [r3, #104]	; 0x68
   80202:	f413 3f80 	tst.w	r3, #65536	; 0x10000
   80206:	d0fa      	beq.n	801fe <SystemInit+0x2e>
  {
  }
 	PMC->PMC_MCKR = (PMC->PMC_MCKR & ~(uint32_t)PMC_MCKR_CSS_Msk) | PMC_MCKR_CSS_MAIN_CLK;
   80208:	4a14      	ldr	r2, [pc, #80]	; (8025c <SystemInit+0x8c>)
   8020a:	6b13      	ldr	r3, [r2, #48]	; 0x30
   8020c:	f023 0303 	bic.w	r3, r3, #3
   80210:	f043 0301 	orr.w	r3, r3, #1
   80214:	6313      	str	r3, [r2, #48]	; 0x30
  while (!(PMC->PMC_SR & PMC_SR_MCKRDY))
   80216:	4b11      	ldr	r3, [pc, #68]	; (8025c <SystemInit+0x8c>)
   80218:	6e9b      	ldr	r3, [r3, #104]	; 0x68
   8021a:	f013 0f08 	tst.w	r3, #8
   8021e:	d0fa      	beq.n	80216 <SystemInit+0x46>
  {
  }

  /* Initialize PLLA */
  PMC->CKGR_PLLAR = SYS_BOARD_PLLAR;
   80220:	4a11      	ldr	r2, [pc, #68]	; (80268 <SystemInit+0x98>)
   80222:	4b0e      	ldr	r3, [pc, #56]	; (8025c <SystemInit+0x8c>)
   80224:	629a      	str	r2, [r3, #40]	; 0x28
  while ( !(PMC->PMC_SR & PMC_SR_LOCKA) )
   80226:	4b0d      	ldr	r3, [pc, #52]	; (8025c <SystemInit+0x8c>)
   80228:	6e9b      	ldr	r3, [r3, #104]	; 0x68
   8022a:	f013 0f02 	tst.w	r3, #2
   8022e:	d0fa      	beq.n	80226 <SystemInit+0x56>
  {
  }

  /* Switch to main clock */
  PMC->PMC_MCKR = (SYS_BOARD_MCKR & ~PMC_MCKR_CSS_Msk) | PMC_MCKR_CSS_MAIN_CLK;
   80230:	2211      	movs	r2, #17
   80232:	4b0a      	ldr	r3, [pc, #40]	; (8025c <SystemInit+0x8c>)
   80234:	631a      	str	r2, [r3, #48]	; 0x30
  while ( !(PMC->PMC_SR & PMC_SR_MCKRDY) )
   80236:	4b09      	ldr	r3, [pc, #36]	; (8025c <SystemInit+0x8c>)
   80238:	6e9b      	ldr	r3, [r3, #104]	; 0x68
   8023a:	f013 0f08 	tst.w	r3, #8
   8023e:	d0fa      	beq.n	80236 <SystemInit+0x66>
  {
  }

  /* Switch to PLLA */
  PMC->PMC_MCKR = SYS_BOARD_MCKR;
   80240:	2212      	movs	r2, #18
   80242:	4b06      	ldr	r3, [pc, #24]	; (8025c <SystemInit+0x8c>)
   80244:	631a      	str	r2, [r3, #48]	; 0x30
  while ( !(PMC->PMC_SR & PMC_SR_MCKRDY) )
   80246:	4b05      	ldr	r3, [pc, #20]	; (8025c <SystemInit+0x8c>)
   80248:	6e9b      	ldr	r3, [r3, #104]	; 0x68
   8024a:	f013 0f08 	tst.w	r3, #8
   8024e:	d0fa      	beq.n	80246 <SystemInit+0x76>
  {
  }

  SystemCoreClock = CHIP_FREQ_CPU_MAX;
   80250:	4a06      	ldr	r2, [pc, #24]	; (8026c <SystemInit+0x9c>)
   80252:	4b07      	ldr	r3, [pc, #28]	; (80270 <SystemInit+0xa0>)
   80254:	601a      	str	r2, [r3, #0]
   80256:	4770      	bx	lr
   80258:	400e0a00 	.word	0x400e0a00
   8025c:	400e0600 	.word	0x400e0600
   80260:	00370809 	.word	0x00370809
   80264:	01370809 	.word	0x01370809
   80268:	20273f03 	.word	0x20273f03
   8026c:	0501bd00 	.word	0x0501bd00
   80270:	20000000 	.word	0x20000000

00080274 <SystemCoreClockUpdate>:
}

void SystemCoreClockUpdate( void )
{
  /* Determine clock frequency according to clock register values */
  switch ( PMC->PMC_MCKR & PMC_MCKR_CSS_Msk )
   80274:	4b3e      	ldr	r3, [pc, #248]	; (80370 <SystemCoreClockUpdate+0xfc>)
   80276:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   80278:	f003 0303 	and.w	r3, r3, #3
   8027c:	2b03      	cmp	r3, #3
   8027e:	d83f      	bhi.n	80300 <SystemCoreClockUpdate+0x8c>
   80280:	e8df f003 	tbb	[pc, r3]
   80284:	2d2d1102 	.word	0x2d2d1102
  {
    case PMC_MCKR_CSS_SLOW_CLK: /* Slow clock */
      if (SUPC->SUPC_SR & SUPC_SR_OSCSEL)
   80288:	4b3a      	ldr	r3, [pc, #232]	; (80374 <SystemCoreClockUpdate+0x100>)
   8028a:	695b      	ldr	r3, [r3, #20]
   8028c:	f013 0f80 	tst.w	r3, #128	; 0x80
   80290:	d004      	beq.n	8029c <SystemCoreClockUpdate+0x28>
      {
        SystemCoreClock = CHIP_FREQ_XTAL_32K;
   80292:	f44f 4200 	mov.w	r2, #32768	; 0x8000
   80296:	4b38      	ldr	r3, [pc, #224]	; (80378 <SystemCoreClockUpdate+0x104>)
   80298:	601a      	str	r2, [r3, #0]
   8029a:	e031      	b.n	80300 <SystemCoreClockUpdate+0x8c>
      }
      else
      {
        SystemCoreClock = CHIP_FREQ_SLCK_RC;
   8029c:	f44f 42fa 	mov.w	r2, #32000	; 0x7d00
   802a0:	4b35      	ldr	r3, [pc, #212]	; (80378 <SystemCoreClockUpdate+0x104>)
   802a2:	601a      	str	r2, [r3, #0]
   802a4:	e02c      	b.n	80300 <SystemCoreClockUpdate+0x8c>
      }
    break;

    case PMC_MCKR_CSS_MAIN_CLK: /* Main clock */
      if (PMC->CKGR_MOR & CKGR_MOR_MOSCSEL)
   802a6:	4b32      	ldr	r3, [pc, #200]	; (80370 <SystemCoreClockUpdate+0xfc>)
   802a8:	6a1b      	ldr	r3, [r3, #32]
   802aa:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
   802ae:	d003      	beq.n	802b8 <SystemCoreClockUpdate+0x44>
      {
        SystemCoreClock = CHIP_FREQ_XTAL_12M;
   802b0:	4a32      	ldr	r2, [pc, #200]	; (8037c <SystemCoreClockUpdate+0x108>)
   802b2:	4b31      	ldr	r3, [pc, #196]	; (80378 <SystemCoreClockUpdate+0x104>)
   802b4:	601a      	str	r2, [r3, #0]
   802b6:	e023      	b.n	80300 <SystemCoreClockUpdate+0x8c>
      }
      else
      {
        SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
   802b8:	4a31      	ldr	r2, [pc, #196]	; (80380 <SystemCoreClockUpdate+0x10c>)
   802ba:	4b2f      	ldr	r3, [pc, #188]	; (80378 <SystemCoreClockUpdate+0x104>)
   802bc:	601a      	str	r2, [r3, #0]

        switch (PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk)
   802be:	4b2c      	ldr	r3, [pc, #176]	; (80370 <SystemCoreClockUpdate+0xfc>)
   802c0:	6a1b      	ldr	r3, [r3, #32]
   802c2:	f003 0370 	and.w	r3, r3, #112	; 0x70
   802c6:	2b10      	cmp	r3, #16
   802c8:	d005      	beq.n	802d6 <SystemCoreClockUpdate+0x62>
   802ca:	2b20      	cmp	r3, #32
   802cc:	d118      	bne.n	80300 <SystemCoreClockUpdate+0x8c>
          case CKGR_MOR_MOSCRCF_8_MHz:
            SystemCoreClock *= 2U;
          break;

          case CKGR_MOR_MOSCRCF_12_MHz:
            SystemCoreClock *= 3U;
   802ce:	4a2b      	ldr	r2, [pc, #172]	; (8037c <SystemCoreClockUpdate+0x108>)
   802d0:	4b29      	ldr	r3, [pc, #164]	; (80378 <SystemCoreClockUpdate+0x104>)
   802d2:	601a      	str	r2, [r3, #0]
          break;
   802d4:	e014      	b.n	80300 <SystemCoreClockUpdate+0x8c>
            SystemCoreClock *= 2U;
   802d6:	4a2b      	ldr	r2, [pc, #172]	; (80384 <SystemCoreClockUpdate+0x110>)
   802d8:	4b27      	ldr	r3, [pc, #156]	; (80378 <SystemCoreClockUpdate+0x104>)
   802da:	601a      	str	r2, [r3, #0]
          break;
   802dc:	e010      	b.n	80300 <SystemCoreClockUpdate+0x8c>
      }
    break;

    case PMC_MCKR_CSS_PLLA_CLK: /* PLLA clock */
    case PMC_MCKR_CSS_UPLL_CLK: /* UPLL clock */
      if ( PMC->CKGR_MOR & CKGR_MOR_MOSCSEL )
   802de:	4b24      	ldr	r3, [pc, #144]	; (80370 <SystemCoreClockUpdate+0xfc>)
   802e0:	6a1b      	ldr	r3, [r3, #32]
   802e2:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
   802e6:	d01a      	beq.n	8031e <SystemCoreClockUpdate+0xaa>
      {
        SystemCoreClock = CHIP_FREQ_XTAL_12M;
   802e8:	4a24      	ldr	r2, [pc, #144]	; (8037c <SystemCoreClockUpdate+0x108>)
   802ea:	4b23      	ldr	r3, [pc, #140]	; (80378 <SystemCoreClockUpdate+0x104>)
   802ec:	601a      	str	r2, [r3, #0]

          default:
          break;
        }
      }
      if ( (PMC->PMC_MCKR & PMC_MCKR_CSS_Msk) == PMC_MCKR_CSS_PLLA_CLK )
   802ee:	4b20      	ldr	r3, [pc, #128]	; (80370 <SystemCoreClockUpdate+0xfc>)
   802f0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   802f2:	f003 0303 	and.w	r3, r3, #3
   802f6:	2b02      	cmp	r3, #2
   802f8:	d024      	beq.n	80344 <SystemCoreClockUpdate+0xd0>
        SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> CKGR_PLLAR_MULA_Pos) + 1U);
        SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk) >> CKGR_PLLAR_DIVA_Pos));
      }
      else
      {
        SystemCoreClock = CHIP_FREQ_UTMIPLL / 2U;
   802fa:	4a23      	ldr	r2, [pc, #140]	; (80388 <SystemCoreClockUpdate+0x114>)
   802fc:	4b1e      	ldr	r3, [pc, #120]	; (80378 <SystemCoreClockUpdate+0x104>)
   802fe:	601a      	str	r2, [r3, #0]
      }
    break;
  }

  if ( (PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3 )
   80300:	4b1b      	ldr	r3, [pc, #108]	; (80370 <SystemCoreClockUpdate+0xfc>)
   80302:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   80304:	f003 0370 	and.w	r3, r3, #112	; 0x70
   80308:	2b70      	cmp	r3, #112	; 0x70
   8030a:	d029      	beq.n	80360 <SystemCoreClockUpdate+0xec>
  {
    SystemCoreClock /= 3U;
  }
  else
  {
    SystemCoreClock >>= ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) >> PMC_MCKR_PRES_Pos);
   8030c:	4b18      	ldr	r3, [pc, #96]	; (80370 <SystemCoreClockUpdate+0xfc>)
   8030e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
   80310:	f3c2 1202 	ubfx	r2, r2, #4, #3
   80314:	4918      	ldr	r1, [pc, #96]	; (80378 <SystemCoreClockUpdate+0x104>)
   80316:	680b      	ldr	r3, [r1, #0]
   80318:	40d3      	lsrs	r3, r2
   8031a:	600b      	str	r3, [r1, #0]
   8031c:	4770      	bx	lr
        SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
   8031e:	4a18      	ldr	r2, [pc, #96]	; (80380 <SystemCoreClockUpdate+0x10c>)
   80320:	4b15      	ldr	r3, [pc, #84]	; (80378 <SystemCoreClockUpdate+0x104>)
   80322:	601a      	str	r2, [r3, #0]
        switch ( PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk )
   80324:	4b12      	ldr	r3, [pc, #72]	; (80370 <SystemCoreClockUpdate+0xfc>)
   80326:	6a1b      	ldr	r3, [r3, #32]
   80328:	f003 0370 	and.w	r3, r3, #112	; 0x70
   8032c:	2b10      	cmp	r3, #16
   8032e:	d005      	beq.n	8033c <SystemCoreClockUpdate+0xc8>
   80330:	2b20      	cmp	r3, #32
   80332:	d1dc      	bne.n	802ee <SystemCoreClockUpdate+0x7a>
            SystemCoreClock *= 3U;
   80334:	4a11      	ldr	r2, [pc, #68]	; (8037c <SystemCoreClockUpdate+0x108>)
   80336:	4b10      	ldr	r3, [pc, #64]	; (80378 <SystemCoreClockUpdate+0x104>)
   80338:	601a      	str	r2, [r3, #0]
          break;
   8033a:	e7d8      	b.n	802ee <SystemCoreClockUpdate+0x7a>
            SystemCoreClock *= 2U;
   8033c:	4a11      	ldr	r2, [pc, #68]	; (80384 <SystemCoreClockUpdate+0x110>)
   8033e:	4b0e      	ldr	r3, [pc, #56]	; (80378 <SystemCoreClockUpdate+0x104>)
   80340:	601a      	str	r2, [r3, #0]
          break;
   80342:	e7d4      	b.n	802ee <SystemCoreClockUpdate+0x7a>
        SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> CKGR_PLLAR_MULA_Pos) + 1U);
   80344:	480a      	ldr	r0, [pc, #40]	; (80370 <SystemCoreClockUpdate+0xfc>)
   80346:	6a82      	ldr	r2, [r0, #40]	; 0x28
   80348:	f3c2 420a 	ubfx	r2, r2, #16, #11
   8034c:	490a      	ldr	r1, [pc, #40]	; (80378 <SystemCoreClockUpdate+0x104>)
   8034e:	680b      	ldr	r3, [r1, #0]
   80350:	fb02 3303 	mla	r3, r2, r3, r3
        SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk) >> CKGR_PLLAR_DIVA_Pos));
   80354:	6a82      	ldr	r2, [r0, #40]	; 0x28
   80356:	b2d2      	uxtb	r2, r2
   80358:	fbb3 f3f2 	udiv	r3, r3, r2
   8035c:	600b      	str	r3, [r1, #0]
   8035e:	e7cf      	b.n	80300 <SystemCoreClockUpdate+0x8c>
    SystemCoreClock /= 3U;
   80360:	4a05      	ldr	r2, [pc, #20]	; (80378 <SystemCoreClockUpdate+0x104>)
   80362:	6813      	ldr	r3, [r2, #0]
   80364:	4909      	ldr	r1, [pc, #36]	; (8038c <SystemCoreClockUpdate+0x118>)
   80366:	fba1 1303 	umull	r1, r3, r1, r3
   8036a:	085b      	lsrs	r3, r3, #1
   8036c:	6013      	str	r3, [r2, #0]
   8036e:	4770      	bx	lr
   80370:	400e0600 	.word	0x400e0600
   80374:	400e1a10 	.word	0x400e1a10
   80378:	20000000 	.word	0x20000000
   8037c:	00b71b00 	.word	0x00b71b00
   80380:	003d0900 	.word	0x003d0900
   80384:	007a1200 	.word	0x007a1200
   80388:	0e4e1c00 	.word	0x0e4e1c00
   8038c:	aaaaaaab 	.word	0xaaaaaaab

00080390 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
   80390:	f100 0308 	add.w	r3, r0, #8
   80394:	6043      	str	r3, [r0, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
   80396:	f04f 32ff 	mov.w	r2, #4294967295
   8039a:	6082      	str	r2, [r0, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
   8039c:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
   8039e:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
   803a0:	2300      	movs	r3, #0
   803a2:	6003      	str	r3, [r0, #0]
   803a4:	4770      	bx	lr

000803a6 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
   803a6:	2300      	movs	r3, #0
   803a8:	6103      	str	r3, [r0, #16]
   803aa:	4770      	bx	lr

000803ac <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
   803ac:	6843      	ldr	r3, [r0, #4]

	pxNewListItem->pxNext = pxIndex->pxNext;
   803ae:	685a      	ldr	r2, [r3, #4]
   803b0:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxPrevious = pxList->pxIndex;
   803b2:	6842      	ldr	r2, [r0, #4]
   803b4:	608a      	str	r2, [r1, #8]
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
   803b6:	685a      	ldr	r2, [r3, #4]
   803b8:	6091      	str	r1, [r2, #8]
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
   803ba:	6059      	str	r1, [r3, #4]
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
   803bc:	6041      	str	r1, [r0, #4]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
   803be:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
   803c0:	6803      	ldr	r3, [r0, #0]
   803c2:	3301      	adds	r3, #1
   803c4:	6003      	str	r3, [r0, #0]
   803c6:	4770      	bx	lr

000803c8 <vListInsert>:
}
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
   803c8:	b410      	push	{r4}
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
   803ca:	680c      	ldr	r4, [r1, #0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
   803cc:	f1b4 3fff 	cmp.w	r4, #4294967295
   803d0:	d002      	beq.n	803d8 <vListInsert+0x10>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
   803d2:	f100 0308 	add.w	r3, r0, #8
   803d6:	e002      	b.n	803de <vListInsert+0x16>
		pxIterator = pxList->xListEnd.pxPrevious;
   803d8:	6903      	ldr	r3, [r0, #16]
   803da:	e004      	b.n	803e6 <vListInsert+0x1e>
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
   803dc:	685b      	ldr	r3, [r3, #4]
   803de:	685a      	ldr	r2, [r3, #4]
   803e0:	6812      	ldr	r2, [r2, #0]
   803e2:	4294      	cmp	r4, r2
   803e4:	d2fa      	bcs.n	803dc <vListInsert+0x14>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
   803e6:	685a      	ldr	r2, [r3, #4]
   803e8:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
   803ea:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious = pxIterator;
   803ec:	608b      	str	r3, [r1, #8]
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
   803ee:	6059      	str	r1, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
   803f0:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
   803f2:	6803      	ldr	r3, [r0, #0]
   803f4:	3301      	adds	r3, #1
   803f6:	6003      	str	r3, [r0, #0]
}
   803f8:	bc10      	pop	{r4}
   803fa:	4770      	bx	lr

000803fc <uxListRemove>:

unsigned portBASE_TYPE uxListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
   803fc:	6843      	ldr	r3, [r0, #4]
   803fe:	6882      	ldr	r2, [r0, #8]
   80400:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
   80402:	6883      	ldr	r3, [r0, #8]
   80404:	6842      	ldr	r2, [r0, #4]
   80406:	605a      	str	r2, [r3, #4]

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
   80408:	6903      	ldr	r3, [r0, #16]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
   8040a:	685a      	ldr	r2, [r3, #4]
   8040c:	4290      	cmp	r0, r2
   8040e:	d006      	beq.n	8041e <uxListRemove+0x22>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
	}

	pxItemToRemove->pvContainer = NULL;
   80410:	2200      	movs	r2, #0
   80412:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
   80414:	681a      	ldr	r2, [r3, #0]
   80416:	3a01      	subs	r2, #1
   80418:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
   8041a:	6818      	ldr	r0, [r3, #0]
}
   8041c:	4770      	bx	lr
		pxList->pxIndex = pxItemToRemove->pxPrevious;
   8041e:	6882      	ldr	r2, [r0, #8]
   80420:	605a      	str	r2, [r3, #4]
   80422:	e7f5      	b.n	80410 <uxListRemove+0x14>

00080424 <pxPortInitialiseStack>:
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */
	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
   80424:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
   80428:	f840 3c04 	str.w	r3, [r0, #-4]
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) pxCode;	/* PC */
   8042c:	f840 1c08 	str.w	r1, [r0, #-8]
	pxTopOfStack--;
	*pxTopOfStack = 0;	/* LR */
   80430:	2300      	movs	r3, #0
   80432:	f840 3c0c 	str.w	r3, [r0, #-12]
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
	*pxTopOfStack = ( portSTACK_TYPE ) pvParameters;	/* R0 */
   80436:	f840 2c20 	str.w	r2, [r0, #-32]
	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */

	return pxTopOfStack;
}
   8043a:	3840      	subs	r0, #64	; 0x40
   8043c:	4770      	bx	lr
	...

00080440 <SVC_Handler>:
/*-----------------------------------------------------------*/

__attribute__ (( naked )) void SVC_Handler( void )
{
	__asm volatile (
   80440:	4b06      	ldr	r3, [pc, #24]	; (8045c <pxCurrentTCBConst2>)
   80442:	6819      	ldr	r1, [r3, #0]
   80444:	6808      	ldr	r0, [r1, #0]
   80446:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
   8044a:	f380 8809 	msr	PSP, r0
   8044e:	f04f 0000 	mov.w	r0, #0
   80452:	f380 8811 	msr	BASEPRI, r0
   80456:	f04e 0e0d 	orr.w	lr, lr, #13
   8045a:	4770      	bx	lr

0008045c <pxCurrentTCBConst2>:
   8045c:	2000a53c 	.word	0x2000a53c

00080460 <vPortYieldFromISR>:
/*-----------------------------------------------------------*/

void vPortYieldFromISR( void )
{
	/* Set a PendSV to request a context switch. */
	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
   80460:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   80464:	4b01      	ldr	r3, [pc, #4]	; (8046c <vPortYieldFromISR+0xc>)
   80466:	601a      	str	r2, [r3, #0]
   80468:	4770      	bx	lr
   8046a:	bf00      	nop
   8046c:	e000ed04 	.word	0xe000ed04

00080470 <ulPortSetInterruptMask>:
}
/*-----------------------------------------------------------*/

__attribute__(( naked )) unsigned long ulPortSetInterruptMask( void )
{
	__asm volatile														\
   80470:	f3ef 8011 	mrs	r0, BASEPRI
   80474:	f04f 01a0 	mov.w	r1, #160	; 0xa0
   80478:	f381 8811 	msr	BASEPRI, r1
   8047c:	4770      	bx	lr
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return 0;
}
   8047e:	2000      	movs	r0, #0

00080480 <vPortEnterCritical>:
{
   80480:	b508      	push	{r3, lr}
	portDISABLE_INTERRUPTS();
   80482:	4b03      	ldr	r3, [pc, #12]	; (80490 <vPortEnterCritical+0x10>)
   80484:	4798      	blx	r3
	uxCriticalNesting++;
   80486:	4a03      	ldr	r2, [pc, #12]	; (80494 <vPortEnterCritical+0x14>)
   80488:	6813      	ldr	r3, [r2, #0]
   8048a:	3301      	adds	r3, #1
   8048c:	6013      	str	r3, [r2, #0]
   8048e:	bd08      	pop	{r3, pc}
   80490:	00080471 	.word	0x00080471
   80494:	20000004 	.word	0x20000004

00080498 <vPortClearInterruptMask>:
/*-----------------------------------------------------------*/

__attribute__(( naked )) void vPortClearInterruptMask( unsigned long ulNewMaskValue )
{
	__asm volatile													\
   80498:	f380 8811 	msr	BASEPRI, r0
   8049c:	4770      	bx	lr
	...

000804a0 <vPortExitCritical>:
{
   804a0:	b508      	push	{r3, lr}
	uxCriticalNesting--;
   804a2:	4a05      	ldr	r2, [pc, #20]	; (804b8 <vPortExitCritical+0x18>)
   804a4:	6813      	ldr	r3, [r2, #0]
   804a6:	3b01      	subs	r3, #1
   804a8:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
   804aa:	b103      	cbz	r3, 804ae <vPortExitCritical+0xe>
   804ac:	bd08      	pop	{r3, pc}
		portENABLE_INTERRUPTS();
   804ae:	2000      	movs	r0, #0
   804b0:	4b02      	ldr	r3, [pc, #8]	; (804bc <vPortExitCritical+0x1c>)
   804b2:	4798      	blx	r3
}
   804b4:	e7fa      	b.n	804ac <vPortExitCritical+0xc>
   804b6:	bf00      	nop
   804b8:	20000004 	.word	0x20000004
   804bc:	00080499 	.word	0x00080499

000804c0 <PendSV_Handler>:

__attribute__(( naked )) void PendSV_Handler( void )
{
	/* This is a naked function. */

	__asm volatile
   804c0:	f3ef 8009 	mrs	r0, PSP
   804c4:	4b0c      	ldr	r3, [pc, #48]	; (804f8 <pxCurrentTCBConst>)
   804c6:	681a      	ldr	r2, [r3, #0]
   804c8:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
   804cc:	6010      	str	r0, [r2, #0]
   804ce:	e92d 4008 	stmdb	sp!, {r3, lr}
   804d2:	f04f 00a0 	mov.w	r0, #160	; 0xa0
   804d6:	f380 8811 	msr	BASEPRI, r0
   804da:	f000 fb8d 	bl	80bf8 <vTaskSwitchContext>
   804de:	f04f 0000 	mov.w	r0, #0
   804e2:	f380 8811 	msr	BASEPRI, r0
   804e6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   804ea:	6819      	ldr	r1, [r3, #0]
   804ec:	6808      	ldr	r0, [r1, #0]
   804ee:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
   804f2:	f380 8809 	msr	PSP, r0
   804f6:	4770      	bx	lr

000804f8 <pxCurrentTCBConst>:
   804f8:	2000a53c 	.word	0x2000a53c

000804fc <SysTick_Handler>:
	);
}
/*-----------------------------------------------------------*/

void SysTick_Handler( void )
{
   804fc:	b508      	push	{r3, lr}
	/* If using preemption, also force a context switch. */
	#if configUSE_PREEMPTION == 1
		portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
   804fe:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   80502:	4b05      	ldr	r3, [pc, #20]	; (80518 <SysTick_Handler+0x1c>)
   80504:	601a      	str	r2, [r3, #0]
	to generate the tick interrupt. */
	#if configUSE_TICKLESS_IDLE == 1
		portNVIC_SYSTICK_LOAD_REG = ulTimerReloadValueForOneTick;
	#endif

	( void ) portSET_INTERRUPT_MASK_FROM_ISR();
   80506:	4b05      	ldr	r3, [pc, #20]	; (8051c <SysTick_Handler+0x20>)
   80508:	4798      	blx	r3
	{
		vTaskIncrementTick();
   8050a:	4b05      	ldr	r3, [pc, #20]	; (80520 <SysTick_Handler+0x24>)
   8050c:	4798      	blx	r3
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( 0 );
   8050e:	2000      	movs	r0, #0
   80510:	4b04      	ldr	r3, [pc, #16]	; (80524 <SysTick_Handler+0x28>)
   80512:	4798      	blx	r3
   80514:	bd08      	pop	{r3, pc}
   80516:	bf00      	nop
   80518:	e000ed04 	.word	0xe000ed04
   8051c:	00080471 	.word	0x00080471
   80520:	00080959 	.word	0x00080959
   80524:	00080499 	.word	0x00080499

00080528 <prvHeapInit>:
	/* This just exists to keep the linker quiet. */
}
/*-----------------------------------------------------------*/

static void prvHeapInit( void )
{
   80528:	b410      	push	{r4}
	/* Ensure the start of the heap is aligned. */
	configASSERT( ( ( ( unsigned long ) xHeap.ucHeap ) & ( ( unsigned long ) portBYTE_ALIGNMENT_MASK ) ) == 0UL );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) xHeap.ucHeap;
   8052a:	4b0d      	ldr	r3, [pc, #52]	; (80560 <prvHeapInit+0x38>)
   8052c:	f103 0208 	add.w	r2, r3, #8
   80530:	601a      	str	r2, [r3, #0]
	xStart.xBlockSize = ( size_t ) 0;
   80532:	2100      	movs	r1, #0
   80534:	6059      	str	r1, [r3, #4]

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	pucHeapEnd = xHeap.ucHeap + xTotalHeapSize;
	pucHeapEnd -= heapSTRUCT_SIZE;
	pxEnd = ( void * ) pucHeapEnd;
   80536:	f649 70f0 	movw	r0, #40944	; 0x9ff0
   8053a:	4402      	add	r2, r0
   8053c:	4c09      	ldr	r4, [pc, #36]	; (80564 <prvHeapInit+0x3c>)
   8053e:	f8c4 2750 	str.w	r2, [r4, #1872]	; 0x750
	configASSERT( ( ( ( unsigned long ) pxEnd ) & ( ( unsigned long ) portBYTE_ALIGNMENT_MASK ) ) == 0UL );
	pxEnd->xBlockSize = 0;
   80542:	f649 74fc 	movw	r4, #40956	; 0x9ffc
   80546:	5119      	str	r1, [r3, r4]
	pxEnd->pxNextFreeBlock = NULL;
   80548:	f649 74f8 	movw	r4, #40952	; 0x9ff8
   8054c:	5119      	str	r1, [r3, r4]

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) xHeap.ucHeap;
	pxFirstFreeBlock->xBlockSize = xTotalHeapSize - heapSTRUCT_SIZE;
   8054e:	60d8      	str	r0, [r3, #12]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
   80550:	609a      	str	r2, [r3, #8]

	/* The heap now contains pxEnd. */
	xFreeBytesRemaining -= heapSTRUCT_SIZE;
   80552:	4a05      	ldr	r2, [pc, #20]	; (80568 <prvHeapInit+0x40>)
   80554:	6813      	ldr	r3, [r2, #0]
   80556:	3b10      	subs	r3, #16
   80558:	6013      	str	r3, [r2, #0]
}
   8055a:	bc10      	pop	{r4}
   8055c:	4770      	bx	lr
   8055e:	bf00      	nop
   80560:	20000460 	.word	0x20000460
   80564:	20009d18 	.word	0x20009d18
   80568:	20000008 	.word	0x20000008

0008056c <prvInsertBlockIntoFreeList>:
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( xBlockLink *pxBlockToInsert )
{
   8056c:	b410      	push	{r4}
xBlockLink *pxIterator;
unsigned char *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
   8056e:	4a13      	ldr	r2, [pc, #76]	; (805bc <prvInsertBlockIntoFreeList+0x50>)
   80570:	e000      	b.n	80574 <prvInsertBlockIntoFreeList+0x8>
   80572:	461a      	mov	r2, r3
   80574:	6813      	ldr	r3, [r2, #0]
   80576:	4283      	cmp	r3, r0
   80578:	d3fb      	bcc.n	80572 <prvInsertBlockIntoFreeList+0x6>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */	
	puc = ( unsigned char * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( unsigned char * ) pxBlockToInsert )
   8057a:	6851      	ldr	r1, [r2, #4]
   8057c:	1854      	adds	r4, r2, r1
   8057e:	42a0      	cmp	r0, r4
   80580:	d009      	beq.n	80596 <prvInsertBlockIntoFreeList+0x2a>
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( unsigned char * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( unsigned char * ) pxIterator->pxNextFreeBlock )
   80582:	6841      	ldr	r1, [r0, #4]
   80584:	1844      	adds	r4, r0, r1
   80586:	42a3      	cmp	r3, r4
   80588:	d00a      	beq.n	805a0 <prvInsertBlockIntoFreeList+0x34>
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;		
   8058a:	6003      	str	r3, [r0, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
   8058c:	4290      	cmp	r0, r2
   8058e:	d000      	beq.n	80592 <prvInsertBlockIntoFreeList+0x26>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
   80590:	6010      	str	r0, [r2, #0]
	}
}
   80592:	bc10      	pop	{r4}
   80594:	4770      	bx	lr
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
   80596:	6840      	ldr	r0, [r0, #4]
   80598:	4401      	add	r1, r0
   8059a:	6051      	str	r1, [r2, #4]
		pxBlockToInsert = pxIterator;
   8059c:	4610      	mov	r0, r2
   8059e:	e7f0      	b.n	80582 <prvInsertBlockIntoFreeList+0x16>
		if( pxIterator->pxNextFreeBlock != pxEnd )
   805a0:	4c07      	ldr	r4, [pc, #28]	; (805c0 <prvInsertBlockIntoFreeList+0x54>)
   805a2:	f8d4 4750 	ldr.w	r4, [r4, #1872]	; 0x750
   805a6:	42a3      	cmp	r3, r4
   805a8:	d006      	beq.n	805b8 <prvInsertBlockIntoFreeList+0x4c>
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
   805aa:	685b      	ldr	r3, [r3, #4]
   805ac:	4419      	add	r1, r3
   805ae:	6041      	str	r1, [r0, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
   805b0:	6813      	ldr	r3, [r2, #0]
   805b2:	681b      	ldr	r3, [r3, #0]
   805b4:	6003      	str	r3, [r0, #0]
   805b6:	e7e9      	b.n	8058c <prvInsertBlockIntoFreeList+0x20>
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
   805b8:	6004      	str	r4, [r0, #0]
   805ba:	e7e7      	b.n	8058c <prvInsertBlockIntoFreeList+0x20>
   805bc:	20000460 	.word	0x20000460
   805c0:	20009d18 	.word	0x20009d18

000805c4 <pvPortMalloc>:
{
   805c4:	b570      	push	{r4, r5, r6, lr}
   805c6:	4605      	mov	r5, r0
	vTaskSuspendAll();
   805c8:	4b22      	ldr	r3, [pc, #136]	; (80654 <pvPortMalloc+0x90>)
   805ca:	4798      	blx	r3
		if( pxEnd == NULL )
   805cc:	4b22      	ldr	r3, [pc, #136]	; (80658 <pvPortMalloc+0x94>)
   805ce:	f8d3 3750 	ldr.w	r3, [r3, #1872]	; 0x750
   805d2:	b17b      	cbz	r3, 805f4 <pvPortMalloc+0x30>
		if( xWantedSize > 0 )
   805d4:	b135      	cbz	r5, 805e4 <pvPortMalloc+0x20>
			xWantedSize += heapSTRUCT_SIZE;
   805d6:	3510      	adds	r5, #16
			if( xWantedSize & portBYTE_ALIGNMENT_MASK )
   805d8:	f015 0f07 	tst.w	r5, #7
   805dc:	d002      	beq.n	805e4 <pvPortMalloc+0x20>
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
   805de:	f025 0507 	bic.w	r5, r5, #7
   805e2:	3508      	adds	r5, #8
		if( ( xWantedSize > 0 ) && ( xWantedSize < xTotalHeapSize ) )
   805e4:	1e6a      	subs	r2, r5, #1
   805e6:	f649 73fe 	movw	r3, #40958	; 0x9ffe
   805ea:	429a      	cmp	r2, r3
   805ec:	d82a      	bhi.n	80644 <pvPortMalloc+0x80>
			pxBlock = xStart.pxNextFreeBlock;
   805ee:	4a1b      	ldr	r2, [pc, #108]	; (8065c <pvPortMalloc+0x98>)
   805f0:	6814      	ldr	r4, [r2, #0]
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
   805f2:	e004      	b.n	805fe <pvPortMalloc+0x3a>
			prvHeapInit();
   805f4:	4b1a      	ldr	r3, [pc, #104]	; (80660 <pvPortMalloc+0x9c>)
   805f6:	4798      	blx	r3
   805f8:	e7ec      	b.n	805d4 <pvPortMalloc+0x10>
				pxPreviousBlock = pxBlock;
   805fa:	4622      	mov	r2, r4
				pxBlock = pxBlock->pxNextFreeBlock;
   805fc:	461c      	mov	r4, r3
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
   805fe:	6863      	ldr	r3, [r4, #4]
   80600:	429d      	cmp	r5, r3
   80602:	d902      	bls.n	8060a <pvPortMalloc+0x46>
   80604:	6823      	ldr	r3, [r4, #0]
   80606:	2b00      	cmp	r3, #0
   80608:	d1f7      	bne.n	805fa <pvPortMalloc+0x36>
			if( pxBlock != pxEnd )
   8060a:	4b13      	ldr	r3, [pc, #76]	; (80658 <pvPortMalloc+0x94>)
   8060c:	f8d3 3750 	ldr.w	r3, [r3, #1872]	; 0x750
   80610:	429c      	cmp	r4, r3
   80612:	d019      	beq.n	80648 <pvPortMalloc+0x84>
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
   80614:	6816      	ldr	r6, [r2, #0]
   80616:	3610      	adds	r6, #16
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
   80618:	6823      	ldr	r3, [r4, #0]
   8061a:	6013      	str	r3, [r2, #0]
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
   8061c:	6863      	ldr	r3, [r4, #4]
   8061e:	1b5b      	subs	r3, r3, r5
   80620:	2b20      	cmp	r3, #32
   80622:	d809      	bhi.n	80638 <pvPortMalloc+0x74>
				xFreeBytesRemaining -= pxBlock->xBlockSize;
   80624:	6861      	ldr	r1, [r4, #4]
   80626:	4a0f      	ldr	r2, [pc, #60]	; (80664 <pvPortMalloc+0xa0>)
   80628:	6813      	ldr	r3, [r2, #0]
   8062a:	1a5b      	subs	r3, r3, r1
   8062c:	6013      	str	r3, [r2, #0]
	xTaskResumeAll();
   8062e:	4b0e      	ldr	r3, [pc, #56]	; (80668 <pvPortMalloc+0xa4>)
   80630:	4798      	blx	r3
		if( pvReturn == NULL )
   80632:	b15e      	cbz	r6, 8064c <pvPortMalloc+0x88>
}
   80634:	4630      	mov	r0, r6
   80636:	bd70      	pop	{r4, r5, r6, pc}
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
   80638:	1960      	adds	r0, r4, r5
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
   8063a:	6043      	str	r3, [r0, #4]
					pxBlock->xBlockSize = xWantedSize;
   8063c:	6065      	str	r5, [r4, #4]
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
   8063e:	4b0b      	ldr	r3, [pc, #44]	; (8066c <pvPortMalloc+0xa8>)
   80640:	4798      	blx	r3
   80642:	e7ef      	b.n	80624 <pvPortMalloc+0x60>
void *pvReturn = NULL;
   80644:	2600      	movs	r6, #0
   80646:	e7f2      	b.n	8062e <pvPortMalloc+0x6a>
   80648:	2600      	movs	r6, #0
   8064a:	e7f0      	b.n	8062e <pvPortMalloc+0x6a>
			vApplicationMallocFailedHook();
   8064c:	4b08      	ldr	r3, [pc, #32]	; (80670 <pvPortMalloc+0xac>)
   8064e:	4798      	blx	r3
	return pvReturn;
   80650:	e7f0      	b.n	80634 <pvPortMalloc+0x70>
   80652:	bf00      	nop
   80654:	00080925 	.word	0x00080925
   80658:	20009d18 	.word	0x20009d18
   8065c:	20000460 	.word	0x20000460
   80660:	00080529 	.word	0x00080529
   80664:	20000008 	.word	0x20000008
   80668:	00080a61 	.word	0x00080a61
   8066c:	0008056d 	.word	0x0008056d
   80670:	00080ef5 	.word	0x00080ef5

00080674 <vPortFree>:
	if( pv != NULL )
   80674:	b188      	cbz	r0, 8069a <vPortFree+0x26>
{
   80676:	b538      	push	{r3, r4, r5, lr}
   80678:	4604      	mov	r4, r0
		puc -= heapSTRUCT_SIZE;
   8067a:	f1a0 0510 	sub.w	r5, r0, #16
		vTaskSuspendAll();
   8067e:	4b07      	ldr	r3, [pc, #28]	; (8069c <vPortFree+0x28>)
   80680:	4798      	blx	r3
			xFreeBytesRemaining += pxLink->xBlockSize;
   80682:	f854 1c0c 	ldr.w	r1, [r4, #-12]
   80686:	4a06      	ldr	r2, [pc, #24]	; (806a0 <vPortFree+0x2c>)
   80688:	6813      	ldr	r3, [r2, #0]
   8068a:	440b      	add	r3, r1
   8068c:	6013      	str	r3, [r2, #0]
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );			
   8068e:	4628      	mov	r0, r5
   80690:	4b04      	ldr	r3, [pc, #16]	; (806a4 <vPortFree+0x30>)
   80692:	4798      	blx	r3
		xTaskResumeAll();
   80694:	4b04      	ldr	r3, [pc, #16]	; (806a8 <vPortFree+0x34>)
   80696:	4798      	blx	r3
   80698:	bd38      	pop	{r3, r4, r5, pc}
   8069a:	4770      	bx	lr
   8069c:	00080925 	.word	0x00080925
   806a0:	20000008 	.word	0x20000008
   806a4:	0008056d 	.word	0x0008056d
   806a8:	00080a61 	.word	0x00080a61

000806ac <prvAllocateTCBAndStack>:
	}
}
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
   806ac:	b570      	push	{r4, r5, r6, lr}
   806ae:	4606      	mov	r6, r0
   806b0:	460c      	mov	r4, r1
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
   806b2:	204c      	movs	r0, #76	; 0x4c
   806b4:	4b0b      	ldr	r3, [pc, #44]	; (806e4 <prvAllocateTCBAndStack+0x38>)
   806b6:	4798      	blx	r3

	if( pxNewTCB != NULL )
   806b8:	4605      	mov	r5, r0
   806ba:	b138      	cbz	r0, 806cc <prvAllocateTCBAndStack+0x20>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
   806bc:	b144      	cbz	r4, 806d0 <prvAllocateTCBAndStack+0x24>
   806be:	632c      	str	r4, [r5, #48]	; 0x30

		if( pxNewTCB->pxStack == NULL )
   806c0:	b15c      	cbz	r4, 806da <prvAllocateTCBAndStack+0x2e>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
   806c2:	00b2      	lsls	r2, r6, #2
   806c4:	21a5      	movs	r1, #165	; 0xa5
   806c6:	4620      	mov	r0, r4
   806c8:	4b07      	ldr	r3, [pc, #28]	; (806e8 <prvAllocateTCBAndStack+0x3c>)
   806ca:	4798      	blx	r3
		}
	}

	return pxNewTCB;
}
   806cc:	4628      	mov	r0, r5
   806ce:	bd70      	pop	{r4, r5, r6, pc}
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
   806d0:	00b0      	lsls	r0, r6, #2
   806d2:	4b04      	ldr	r3, [pc, #16]	; (806e4 <prvAllocateTCBAndStack+0x38>)
   806d4:	4798      	blx	r3
   806d6:	4604      	mov	r4, r0
   806d8:	e7f1      	b.n	806be <prvAllocateTCBAndStack+0x12>
			vPortFree( pxNewTCB );
   806da:	4628      	mov	r0, r5
   806dc:	4b03      	ldr	r3, [pc, #12]	; (806ec <prvAllocateTCBAndStack+0x40>)
   806de:	4798      	blx	r3
			pxNewTCB = NULL;
   806e0:	2500      	movs	r5, #0
   806e2:	e7f3      	b.n	806cc <prvAllocateTCBAndStack+0x20>
   806e4:	000805c5 	.word	0x000805c5
   806e8:	0008157d 	.word	0x0008157d
   806ec:	00080675 	.word	0x00080675

000806f0 <prvInitialiseTCBVariables>:
{
   806f0:	b570      	push	{r4, r5, r6, lr}
   806f2:	4604      	mov	r4, r0
   806f4:	4615      	mov	r5, r2
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
   806f6:	220a      	movs	r2, #10
   806f8:	3034      	adds	r0, #52	; 0x34
   806fa:	4b0b      	ldr	r3, [pc, #44]	; (80728 <prvInitialiseTCBVariables+0x38>)
   806fc:	4798      	blx	r3
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
   806fe:	2300      	movs	r3, #0
   80700:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
	if( uxPriority >= configMAX_PRIORITIES )
   80704:	2d04      	cmp	r5, #4
   80706:	d900      	bls.n	8070a <prvInitialiseTCBVariables+0x1a>
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
   80708:	2504      	movs	r5, #4
	pxTCB->uxPriority = uxPriority;
   8070a:	62e5      	str	r5, [r4, #44]	; 0x2c
		pxTCB->uxBasePriority = uxPriority;
   8070c:	64a5      	str	r5, [r4, #72]	; 0x48
	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
   8070e:	1d20      	adds	r0, r4, #4
   80710:	4e06      	ldr	r6, [pc, #24]	; (8072c <prvInitialiseTCBVariables+0x3c>)
   80712:	47b0      	blx	r6
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
   80714:	f104 0018 	add.w	r0, r4, #24
   80718:	47b0      	blx	r6
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
   8071a:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
   8071c:	f1c5 0505 	rsb	r5, r5, #5
   80720:	61a5      	str	r5, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
   80722:	6264      	str	r4, [r4, #36]	; 0x24
   80724:	bd70      	pop	{r4, r5, r6, pc}
   80726:	bf00      	nop
   80728:	00081619 	.word	0x00081619
   8072c:	000803a7 	.word	0x000803a7

00080730 <prvInitialiseTaskLists>:
{
   80730:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
   80732:	2400      	movs	r4, #0
   80734:	2c04      	cmp	r4, #4
   80736:	d917      	bls.n	80768 <prvInitialiseTaskLists+0x38>
	vListInitialise( ( xList * ) &xDelayedTaskList1 );
   80738:	4c0f      	ldr	r4, [pc, #60]	; (80778 <prvInitialiseTaskLists+0x48>)
   8073a:	f104 0764 	add.w	r7, r4, #100	; 0x64
   8073e:	4638      	mov	r0, r7
   80740:	4d0e      	ldr	r5, [pc, #56]	; (8077c <prvInitialiseTaskLists+0x4c>)
   80742:	47a8      	blx	r5
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
   80744:	f104 0678 	add.w	r6, r4, #120	; 0x78
   80748:	4630      	mov	r0, r6
   8074a:	47a8      	blx	r5
	vListInitialise( ( xList * ) &xPendingReadyList );
   8074c:	f104 008c 	add.w	r0, r4, #140	; 0x8c
   80750:	47a8      	blx	r5
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
   80752:	f104 00a0 	add.w	r0, r4, #160	; 0xa0
   80756:	47a8      	blx	r5
		vListInitialise( ( xList * ) &xSuspendedTaskList );
   80758:	f104 00b4 	add.w	r0, r4, #180	; 0xb4
   8075c:	47a8      	blx	r5
	pxDelayedTaskList = &xDelayedTaskList1;
   8075e:	f8c4 70c8 	str.w	r7, [r4, #200]	; 0xc8
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
   80762:	f8c4 60cc 	str.w	r6, [r4, #204]	; 0xcc
   80766:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
   80768:	2014      	movs	r0, #20
   8076a:	4b03      	ldr	r3, [pc, #12]	; (80778 <prvInitialiseTaskLists+0x48>)
   8076c:	fb00 3004 	mla	r0, r0, r4, r3
   80770:	4b02      	ldr	r3, [pc, #8]	; (8077c <prvInitialiseTaskLists+0x4c>)
   80772:	4798      	blx	r3
	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
   80774:	3401      	adds	r4, #1
   80776:	e7dd      	b.n	80734 <prvInitialiseTaskLists+0x4>
   80778:	2000a46c 	.word	0x2000a46c
   8077c:	00080391 	.word	0x00080391

00080780 <prvAddCurrentTaskToDelayedList>:
{
   80780:	b510      	push	{r4, lr}
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
   80782:	4b10      	ldr	r3, [pc, #64]	; (807c4 <prvAddCurrentTaskToDelayedList+0x44>)
   80784:	f8d3 20d0 	ldr.w	r2, [r3, #208]	; 0xd0
   80788:	6050      	str	r0, [r2, #4]
	if( xTimeToWake < xTickCount )
   8078a:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
   8078e:	4298      	cmp	r0, r3
   80790:	d30f      	bcc.n	807b2 <prvAddCurrentTaskToDelayedList+0x32>
   80792:	4604      	mov	r4, r0
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
   80794:	4b0b      	ldr	r3, [pc, #44]	; (807c4 <prvAddCurrentTaskToDelayedList+0x44>)
   80796:	f8d3 00c8 	ldr.w	r0, [r3, #200]	; 0xc8
   8079a:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   8079e:	3104      	adds	r1, #4
   807a0:	4b09      	ldr	r3, [pc, #36]	; (807c8 <prvAddCurrentTaskToDelayedList+0x48>)
   807a2:	4798      	blx	r3
		if( xTimeToWake < xNextTaskUnblockTime )
   807a4:	4b09      	ldr	r3, [pc, #36]	; (807cc <prvAddCurrentTaskToDelayedList+0x4c>)
   807a6:	681b      	ldr	r3, [r3, #0]
   807a8:	429c      	cmp	r4, r3
   807aa:	d201      	bcs.n	807b0 <prvAddCurrentTaskToDelayedList+0x30>
			xNextTaskUnblockTime = xTimeToWake;
   807ac:	4b07      	ldr	r3, [pc, #28]	; (807cc <prvAddCurrentTaskToDelayedList+0x4c>)
   807ae:	601c      	str	r4, [r3, #0]
   807b0:	bd10      	pop	{r4, pc}
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
   807b2:	4b04      	ldr	r3, [pc, #16]	; (807c4 <prvAddCurrentTaskToDelayedList+0x44>)
   807b4:	f8d3 00cc 	ldr.w	r0, [r3, #204]	; 0xcc
   807b8:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   807bc:	3104      	adds	r1, #4
   807be:	4b02      	ldr	r3, [pc, #8]	; (807c8 <prvAddCurrentTaskToDelayedList+0x48>)
   807c0:	4798      	blx	r3
   807c2:	bd10      	pop	{r4, pc}
   807c4:	2000a46c 	.word	0x2000a46c
   807c8:	000803c9 	.word	0x000803c9
   807cc:	2000000c 	.word	0x2000000c

000807d0 <xTaskGenericCreate>:
{
   807d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   807d4:	b083      	sub	sp, #12
   807d6:	9e0c      	ldr	r6, [sp, #48]	; 0x30
   807d8:	f8dd 8034 	ldr.w	r8, [sp, #52]	; 0x34
	configASSERT( pxTaskCode );
   807dc:	b148      	cbz	r0, 807f2 <xTaskGenericCreate+0x22>
   807de:	468b      	mov	fp, r1
   807e0:	4617      	mov	r7, r2
   807e2:	469a      	mov	sl, r3
   807e4:	4681      	mov	r9, r0
	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
   807e6:	2e04      	cmp	r6, #4
   807e8:	d907      	bls.n	807fa <xTaskGenericCreate+0x2a>
   807ea:	4b44      	ldr	r3, [pc, #272]	; (808fc <xTaskGenericCreate+0x12c>)
   807ec:	4798      	blx	r3
   807ee:	bf00      	nop
   807f0:	e7fd      	b.n	807ee <xTaskGenericCreate+0x1e>
	configASSERT( pxTaskCode );
   807f2:	4b42      	ldr	r3, [pc, #264]	; (808fc <xTaskGenericCreate+0x12c>)
   807f4:	4798      	blx	r3
   807f6:	bf00      	nop
   807f8:	e7fd      	b.n	807f6 <xTaskGenericCreate+0x26>
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
   807fa:	990e      	ldr	r1, [sp, #56]	; 0x38
   807fc:	4610      	mov	r0, r2
   807fe:	4b40      	ldr	r3, [pc, #256]	; (80900 <xTaskGenericCreate+0x130>)
   80800:	4798      	blx	r3
	if( pxNewTCB != NULL )
   80802:	4604      	mov	r4, r0
   80804:	2800      	cmp	r0, #0
   80806:	d068      	beq.n	808da <xTaskGenericCreate+0x10a>
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
   80808:	6b03      	ldr	r3, [r0, #48]	; 0x30
   8080a:	f107 4580 	add.w	r5, r7, #1073741824	; 0x40000000
   8080e:	3d01      	subs	r5, #1
   80810:	eb03 0385 	add.w	r3, r3, r5, lsl #2
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK  ) );
   80814:	f023 0507 	bic.w	r5, r3, #7
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
   80818:	9700      	str	r7, [sp, #0]
   8081a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   8081c:	4632      	mov	r2, r6
   8081e:	4659      	mov	r1, fp
   80820:	4f38      	ldr	r7, [pc, #224]	; (80904 <xTaskGenericCreate+0x134>)
   80822:	47b8      	blx	r7
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
   80824:	4652      	mov	r2, sl
   80826:	4649      	mov	r1, r9
   80828:	4628      	mov	r0, r5
   8082a:	4b37      	ldr	r3, [pc, #220]	; (80908 <xTaskGenericCreate+0x138>)
   8082c:	4798      	blx	r3
   8082e:	6020      	str	r0, [r4, #0]
		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
   80830:	f010 0f07 	tst.w	r0, #7
   80834:	d11d      	bne.n	80872 <xTaskGenericCreate+0xa2>
		if( ( void * ) pxCreatedTask != NULL )
   80836:	f1b8 0f00 	cmp.w	r8, #0
   8083a:	d001      	beq.n	80840 <xTaskGenericCreate+0x70>
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
   8083c:	f8c8 4000 	str.w	r4, [r8]
		taskENTER_CRITICAL();
   80840:	4b32      	ldr	r3, [pc, #200]	; (8090c <xTaskGenericCreate+0x13c>)
   80842:	4798      	blx	r3
			uxCurrentNumberOfTasks++;
   80844:	4b32      	ldr	r3, [pc, #200]	; (80910 <xTaskGenericCreate+0x140>)
   80846:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
   8084a:	3201      	adds	r2, #1
   8084c:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
			if( pxCurrentTCB == NULL )
   80850:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
   80854:	b18b      	cbz	r3, 8087a <xTaskGenericCreate+0xaa>
				if( xSchedulerRunning == pdFALSE )
   80856:	4b2e      	ldr	r3, [pc, #184]	; (80910 <xTaskGenericCreate+0x140>)
   80858:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
   8085c:	b9b3      	cbnz	r3, 8088c <xTaskGenericCreate+0xbc>
					if( pxCurrentTCB->uxPriority <= uxPriority )
   8085e:	4b2c      	ldr	r3, [pc, #176]	; (80910 <xTaskGenericCreate+0x140>)
   80860:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
   80864:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   80866:	429e      	cmp	r6, r3
   80868:	d310      	bcc.n	8088c <xTaskGenericCreate+0xbc>
						pxCurrentTCB = pxNewTCB;
   8086a:	4b29      	ldr	r3, [pc, #164]	; (80910 <xTaskGenericCreate+0x140>)
   8086c:	f8c3 40d0 	str.w	r4, [r3, #208]	; 0xd0
   80870:	e00c      	b.n	8088c <xTaskGenericCreate+0xbc>
		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
   80872:	4b22      	ldr	r3, [pc, #136]	; (808fc <xTaskGenericCreate+0x12c>)
   80874:	4798      	blx	r3
   80876:	bf00      	nop
   80878:	e7fd      	b.n	80876 <xTaskGenericCreate+0xa6>
				pxCurrentTCB =  pxNewTCB;
   8087a:	4b25      	ldr	r3, [pc, #148]	; (80910 <xTaskGenericCreate+0x140>)
   8087c:	f8c3 40d0 	str.w	r4, [r3, #208]	; 0xd0
				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
   80880:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
   80884:	2b01      	cmp	r3, #1
   80886:	d101      	bne.n	8088c <xTaskGenericCreate+0xbc>
					prvInitialiseTaskLists();
   80888:	4b22      	ldr	r3, [pc, #136]	; (80914 <xTaskGenericCreate+0x144>)
   8088a:	4798      	blx	r3
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
   8088c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   8088e:	4a20      	ldr	r2, [pc, #128]	; (80910 <xTaskGenericCreate+0x140>)
   80890:	f8d2 2108 	ldr.w	r2, [r2, #264]	; 0x108
   80894:	4293      	cmp	r3, r2
   80896:	d902      	bls.n	8089e <xTaskGenericCreate+0xce>
				uxTopUsedPriority = pxNewTCB->uxPriority;
   80898:	4a1d      	ldr	r2, [pc, #116]	; (80910 <xTaskGenericCreate+0x140>)
   8089a:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
				pxNewTCB->uxTCBNumber = uxTaskNumber;
   8089e:	491c      	ldr	r1, [pc, #112]	; (80910 <xTaskGenericCreate+0x140>)
   808a0:	f8d1 210c 	ldr.w	r2, [r1, #268]	; 0x10c
   808a4:	6422      	str	r2, [r4, #64]	; 0x40
			uxTaskNumber++;
   808a6:	3201      	adds	r2, #1
   808a8:	f8c1 210c 	str.w	r2, [r1, #268]	; 0x10c
			prvAddTaskToReadyQueue( pxNewTCB );
   808ac:	f8d1 2110 	ldr.w	r2, [r1, #272]	; 0x110
   808b0:	4293      	cmp	r3, r2
   808b2:	d901      	bls.n	808b8 <xTaskGenericCreate+0xe8>
   808b4:	f8c1 3110 	str.w	r3, [r1, #272]	; 0x110
   808b8:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   808bc:	009a      	lsls	r2, r3, #2
   808be:	1d21      	adds	r1, r4, #4
   808c0:	4813      	ldr	r0, [pc, #76]	; (80910 <xTaskGenericCreate+0x140>)
   808c2:	4410      	add	r0, r2
   808c4:	4b14      	ldr	r3, [pc, #80]	; (80918 <xTaskGenericCreate+0x148>)
   808c6:	4798      	blx	r3
		taskEXIT_CRITICAL();
   808c8:	4b14      	ldr	r3, [pc, #80]	; (8091c <xTaskGenericCreate+0x14c>)
   808ca:	4798      	blx	r3
			xReturn = pdPASS;
   808cc:	2401      	movs	r4, #1
	if( xReturn == pdPASS )
   808ce:	2c01      	cmp	r4, #1
   808d0:	d006      	beq.n	808e0 <xTaskGenericCreate+0x110>
}
   808d2:	4620      	mov	r0, r4
   808d4:	b003      	add	sp, #12
   808d6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
   808da:	f04f 34ff 	mov.w	r4, #4294967295
   808de:	e7f6      	b.n	808ce <xTaskGenericCreate+0xfe>
		if( xSchedulerRunning != pdFALSE )
   808e0:	4b0b      	ldr	r3, [pc, #44]	; (80910 <xTaskGenericCreate+0x140>)
   808e2:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
   808e6:	2b00      	cmp	r3, #0
   808e8:	d0f3      	beq.n	808d2 <xTaskGenericCreate+0x102>
			if( pxCurrentTCB->uxPriority < uxPriority )
   808ea:	4b09      	ldr	r3, [pc, #36]	; (80910 <xTaskGenericCreate+0x140>)
   808ec:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
   808f0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   808f2:	429e      	cmp	r6, r3
   808f4:	d9ed      	bls.n	808d2 <xTaskGenericCreate+0x102>
				portYIELD_WITHIN_API();
   808f6:	4b0a      	ldr	r3, [pc, #40]	; (80920 <xTaskGenericCreate+0x150>)
   808f8:	4798      	blx	r3
	return xReturn;
   808fa:	e7ea      	b.n	808d2 <xTaskGenericCreate+0x102>
   808fc:	00080471 	.word	0x00080471
   80900:	000806ad 	.word	0x000806ad
   80904:	000806f1 	.word	0x000806f1
   80908:	00080425 	.word	0x00080425
   8090c:	00080481 	.word	0x00080481
   80910:	2000a46c 	.word	0x2000a46c
   80914:	00080731 	.word	0x00080731
   80918:	000803ad 	.word	0x000803ad
   8091c:	000804a1 	.word	0x000804a1
   80920:	00080461 	.word	0x00080461

00080924 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
   80924:	4a03      	ldr	r2, [pc, #12]	; (80934 <vTaskSuspendAll+0x10>)
   80926:	f8d2 3118 	ldr.w	r3, [r2, #280]	; 0x118
   8092a:	3301      	adds	r3, #1
   8092c:	f8c2 3118 	str.w	r3, [r2, #280]	; 0x118
   80930:	4770      	bx	lr
   80932:	bf00      	nop
   80934:	2000a46c 	.word	0x2000a46c

00080938 <xTaskGetTickCount>:
{
   80938:	b510      	push	{r4, lr}
	taskENTER_CRITICAL();
   8093a:	4b04      	ldr	r3, [pc, #16]	; (8094c <xTaskGetTickCount+0x14>)
   8093c:	4798      	blx	r3
		xTicks = xTickCount;
   8093e:	4b04      	ldr	r3, [pc, #16]	; (80950 <xTaskGetTickCount+0x18>)
   80940:	f8d3 40d4 	ldr.w	r4, [r3, #212]	; 0xd4
	taskEXIT_CRITICAL();
   80944:	4b03      	ldr	r3, [pc, #12]	; (80954 <xTaskGetTickCount+0x1c>)
   80946:	4798      	blx	r3
}
   80948:	4620      	mov	r0, r4
   8094a:	bd10      	pop	{r4, pc}
   8094c:	00080481 	.word	0x00080481
   80950:	2000a46c 	.word	0x2000a46c
   80954:	000804a1 	.word	0x000804a1

00080958 <vTaskIncrementTick>:
{
   80958:	b538      	push	{r3, r4, r5, lr}
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
   8095a:	4b3c      	ldr	r3, [pc, #240]	; (80a4c <vTaskIncrementTick+0xf4>)
   8095c:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
   80960:	2b00      	cmp	r3, #0
   80962:	d16c      	bne.n	80a3e <vTaskIncrementTick+0xe6>
		++xTickCount;
   80964:	4b39      	ldr	r3, [pc, #228]	; (80a4c <vTaskIncrementTick+0xf4>)
   80966:	f8d3 20d4 	ldr.w	r2, [r3, #212]	; 0xd4
   8096a:	3201      	adds	r2, #1
   8096c:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
		if( xTickCount == ( portTickType ) 0U )
   80970:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
   80974:	b9d3      	cbnz	r3, 809ac <vTaskIncrementTick+0x54>
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
   80976:	4b35      	ldr	r3, [pc, #212]	; (80a4c <vTaskIncrementTick+0xf4>)
   80978:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
   8097c:	681b      	ldr	r3, [r3, #0]
   8097e:	b9eb      	cbnz	r3, 809bc <vTaskIncrementTick+0x64>
			pxTemp = pxDelayedTaskList;
   80980:	4b32      	ldr	r3, [pc, #200]	; (80a4c <vTaskIncrementTick+0xf4>)
   80982:	f8d3 20c8 	ldr.w	r2, [r3, #200]	; 0xc8
			pxDelayedTaskList = pxOverflowDelayedTaskList;
   80986:	f8d3 10cc 	ldr.w	r1, [r3, #204]	; 0xcc
   8098a:	f8c3 10c8 	str.w	r1, [r3, #200]	; 0xc8
			pxOverflowDelayedTaskList = pxTemp;
   8098e:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc
			xNumOfOverflows++;
   80992:	f8d3 211c 	ldr.w	r2, [r3, #284]	; 0x11c
   80996:	3201      	adds	r2, #1
   80998:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   8099c:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
   809a0:	681b      	ldr	r3, [r3, #0]
   809a2:	b97b      	cbnz	r3, 809c4 <vTaskIncrementTick+0x6c>
				xNextTaskUnblockTime = portMAX_DELAY;
   809a4:	f04f 32ff 	mov.w	r2, #4294967295
   809a8:	4b29      	ldr	r3, [pc, #164]	; (80a50 <vTaskIncrementTick+0xf8>)
   809aa:	601a      	str	r2, [r3, #0]
		prvCheckDelayedTasks();
   809ac:	4b27      	ldr	r3, [pc, #156]	; (80a4c <vTaskIncrementTick+0xf4>)
   809ae:	f8d3 20d4 	ldr.w	r2, [r3, #212]	; 0xd4
   809b2:	4b27      	ldr	r3, [pc, #156]	; (80a50 <vTaskIncrementTick+0xf8>)
   809b4:	681b      	ldr	r3, [r3, #0]
   809b6:	429a      	cmp	r2, r3
   809b8:	d21d      	bcs.n	809f6 <vTaskIncrementTick+0x9e>
   809ba:	e046      	b.n	80a4a <vTaskIncrementTick+0xf2>
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
   809bc:	4b25      	ldr	r3, [pc, #148]	; (80a54 <vTaskIncrementTick+0xfc>)
   809be:	4798      	blx	r3
   809c0:	bf00      	nop
   809c2:	e7fd      	b.n	809c0 <vTaskIncrementTick+0x68>
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
   809c4:	4b21      	ldr	r3, [pc, #132]	; (80a4c <vTaskIncrementTick+0xf4>)
   809c6:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
   809ca:	68db      	ldr	r3, [r3, #12]
   809cc:	68db      	ldr	r3, [r3, #12]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
   809ce:	685a      	ldr	r2, [r3, #4]
   809d0:	4b1f      	ldr	r3, [pc, #124]	; (80a50 <vTaskIncrementTick+0xf8>)
   809d2:	601a      	str	r2, [r3, #0]
   809d4:	e7ea      	b.n	809ac <vTaskIncrementTick+0x54>
		prvCheckDelayedTasks();
   809d6:	f04f 32ff 	mov.w	r2, #4294967295
   809da:	4b1d      	ldr	r3, [pc, #116]	; (80a50 <vTaskIncrementTick+0xf8>)
   809dc:	601a      	str	r2, [r3, #0]
   809de:	bd38      	pop	{r3, r4, r5, pc}
   809e0:	4b1b      	ldr	r3, [pc, #108]	; (80a50 <vTaskIncrementTick+0xf8>)
   809e2:	601a      	str	r2, [r3, #0]
   809e4:	bd38      	pop	{r3, r4, r5, pc}
   809e6:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   809ea:	009a      	lsls	r2, r3, #2
   809ec:	4629      	mov	r1, r5
   809ee:	4817      	ldr	r0, [pc, #92]	; (80a4c <vTaskIncrementTick+0xf4>)
   809f0:	4410      	add	r0, r2
   809f2:	4b19      	ldr	r3, [pc, #100]	; (80a58 <vTaskIncrementTick+0x100>)
   809f4:	4798      	blx	r3
   809f6:	4b15      	ldr	r3, [pc, #84]	; (80a4c <vTaskIncrementTick+0xf4>)
   809f8:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
   809fc:	681b      	ldr	r3, [r3, #0]
   809fe:	2b00      	cmp	r3, #0
   80a00:	d0e9      	beq.n	809d6 <vTaskIncrementTick+0x7e>
   80a02:	4b12      	ldr	r3, [pc, #72]	; (80a4c <vTaskIncrementTick+0xf4>)
   80a04:	f8d3 20c8 	ldr.w	r2, [r3, #200]	; 0xc8
   80a08:	68d2      	ldr	r2, [r2, #12]
   80a0a:	68d4      	ldr	r4, [r2, #12]
   80a0c:	6862      	ldr	r2, [r4, #4]
   80a0e:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
   80a12:	429a      	cmp	r2, r3
   80a14:	d8e4      	bhi.n	809e0 <vTaskIncrementTick+0x88>
   80a16:	1d25      	adds	r5, r4, #4
   80a18:	4628      	mov	r0, r5
   80a1a:	4b10      	ldr	r3, [pc, #64]	; (80a5c <vTaskIncrementTick+0x104>)
   80a1c:	4798      	blx	r3
   80a1e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   80a20:	b11b      	cbz	r3, 80a2a <vTaskIncrementTick+0xd2>
   80a22:	f104 0018 	add.w	r0, r4, #24
   80a26:	4b0d      	ldr	r3, [pc, #52]	; (80a5c <vTaskIncrementTick+0x104>)
   80a28:	4798      	blx	r3
   80a2a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   80a2c:	4a07      	ldr	r2, [pc, #28]	; (80a4c <vTaskIncrementTick+0xf4>)
   80a2e:	f8d2 2110 	ldr.w	r2, [r2, #272]	; 0x110
   80a32:	4293      	cmp	r3, r2
   80a34:	d9d7      	bls.n	809e6 <vTaskIncrementTick+0x8e>
   80a36:	4a05      	ldr	r2, [pc, #20]	; (80a4c <vTaskIncrementTick+0xf4>)
   80a38:	f8c2 3110 	str.w	r3, [r2, #272]	; 0x110
   80a3c:	e7d3      	b.n	809e6 <vTaskIncrementTick+0x8e>
		++uxMissedTicks;
   80a3e:	4a03      	ldr	r2, [pc, #12]	; (80a4c <vTaskIncrementTick+0xf4>)
   80a40:	f8d2 3120 	ldr.w	r3, [r2, #288]	; 0x120
   80a44:	3301      	adds	r3, #1
   80a46:	f8c2 3120 	str.w	r3, [r2, #288]	; 0x120
   80a4a:	bd38      	pop	{r3, r4, r5, pc}
   80a4c:	2000a46c 	.word	0x2000a46c
   80a50:	2000000c 	.word	0x2000000c
   80a54:	00080471 	.word	0x00080471
   80a58:	000803ad 	.word	0x000803ad
   80a5c:	000803fd 	.word	0x000803fd

00080a60 <xTaskResumeAll>:
{
   80a60:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	configASSERT( uxSchedulerSuspended );
   80a64:	4b34      	ldr	r3, [pc, #208]	; (80b38 <xTaskResumeAll+0xd8>)
   80a66:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
   80a6a:	b91b      	cbnz	r3, 80a74 <xTaskResumeAll+0x14>
   80a6c:	4b33      	ldr	r3, [pc, #204]	; (80b3c <xTaskResumeAll+0xdc>)
   80a6e:	4798      	blx	r3
   80a70:	bf00      	nop
   80a72:	e7fd      	b.n	80a70 <xTaskResumeAll+0x10>
	taskENTER_CRITICAL();
   80a74:	4b32      	ldr	r3, [pc, #200]	; (80b40 <xTaskResumeAll+0xe0>)
   80a76:	4798      	blx	r3
		--uxSchedulerSuspended;
   80a78:	4b2f      	ldr	r3, [pc, #188]	; (80b38 <xTaskResumeAll+0xd8>)
   80a7a:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
   80a7e:	3a01      	subs	r2, #1
   80a80:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
   80a84:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
   80a88:	2b00      	cmp	r3, #0
   80a8a:	d152      	bne.n	80b32 <xTaskResumeAll+0xd2>
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
   80a8c:	4b2a      	ldr	r3, [pc, #168]	; (80b38 <xTaskResumeAll+0xd8>)
   80a8e:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
   80a92:	b33b      	cbz	r3, 80ae4 <xTaskResumeAll+0x84>
   80a94:	2400      	movs	r4, #0
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
   80a96:	4b28      	ldr	r3, [pc, #160]	; (80b38 <xTaskResumeAll+0xd8>)
   80a98:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
   80a9c:	b343      	cbz	r3, 80af0 <xTaskResumeAll+0x90>
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
   80a9e:	4e26      	ldr	r6, [pc, #152]	; (80b38 <xTaskResumeAll+0xd8>)
   80aa0:	f8d6 3098 	ldr.w	r3, [r6, #152]	; 0x98
   80aa4:	68dd      	ldr	r5, [r3, #12]
					uxListRemove( &( pxTCB->xEventListItem ) );
   80aa6:	f105 0018 	add.w	r0, r5, #24
   80aaa:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 80b54 <xTaskResumeAll+0xf4>
   80aae:	47c0      	blx	r8
					uxListRemove( &( pxTCB->xGenericListItem ) );
   80ab0:	1d2f      	adds	r7, r5, #4
   80ab2:	4638      	mov	r0, r7
   80ab4:	47c0      	blx	r8
					prvAddTaskToReadyQueue( pxTCB );
   80ab6:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
   80ab8:	f8d6 2110 	ldr.w	r2, [r6, #272]	; 0x110
   80abc:	4293      	cmp	r3, r2
   80abe:	d901      	bls.n	80ac4 <xTaskResumeAll+0x64>
   80ac0:	f8c6 3110 	str.w	r3, [r6, #272]	; 0x110
   80ac4:	4e1c      	ldr	r6, [pc, #112]	; (80b38 <xTaskResumeAll+0xd8>)
   80ac6:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   80aca:	0098      	lsls	r0, r3, #2
   80acc:	4639      	mov	r1, r7
   80ace:	4430      	add	r0, r6
   80ad0:	4b1c      	ldr	r3, [pc, #112]	; (80b44 <xTaskResumeAll+0xe4>)
   80ad2:	4798      	blx	r3
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   80ad4:	6aea      	ldr	r2, [r5, #44]	; 0x2c
   80ad6:	f8d6 30d0 	ldr.w	r3, [r6, #208]	; 0xd0
   80ada:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   80adc:	429a      	cmp	r2, r3
   80ade:	d3da      	bcc.n	80a96 <xTaskResumeAll+0x36>
						xYieldRequired = pdTRUE;
   80ae0:	2401      	movs	r4, #1
   80ae2:	e7d8      	b.n	80a96 <xTaskResumeAll+0x36>
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
   80ae4:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
   80ae6:	4b18      	ldr	r3, [pc, #96]	; (80b48 <xTaskResumeAll+0xe8>)
   80ae8:	4798      	blx	r3
}
   80aea:	4620      	mov	r0, r4
   80aec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
   80af0:	4b11      	ldr	r3, [pc, #68]	; (80b38 <xTaskResumeAll+0xd8>)
   80af2:	f8d3 3120 	ldr.w	r3, [r3, #288]	; 0x120
   80af6:	b9ab      	cbnz	r3, 80b24 <xTaskResumeAll+0xc4>
				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
   80af8:	b924      	cbnz	r4, 80b04 <xTaskResumeAll+0xa4>
   80afa:	4b0f      	ldr	r3, [pc, #60]	; (80b38 <xTaskResumeAll+0xd8>)
   80afc:	f8d3 3124 	ldr.w	r3, [r3, #292]	; 0x124
   80b00:	2b01      	cmp	r3, #1
   80b02:	d1f0      	bne.n	80ae6 <xTaskResumeAll+0x86>
					xMissedYield = pdFALSE;
   80b04:	2200      	movs	r2, #0
   80b06:	4b0c      	ldr	r3, [pc, #48]	; (80b38 <xTaskResumeAll+0xd8>)
   80b08:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
					portYIELD_WITHIN_API();
   80b0c:	4b0f      	ldr	r3, [pc, #60]	; (80b4c <xTaskResumeAll+0xec>)
   80b0e:	4798      	blx	r3
					xAlreadyYielded = pdTRUE;
   80b10:	2401      	movs	r4, #1
   80b12:	e7e8      	b.n	80ae6 <xTaskResumeAll+0x86>
						vTaskIncrementTick();
   80b14:	4b0e      	ldr	r3, [pc, #56]	; (80b50 <xTaskResumeAll+0xf0>)
   80b16:	4798      	blx	r3
						--uxMissedTicks;
   80b18:	4a07      	ldr	r2, [pc, #28]	; (80b38 <xTaskResumeAll+0xd8>)
   80b1a:	f8d2 3120 	ldr.w	r3, [r2, #288]	; 0x120
   80b1e:	3b01      	subs	r3, #1
   80b20:	f8c2 3120 	str.w	r3, [r2, #288]	; 0x120
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
   80b24:	4b04      	ldr	r3, [pc, #16]	; (80b38 <xTaskResumeAll+0xd8>)
   80b26:	f8d3 3120 	ldr.w	r3, [r3, #288]	; 0x120
   80b2a:	2b00      	cmp	r3, #0
   80b2c:	d1f2      	bne.n	80b14 <xTaskResumeAll+0xb4>
						xYieldRequired = pdTRUE;
   80b2e:	2401      	movs	r4, #1
   80b30:	e7e2      	b.n	80af8 <xTaskResumeAll+0x98>
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
   80b32:	2400      	movs	r4, #0
   80b34:	e7d7      	b.n	80ae6 <xTaskResumeAll+0x86>
   80b36:	bf00      	nop
   80b38:	2000a46c 	.word	0x2000a46c
   80b3c:	00080471 	.word	0x00080471
   80b40:	00080481 	.word	0x00080481
   80b44:	000803ad 	.word	0x000803ad
   80b48:	000804a1 	.word	0x000804a1
   80b4c:	00080461 	.word	0x00080461
   80b50:	00080959 	.word	0x00080959
   80b54:	000803fd 	.word	0x000803fd

00080b58 <vTaskDelayUntil>:
	{
   80b58:	b538      	push	{r3, r4, r5, lr}
		configASSERT( pxPreviousWakeTime );
   80b5a:	b130      	cbz	r0, 80b6a <vTaskDelayUntil+0x12>
   80b5c:	460c      	mov	r4, r1
   80b5e:	4605      	mov	r5, r0
		configASSERT( ( xTimeIncrement > 0U ) );
   80b60:	b939      	cbnz	r1, 80b72 <vTaskDelayUntil+0x1a>
   80b62:	4b1e      	ldr	r3, [pc, #120]	; (80bdc <vTaskDelayUntil+0x84>)
   80b64:	4798      	blx	r3
   80b66:	bf00      	nop
   80b68:	e7fd      	b.n	80b66 <vTaskDelayUntil+0xe>
		configASSERT( pxPreviousWakeTime );
   80b6a:	4b1c      	ldr	r3, [pc, #112]	; (80bdc <vTaskDelayUntil+0x84>)
   80b6c:	4798      	blx	r3
   80b6e:	bf00      	nop
   80b70:	e7fd      	b.n	80b6e <vTaskDelayUntil+0x16>
		vTaskSuspendAll();
   80b72:	4b1b      	ldr	r3, [pc, #108]	; (80be0 <vTaskDelayUntil+0x88>)
   80b74:	4798      	blx	r3
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
   80b76:	682b      	ldr	r3, [r5, #0]
   80b78:	441c      	add	r4, r3
			if( xTickCount < *pxPreviousWakeTime )
   80b7a:	4a1a      	ldr	r2, [pc, #104]	; (80be4 <vTaskDelayUntil+0x8c>)
   80b7c:	f8d2 20d4 	ldr.w	r2, [r2, #212]	; 0xd4
   80b80:	4293      	cmp	r3, r2
   80b82:	d90d      	bls.n	80ba0 <vTaskDelayUntil+0x48>
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
   80b84:	42a3      	cmp	r3, r4
   80b86:	d914      	bls.n	80bb2 <vTaskDelayUntil+0x5a>
   80b88:	4b16      	ldr	r3, [pc, #88]	; (80be4 <vTaskDelayUntil+0x8c>)
   80b8a:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
   80b8e:	429c      	cmp	r4, r3
   80b90:	d811      	bhi.n	80bb6 <vTaskDelayUntil+0x5e>
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
   80b92:	2300      	movs	r3, #0
			*pxPreviousWakeTime = xTimeToWake;
   80b94:	602c      	str	r4, [r5, #0]
			if( xShouldDelay != pdFALSE )
   80b96:	b9a3      	cbnz	r3, 80bc2 <vTaskDelayUntil+0x6a>
		xAlreadyYielded = xTaskResumeAll();
   80b98:	4b13      	ldr	r3, [pc, #76]	; (80be8 <vTaskDelayUntil+0x90>)
   80b9a:	4798      	blx	r3
		if( xAlreadyYielded == pdFALSE )
   80b9c:	b1d8      	cbz	r0, 80bd6 <vTaskDelayUntil+0x7e>
   80b9e:	bd38      	pop	{r3, r4, r5, pc}
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
   80ba0:	42a3      	cmp	r3, r4
   80ba2:	d80a      	bhi.n	80bba <vTaskDelayUntil+0x62>
   80ba4:	4b0f      	ldr	r3, [pc, #60]	; (80be4 <vTaskDelayUntil+0x8c>)
   80ba6:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
   80baa:	429c      	cmp	r4, r3
   80bac:	d807      	bhi.n	80bbe <vTaskDelayUntil+0x66>
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
   80bae:	2300      	movs	r3, #0
   80bb0:	e7f0      	b.n	80b94 <vTaskDelayUntil+0x3c>
   80bb2:	2300      	movs	r3, #0
   80bb4:	e7ee      	b.n	80b94 <vTaskDelayUntil+0x3c>
					xShouldDelay = pdTRUE;
   80bb6:	2301      	movs	r3, #1
   80bb8:	e7ec      	b.n	80b94 <vTaskDelayUntil+0x3c>
					xShouldDelay = pdTRUE;
   80bba:	2301      	movs	r3, #1
   80bbc:	e7ea      	b.n	80b94 <vTaskDelayUntil+0x3c>
   80bbe:	2301      	movs	r3, #1
   80bc0:	e7e8      	b.n	80b94 <vTaskDelayUntil+0x3c>
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
   80bc2:	4b08      	ldr	r3, [pc, #32]	; (80be4 <vTaskDelayUntil+0x8c>)
   80bc4:	f8d3 00d0 	ldr.w	r0, [r3, #208]	; 0xd0
   80bc8:	3004      	adds	r0, #4
   80bca:	4b08      	ldr	r3, [pc, #32]	; (80bec <vTaskDelayUntil+0x94>)
   80bcc:	4798      	blx	r3
				prvAddCurrentTaskToDelayedList( xTimeToWake );
   80bce:	4620      	mov	r0, r4
   80bd0:	4b07      	ldr	r3, [pc, #28]	; (80bf0 <vTaskDelayUntil+0x98>)
   80bd2:	4798      	blx	r3
   80bd4:	e7e0      	b.n	80b98 <vTaskDelayUntil+0x40>
			portYIELD_WITHIN_API();
   80bd6:	4b07      	ldr	r3, [pc, #28]	; (80bf4 <vTaskDelayUntil+0x9c>)
   80bd8:	4798      	blx	r3
	}
   80bda:	e7e0      	b.n	80b9e <vTaskDelayUntil+0x46>
   80bdc:	00080471 	.word	0x00080471
   80be0:	00080925 	.word	0x00080925
   80be4:	2000a46c 	.word	0x2000a46c
   80be8:	00080a61 	.word	0x00080a61
   80bec:	000803fd 	.word	0x000803fd
   80bf0:	00080781 	.word	0x00080781
   80bf4:	00080461 	.word	0x00080461

00080bf8 <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
   80bf8:	4b20      	ldr	r3, [pc, #128]	; (80c7c <vTaskSwitchContext+0x84>)
   80bfa:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
   80bfe:	b99b      	cbnz	r3, 80c28 <vTaskSwitchContext+0x30>
{
   80c00:	b510      	push	{r4, lr}
		taskSELECT_HIGHEST_PRIORITY_TASK();
   80c02:	491e      	ldr	r1, [pc, #120]	; (80c7c <vTaskSwitchContext+0x84>)
   80c04:	f8d1 3110 	ldr.w	r3, [r1, #272]	; 0x110
   80c08:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   80c0c:	009a      	lsls	r2, r3, #2
   80c0e:	588b      	ldr	r3, [r1, r2]
   80c10:	b99b      	cbnz	r3, 80c3a <vTaskSwitchContext+0x42>
   80c12:	4b1a      	ldr	r3, [pc, #104]	; (80c7c <vTaskSwitchContext+0x84>)
   80c14:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
   80c18:	b15b      	cbz	r3, 80c32 <vTaskSwitchContext+0x3a>
   80c1a:	4a18      	ldr	r2, [pc, #96]	; (80c7c <vTaskSwitchContext+0x84>)
   80c1c:	f8d2 3110 	ldr.w	r3, [r2, #272]	; 0x110
   80c20:	3b01      	subs	r3, #1
   80c22:	f8c2 3110 	str.w	r3, [r2, #272]	; 0x110
   80c26:	e7ec      	b.n	80c02 <vTaskSwitchContext+0xa>
		xMissedYield = pdTRUE;
   80c28:	2201      	movs	r2, #1
   80c2a:	4b14      	ldr	r3, [pc, #80]	; (80c7c <vTaskSwitchContext+0x84>)
   80c2c:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
   80c30:	4770      	bx	lr
		taskSELECT_HIGHEST_PRIORITY_TASK();
   80c32:	4b13      	ldr	r3, [pc, #76]	; (80c80 <vTaskSwitchContext+0x88>)
   80c34:	4798      	blx	r3
   80c36:	bf00      	nop
   80c38:	e7fd      	b.n	80c36 <vTaskSwitchContext+0x3e>
   80c3a:	460a      	mov	r2, r1
   80c3c:	f8d1 3110 	ldr.w	r3, [r1, #272]	; 0x110
   80c40:	0099      	lsls	r1, r3, #2
   80c42:	18cc      	adds	r4, r1, r3
   80c44:	00a0      	lsls	r0, r4, #2
   80c46:	4410      	add	r0, r2
   80c48:	6844      	ldr	r4, [r0, #4]
   80c4a:	6864      	ldr	r4, [r4, #4]
   80c4c:	6044      	str	r4, [r0, #4]
   80c4e:	4419      	add	r1, r3
   80c50:	0088      	lsls	r0, r1, #2
   80c52:	4601      	mov	r1, r0
   80c54:	3008      	adds	r0, #8
   80c56:	4402      	add	r2, r0
   80c58:	4294      	cmp	r4, r2
   80c5a:	d009      	beq.n	80c70 <vTaskSwitchContext+0x78>
   80c5c:	4907      	ldr	r1, [pc, #28]	; (80c7c <vTaskSwitchContext+0x84>)
   80c5e:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   80c62:	009a      	lsls	r2, r3, #2
   80c64:	440a      	add	r2, r1
   80c66:	6853      	ldr	r3, [r2, #4]
   80c68:	68db      	ldr	r3, [r3, #12]
   80c6a:	f8c1 30d0 	str.w	r3, [r1, #208]	; 0xd0
   80c6e:	bd10      	pop	{r4, pc}
   80c70:	6860      	ldr	r0, [r4, #4]
   80c72:	4a02      	ldr	r2, [pc, #8]	; (80c7c <vTaskSwitchContext+0x84>)
   80c74:	440a      	add	r2, r1
   80c76:	6050      	str	r0, [r2, #4]
   80c78:	e7f0      	b.n	80c5c <vTaskSwitchContext+0x64>
   80c7a:	bf00      	nop
   80c7c:	2000a46c 	.word	0x2000a46c
   80c80:	00080471 	.word	0x00080471

00080c84 <Toggle_Output>:

void Toggle_Output(Pio *PORT,uint8_t PIN)
{
	static uint32_t t;

	t = (PORT->PIO_ODSR>>(PIN))&(0x1);
   80c84:	6b83      	ldr	r3, [r0, #56]	; 0x38
   80c86:	40cb      	lsrs	r3, r1
	if (t)//tests if LED PIO is active
   80c88:	f013 0f01 	tst.w	r3, #1
   80c8c:	d104      	bne.n	80c98 <Toggle_Output+0x14>
	{
		PORT->PIO_CODR = 0x1 << PIN;
	}
	else
	{
		PORT->PIO_SODR= 0x1 << PIN;
   80c8e:	2301      	movs	r3, #1
   80c90:	fa03 f101 	lsl.w	r1, r3, r1
   80c94:	6301      	str	r1, [r0, #48]	; 0x30
   80c96:	4770      	bx	lr
		PORT->PIO_CODR = 0x1 << PIN;
   80c98:	2301      	movs	r3, #1
   80c9a:	fa03 f101 	lsl.w	r1, r3, r1
   80c9e:	6341      	str	r1, [r0, #52]	; 0x34
   80ca0:	4770      	bx	lr
	...

00080ca4 <Set_Duty_Cycle_Synchronous_Channels>:
	PWM_sel->PWM_CDTYUPDx &= ~PWM_CDTYUPD_CDTYUPD_Msk;//reset
	PWM_sel->PWM_CDTYUPDx |= PWM_CDTYUPD_CDTYUPD(t);//set PWM
}

void Set_Duty_Cycle_Synchronous_Channels(uint8_t Duty_Cycle, PWMx *PWM_sel)
{
   80ca4:	b082      	sub	sp, #8
	volatile uint32_t t ;
	if (Duty_Cycle>100)
   80ca6:	2864      	cmp	r0, #100	; 0x64
   80ca8:	d900      	bls.n	80cac <Set_Duty_Cycle_Synchronous_Channels+0x8>
	{
		Duty_Cycle=100;
   80caa:	2064      	movs	r0, #100	; 0x64
	}
	t=PWM0->PWM_CPRDx&0xFFF;//grab channel PWM period
   80cac:	4b0d      	ldr	r3, [pc, #52]	; (80ce4 <Set_Duty_Cycle_Synchronous_Channels+0x40>)
   80cae:	68db      	ldr	r3, [r3, #12]
   80cb0:	f3c3 030b 	ubfx	r3, r3, #0, #12
   80cb4:	9301      	str	r3, [sp, #4]
	t = (int)((long)Duty_Cycle*(long)t/100);//calculate Duty Cycle update value as ratio of channel period
   80cb6:	9b01      	ldr	r3, [sp, #4]
   80cb8:	fb03 f000 	mul.w	r0, r3, r0
   80cbc:	4b0a      	ldr	r3, [pc, #40]	; (80ce8 <Set_Duty_Cycle_Synchronous_Channels+0x44>)
   80cbe:	fb83 2300 	smull	r2, r3, r3, r0
   80cc2:	17c0      	asrs	r0, r0, #31
   80cc4:	ebc0 1063 	rsb	r0, r0, r3, asr #5
   80cc8:	9001      	str	r0, [sp, #4]
	PWM_sel->PWM_CDTYUPDx &= ~PWM_CDTYUPD_CDTYUPD_Msk;//reset
   80cca:	688b      	ldr	r3, [r1, #8]
   80ccc:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
   80cd0:	608b      	str	r3, [r1, #8]
	PWM_sel->PWM_CDTYUPDx |= PWM_CDTYUPD_CDTYUPD(t);//set PWM
   80cd2:	9b01      	ldr	r3, [sp, #4]
   80cd4:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
   80cd8:	688a      	ldr	r2, [r1, #8]
   80cda:	4313      	orrs	r3, r2
   80cdc:	608b      	str	r3, [r1, #8]
   80cde:	b002      	add	sp, #8
   80ce0:	4770      	bx	lr
   80ce2:	bf00      	nop
   80ce4:	40094200 	.word	0x40094200
   80ce8:	51eb851f 	.word	0x51eb851f

00080cec <SPI_transfer>:
 *  Author: hanno
 */ 
#include "SPI_SAM.h"

void SPI_transfer(const char myString[])
{
   80cec:	b410      	push	{r4}
   80cee:	b083      	sub	sp, #12
	volatile uint32_t temp;
	uint8_t count = 0;
   80cf0:	2200      	movs	r2, #0
	while (myString[count])
   80cf2:	e01a      	b.n	80d2a <SPI_transfer+0x3e>
	{
		temp = (SPI0->SPI_SR>>1)&(0x0001);
		while (temp==0)//tests data register is ready
		{
			temp = (SPI0->SPI_SR>>1)&(0x0001);//Data has been written to SPI_TDR and not yet transferred to the serializer
   80cf4:	4b12      	ldr	r3, [pc, #72]	; (80d40 <SPI_transfer+0x54>)
   80cf6:	691b      	ldr	r3, [r3, #16]
   80cf8:	f3c3 0340 	ubfx	r3, r3, #1, #1
   80cfc:	9301      	str	r3, [sp, #4]
		while (temp==0)//tests data register is ready
   80cfe:	9b01      	ldr	r3, [sp, #4]
   80d00:	2b00      	cmp	r3, #0
   80d02:	d0f7      	beq.n	80cf4 <SPI_transfer+0x8>
		}
		//set data to be transferred
		SPI0->SPI_TDR |= SPI_TDR_TD(myString[count]);
   80d04:	4b0e      	ldr	r3, [pc, #56]	; (80d40 <SPI_transfer+0x54>)
   80d06:	68d9      	ldr	r1, [r3, #12]
   80d08:	4321      	orrs	r1, r4
   80d0a:	60d9      	str	r1, [r3, #12]
		
		temp = (SPI0->SPI_SR>>1)&(0x0001);
   80d0c:	691b      	ldr	r3, [r3, #16]
   80d0e:	f3c3 0340 	ubfx	r3, r3, #1, #1
   80d12:	9301      	str	r3, [sp, #4]
		while (temp==0)//tests data register is ready
   80d14:	e004      	b.n	80d20 <SPI_transfer+0x34>
		{
			temp = (SPI0->SPI_SR>>1)&(0x0001);//Data has been written to SPI_TDR and not yet transferred to the serializer
   80d16:	4b0a      	ldr	r3, [pc, #40]	; (80d40 <SPI_transfer+0x54>)
   80d18:	691b      	ldr	r3, [r3, #16]
   80d1a:	f3c3 0340 	ubfx	r3, r3, #1, #1
   80d1e:	9301      	str	r3, [sp, #4]
		while (temp==0)//tests data register is ready
   80d20:	9b01      	ldr	r3, [sp, #4]
   80d22:	2b00      	cmp	r3, #0
   80d24:	d0f7      	beq.n	80d16 <SPI_transfer+0x2a>
		}
		
		count ++;
   80d26:	3201      	adds	r2, #1
   80d28:	b2d2      	uxtb	r2, r2
	while (myString[count])
   80d2a:	5c84      	ldrb	r4, [r0, r2]
   80d2c:	b12c      	cbz	r4, 80d3a <SPI_transfer+0x4e>
		temp = (SPI0->SPI_SR>>1)&(0x0001);
   80d2e:	4b04      	ldr	r3, [pc, #16]	; (80d40 <SPI_transfer+0x54>)
   80d30:	691b      	ldr	r3, [r3, #16]
   80d32:	f3c3 0340 	ubfx	r3, r3, #1, #1
   80d36:	9301      	str	r3, [sp, #4]
		while (temp==0)//tests data register is ready
   80d38:	e7e1      	b.n	80cfe <SPI_transfer+0x12>
	}
	
	
	
   80d3a:	b003      	add	sp, #12
   80d3c:	bc10      	pop	{r4}
   80d3e:	4770      	bx	lr
   80d40:	40008000 	.word	0x40008000

00080d44 <transmitByte>:
 * Created: 2022/03/08 14:16:09
 *  Author: hanno
 */ 
#include "USART_SAM.h"

void transmitByte(uint8_t data){
   80d44:	b082      	sub	sp, #8
	volatile uint32_t t1;
	//wait for ready
	t1 = (USART0->US_CSR>>1)&0x1;
   80d46:	4b0e      	ldr	r3, [pc, #56]	; (80d80 <transmitByte+0x3c>)
   80d48:	695b      	ldr	r3, [r3, #20]
   80d4a:	f3c3 0340 	ubfx	r3, r3, #1, #1
   80d4e:	9301      	str	r3, [sp, #4]
	while ((~t1)&0x1){
   80d50:	9b01      	ldr	r3, [sp, #4]
   80d52:	f013 0f01 	tst.w	r3, #1
   80d56:	d111      	bne.n	80d7c <transmitByte+0x38>
   80d58:	2301      	movs	r3, #1
   80d5a:	b94b      	cbnz	r3, 80d70 <transmitByte+0x2c>
		t1 = (USART0->US_CSR>>1)&0x1;}//#SR	
	t1 = (USART0->US_CSR>>9)&0x1;
   80d5c:	4b08      	ldr	r3, [pc, #32]	; (80d80 <transmitByte+0x3c>)
   80d5e:	695a      	ldr	r2, [r3, #20]
   80d60:	f3c2 2240 	ubfx	r2, r2, #9, #1
   80d64:	9201      	str	r2, [sp, #4]
	while (!( UART_SR_TXEMPTY)){
	t1 = (USART0->US_CSR>>9)&0x1;
	};
	
	//load data to be transmitted
	USART0->US_THR |= data;
   80d66:	69da      	ldr	r2, [r3, #28]
   80d68:	4310      	orrs	r0, r2
   80d6a:	61d8      	str	r0, [r3, #28]
}
   80d6c:	b002      	add	sp, #8
   80d6e:	4770      	bx	lr
		t1 = (USART0->US_CSR>>1)&0x1;}//#SR	
   80d70:	4b03      	ldr	r3, [pc, #12]	; (80d80 <transmitByte+0x3c>)
   80d72:	695b      	ldr	r3, [r3, #20]
   80d74:	f3c3 0340 	ubfx	r3, r3, #1, #1
   80d78:	9301      	str	r3, [sp, #4]
   80d7a:	e7e9      	b.n	80d50 <transmitByte+0xc>
	while ((~t1)&0x1){
   80d7c:	2300      	movs	r3, #0
   80d7e:	e7ec      	b.n	80d5a <transmitByte+0x16>
   80d80:	40098000 	.word	0x40098000

00080d84 <USART_Transfer>:

void USART_Transfer(const char myString[]) {//w
   80d84:	b538      	push	{r3, r4, r5, lr}
   80d86:	4605      	mov	r5, r0
	uint8_t i = 0;
   80d88:	2400      	movs	r4, #0
	while (myString[i]) {
   80d8a:	e003      	b.n	80d94 <USART_Transfer+0x10>
		transmitByte(myString[i]);
   80d8c:	4b03      	ldr	r3, [pc, #12]	; (80d9c <USART_Transfer+0x18>)
   80d8e:	4798      	blx	r3
		i++;
   80d90:	3401      	adds	r4, #1
   80d92:	b2e4      	uxtb	r4, r4
	while (myString[i]) {
   80d94:	5d28      	ldrb	r0, [r5, r4]
   80d96:	2800      	cmp	r0, #0
   80d98:	d1f8      	bne.n	80d8c <USART_Transfer+0x8>
	}
   80d9a:	bd38      	pop	{r3, r4, r5, pc}
   80d9c:	00080d45 	.word	0x00080d45

00080da0 <Task2_task>:
	/* Should never go there */
	vTaskDelete(NULL);
}

static void Task2_task(void *pvParameters)
{
   80da0:	b500      	push	{lr}
   80da2:	b083      	sub	sp, #12
	portTickType xLastWakeTime;
	const portTickType xFrequency = 150;

	// Initialise the xLastWakeTime variable with the current time.
	xLastWakeTime = xTaskGetTickCount();
   80da4:	4b05      	ldr	r3, [pc, #20]	; (80dbc <Task2_task+0x1c>)
   80da6:	4798      	blx	r3
   80da8:	9001      	str	r0, [sp, #4]
	for(;;)
	{
		/* task application*/
		
		//DELAY(150);
		vTaskDelayUntil( &xLastWakeTime, xFrequency );
   80daa:	2196      	movs	r1, #150	; 0x96
   80dac:	a801      	add	r0, sp, #4
   80dae:	4b04      	ldr	r3, [pc, #16]	; (80dc0 <Task2_task+0x20>)
   80db0:	4798      	blx	r3
		Toggle_Output(OUT_A0_PA16_PORT,OUT_A0_PA16_PIN);
   80db2:	2110      	movs	r1, #16
   80db4:	4803      	ldr	r0, [pc, #12]	; (80dc4 <Task2_task+0x24>)
   80db6:	4b04      	ldr	r3, [pc, #16]	; (80dc8 <Task2_task+0x28>)
   80db8:	4798      	blx	r3
   80dba:	e7f6      	b.n	80daa <Task2_task+0xa>
   80dbc:	00080939 	.word	0x00080939
   80dc0:	00080b59 	.word	0x00080b59
   80dc4:	400e0e00 	.word	0x400e0e00
   80dc8:	00080c85 	.word	0x00080c85

00080dcc <Task1_task>:
{
   80dcc:	b500      	push	{lr}
   80dce:	b083      	sub	sp, #12
	xLastWakeTime = xTaskGetTickCount();
   80dd0:	4b05      	ldr	r3, [pc, #20]	; (80de8 <Task1_task+0x1c>)
   80dd2:	4798      	blx	r3
   80dd4:	9001      	str	r0, [sp, #4]
		vTaskDelayUntil( &xLastWakeTime, xFrequency );
   80dd6:	2164      	movs	r1, #100	; 0x64
   80dd8:	a801      	add	r0, sp, #4
   80dda:	4b04      	ldr	r3, [pc, #16]	; (80dec <Task1_task+0x20>)
   80ddc:	4798      	blx	r3
		Toggle_Output(OUT_A1_PA24_PORT,OUT_A1_PA24_PIN);
   80dde:	2118      	movs	r1, #24
   80de0:	4803      	ldr	r0, [pc, #12]	; (80df0 <Task1_task+0x24>)
   80de2:	4b04      	ldr	r3, [pc, #16]	; (80df4 <Task1_task+0x28>)
   80de4:	4798      	blx	r3
   80de6:	e7f6      	b.n	80dd6 <Task1_task+0xa>
   80de8:	00080939 	.word	0x00080939
   80dec:	00080b59 	.word	0x00080b59
   80df0:	400e0e00 	.word	0x400e0e00
   80df4:	00080c85 	.word	0x00080c85

00080df8 <DELAY>:
	}
	    
}

void DELAY(uint32_t delay) //delay in ms
{
   80df8:	b082      	sub	sp, #8
	volatile uint32_t cnt = 0;
   80dfa:	2300      	movs	r3, #0
   80dfc:	9301      	str	r3, [sp, #4]
	if (delay>10000)//overflow protection
   80dfe:	f242 7310 	movw	r3, #10000	; 0x2710
   80e02:	4298      	cmp	r0, r3
   80e04:	d900      	bls.n	80e08 <DELAY+0x10>
	{
		delay = 10000;
   80e06:	4618      	mov	r0, r3
	}
	delay = 6666*delay; //adjust delay to represent clock cycles
   80e08:	f641 230a 	movw	r3, #6666	; 0x1a0a
   80e0c:	fb03 f000 	mul.w	r0, r3, r0
	while(cnt<=delay)
   80e10:	e002      	b.n	80e18 <DELAY+0x20>
	{
		cnt =cnt+1;
   80e12:	9b01      	ldr	r3, [sp, #4]
   80e14:	3301      	adds	r3, #1
   80e16:	9301      	str	r3, [sp, #4]
	while(cnt<=delay)
   80e18:	9b01      	ldr	r3, [sp, #4]
   80e1a:	4298      	cmp	r0, r3
   80e1c:	d2f9      	bcs.n	80e12 <DELAY+0x1a>
	}
}
   80e1e:	b002      	add	sp, #8
   80e20:	4770      	bx	lr
	...

00080e24 <main>:
{
   80e24:	b500      	push	{lr}
   80e26:	b087      	sub	sp, #28
	volatile uint32_t a = 0;
   80e28:	2400      	movs	r4, #0
   80e2a:	9405      	str	r4, [sp, #20]
    SystemInit();
   80e2c:	4b1f      	ldr	r3, [pc, #124]	; (80eac <main+0x88>)
   80e2e:	4798      	blx	r3
	SystemCoreClockUpdate();
   80e30:	4b1f      	ldr	r3, [pc, #124]	; (80eb0 <main+0x8c>)
   80e32:	4798      	blx	r3
	PIO_INIT();//works
   80e34:	4b1f      	ldr	r3, [pc, #124]	; (80eb4 <main+0x90>)
   80e36:	4798      	blx	r3
	TWI_init();//
   80e38:	4b1f      	ldr	r3, [pc, #124]	; (80eb8 <main+0x94>)
   80e3a:	4798      	blx	r3
	USART0_init();//works
   80e3c:	4b1f      	ldr	r3, [pc, #124]	; (80ebc <main+0x98>)
   80e3e:	4798      	blx	r3
	DAC_init();//initiated Vref/2 output works 
   80e40:	4b1f      	ldr	r3, [pc, #124]	; (80ec0 <main+0x9c>)
   80e42:	4798      	blx	r3
	ADC_init();//works
   80e44:	4b1f      	ldr	r3, [pc, #124]	; (80ec4 <main+0xa0>)
   80e46:	4798      	blx	r3
	PWM_init();//works  
   80e48:	4b1f      	ldr	r3, [pc, #124]	; (80ec8 <main+0xa4>)
   80e4a:	4798      	blx	r3
	SPI_init();//works
   80e4c:	4b1f      	ldr	r3, [pc, #124]	; (80ecc <main+0xa8>)
   80e4e:	4798      	blx	r3
	xTaskCreate(Task1_task,NULL,configMINIMAL_STACK_SIZE+400,NULL, 1,& Task1_id);
   80e50:	9403      	str	r4, [sp, #12]
   80e52:	9402      	str	r4, [sp, #8]
   80e54:	4b1e      	ldr	r3, [pc, #120]	; (80ed0 <main+0xac>)
   80e56:	9301      	str	r3, [sp, #4]
   80e58:	2301      	movs	r3, #1
   80e5a:	9300      	str	r3, [sp, #0]
   80e5c:	4623      	mov	r3, r4
   80e5e:	f240 2212 	movw	r2, #530	; 0x212
   80e62:	4621      	mov	r1, r4
   80e64:	481b      	ldr	r0, [pc, #108]	; (80ed4 <main+0xb0>)
   80e66:	4d1c      	ldr	r5, [pc, #112]	; (80ed8 <main+0xb4>)
   80e68:	47a8      	blx	r5
	xTaskCreate(Task2_task,NULL,configMINIMAL_STACK_SIZE+400,NULL, 2,& Task2_id);
   80e6a:	9403      	str	r4, [sp, #12]
   80e6c:	9402      	str	r4, [sp, #8]
   80e6e:	4b1b      	ldr	r3, [pc, #108]	; (80edc <main+0xb8>)
   80e70:	9301      	str	r3, [sp, #4]
   80e72:	2302      	movs	r3, #2
   80e74:	9300      	str	r3, [sp, #0]
   80e76:	4623      	mov	r3, r4
   80e78:	f240 2212 	movw	r2, #530	; 0x212
   80e7c:	4621      	mov	r1, r4
   80e7e:	4818      	ldr	r0, [pc, #96]	; (80ee0 <main+0xbc>)
   80e80:	47a8      	blx	r5
   80e82:	e010      	b.n	80ea6 <main+0x82>
		a =a+1;
   80e84:	9b05      	ldr	r3, [sp, #20]
   80e86:	3301      	adds	r3, #1
   80e88:	9305      	str	r3, [sp, #20]
		while(a<=500)//small delay
   80e8a:	9b05      	ldr	r3, [sp, #20]
   80e8c:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
   80e90:	d9f8      	bls.n	80e84 <main+0x60>
		SPI_transfer("Hello World");
   80e92:	4c14      	ldr	r4, [pc, #80]	; (80ee4 <main+0xc0>)
   80e94:	4620      	mov	r0, r4
   80e96:	4b14      	ldr	r3, [pc, #80]	; (80ee8 <main+0xc4>)
   80e98:	4798      	blx	r3
		DELAY(10);
   80e9a:	200a      	movs	r0, #10
   80e9c:	4b13      	ldr	r3, [pc, #76]	; (80eec <main+0xc8>)
   80e9e:	4798      	blx	r3
		USART_Transfer("Hello World");
   80ea0:	4620      	mov	r0, r4
   80ea2:	4b13      	ldr	r3, [pc, #76]	; (80ef0 <main+0xcc>)
   80ea4:	4798      	blx	r3
		a = 0;
   80ea6:	2300      	movs	r3, #0
   80ea8:	9305      	str	r3, [sp, #20]
		while(a<=500)//small delay
   80eaa:	e7ee      	b.n	80e8a <main+0x66>
   80eac:	000801d1 	.word	0x000801d1
   80eb0:	00080275 	.word	0x00080275
   80eb4:	0008129d 	.word	0x0008129d
   80eb8:	00081455 	.word	0x00081455
   80ebc:	00081495 	.word	0x00081495
   80ec0:	00080f3d 	.word	0x00080f3d
   80ec4:	00080ef9 	.word	0x00080ef9
   80ec8:	000812f1 	.word	0x000812f1
   80ecc:	000813c5 	.word	0x000813c5
   80ed0:	2000a594 	.word	0x2000a594
   80ed4:	00080dcd 	.word	0x00080dcd
   80ed8:	000807d1 	.word	0x000807d1
   80edc:	2000a598 	.word	0x2000a598
   80ee0:	00080da1 	.word	0x00080da1
   80ee4:	0008179c 	.word	0x0008179c
   80ee8:	00080ced 	.word	0x00080ced
   80eec:	00080df9 	.word	0x00080df9
   80ef0:	00080d85 	.word	0x00080d85

00080ef4 <vApplicationMallocFailedHook>:

void vApplicationMallocFailedHook( void )
{
   80ef4:	e7fe      	b.n	80ef4 <vApplicationMallocFailedHook>
	...

00080ef8 <ADC_init>:
#include "ADC_init_SAM.h"

void ADC_init(void)
{
	//Disable DAC Write Protect Mode Register
	ADC->ADC_WPMR =ADC_WPMR_WPKEY_PASSWD|~(ADC_WPMR_WPEN);
   80ef8:	4b0e      	ldr	r3, [pc, #56]	; (80f34 <ADC_init+0x3c>)
   80efa:	f06f 0201 	mvn.w	r2, #1
   80efe:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
	//Enable Peripheral Clock
	PMC->PMC_PCER1 |= (PMC_PCER1_PID37);//enable clock for ADC
   80f02:	490d      	ldr	r1, [pc, #52]	; (80f38 <ADC_init+0x40>)
   80f04:	f8d1 2100 	ldr.w	r2, [r1, #256]	; 0x100
   80f08:	f042 0220 	orr.w	r2, r2, #32
   80f0c:	f8c1 2100 	str.w	r2, [r1, #256]	; 0x100
	// set sampling speed 100us
	ADC -> ADC_MR	&= ~(ADC_MR_PRESCAL_Msk);//reset
   80f10:	685a      	ldr	r2, [r3, #4]
   80f12:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
   80f16:	605a      	str	r2, [r3, #4]
	ADC -> ADC_MR	|= ADC_MR_PRESCAL(3999);// set
   80f18:	685a      	ldr	r2, [r3, #4]
   80f1a:	f442 421f 	orr.w	r2, r2, #40704	; 0x9f00
   80f1e:	605a      	str	r2, [r3, #4]
	// enable AD channel 
	ADC -> ADC_CHDR &= ~(0xFF);//reset
   80f20:	695a      	ldr	r2, [r3, #20]
   80f22:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
   80f26:	615a      	str	r2, [r3, #20]
	ADC -> ADC_CHER |= ADC_CHER_CH0;//set AD0
   80f28:	691a      	ldr	r2, [r3, #16]
   80f2a:	f042 0201 	orr.w	r2, r2, #1
   80f2e:	611a      	str	r2, [r3, #16]
   80f30:	4770      	bx	lr
   80f32:	bf00      	nop
   80f34:	400c0000 	.word	0x400c0000
   80f38:	400e0600 	.word	0x400e0600

00080f3c <DAC_init>:
 *  Author: hanno
 */ 
#include "DAC_init_SAM.h"

void DAC_init(void)
{
   80f3c:	b082      	sub	sp, #8
	volatile uint32_t temp;
	//Disable DAC Write Protect Mode Register
	DACC->DACC_WPMR =DACC_WPMR_WPKEY(0x444143)|~(DACC_WPMR_WPEN);
   80f3e:	4b1d      	ldr	r3, [pc, #116]	; (80fb4 <DAC_init+0x78>)
   80f40:	f06f 0201 	mvn.w	r2, #1
   80f44:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
	//Enable Peripheral Clock
	PMC->PMC_PCER1 |= (PMC_PCER1_PID38);//enable clock for DAC
   80f48:	491b      	ldr	r1, [pc, #108]	; (80fb8 <DAC_init+0x7c>)
   80f4a:	f8d1 2100 	ldr.w	r2, [r1, #256]	; 0x100
   80f4e:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   80f52:	f8c1 2100 	str.w	r2, [r1, #256]	; 0x100
	/*//Select Channel 1
	DACC->DACC_MR |= DACC_MR_USER_SEL_CHANNEL1;*/
	//set startup time
	DACC->DACC_MR &= ~(DACC_MR_STARTUP_Msk);
   80f56:	685a      	ldr	r2, [r3, #4]
   80f58:	f022 527c 	bic.w	r2, r2, #1056964608	; 0x3f000000
   80f5c:	605a      	str	r2, [r3, #4]
	DACC->DACC_MR |= (DACC_MR_STARTUP_1344);
   80f5e:	685a      	ldr	r2, [r3, #4]
   80f60:	f042 52a8 	orr.w	r2, r2, #352321536	; 0x15000000
   80f64:	605a      	str	r2, [r3, #4]
	/*//set refresh period
	DACC->DACC_MR &= ~(DACC_MR_REFRESH_Msk);
	DACC->DACC_MR |= (DACC_MR_REFRESH(0x30));*/
	// Disable channel 0 and enable channel 1
	DACC->DACC_CHDR|= DACC_CHER_CH0;
   80f66:	695a      	ldr	r2, [r3, #20]
   80f68:	f042 0201 	orr.w	r2, r2, #1
   80f6c:	615a      	str	r2, [r3, #20]
	DACC->DACC_CHER|= DACC_CHER_CH1;
   80f6e:	691a      	ldr	r2, [r3, #16]
   80f70:	f042 0202 	orr.w	r2, r2, #2
   80f74:	611a      	str	r2, [r3, #16]
	
	// check if DACC is ready to accept new conversion requests
	temp = (DACC->DACC_ISR>>0)&(0x0001);
   80f76:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   80f78:	f003 0301 	and.w	r3, r3, #1
   80f7c:	9301      	str	r3, [sp, #4]
	if (temp==0)//wait for DAC complete
   80f7e:	9b01      	ldr	r3, [sp, #4]
   80f80:	b92b      	cbnz	r3, 80f8e <DAC_init+0x52>
	{
		while (1)
		{
			temp = (DACC->DACC_ISR>>0)&(0x0001);//DAC not complete
   80f82:	4b0c      	ldr	r3, [pc, #48]	; (80fb4 <DAC_init+0x78>)
   80f84:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   80f86:	f003 0301 	and.w	r3, r3, #1
   80f8a:	9301      	str	r3, [sp, #4]
   80f8c:	e7f9      	b.n	80f82 <DAC_init+0x46>
		}
	}
	
	// Set data to be converted
	DACC->DACC_CDR |= 0xFF/2; //Vref/2 
   80f8e:	4b09      	ldr	r3, [pc, #36]	; (80fb4 <DAC_init+0x78>)
   80f90:	6a1a      	ldr	r2, [r3, #32]
   80f92:	f042 027f 	orr.w	r2, r2, #127	; 0x7f
   80f96:	621a      	str	r2, [r3, #32]
	
	// check EOC
	temp = (DACC->DACC_ISR>>0)&(0x0001);
   80f98:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   80f9a:	f003 0301 	and.w	r3, r3, #1
   80f9e:	9301      	str	r3, [sp, #4]
	if (temp==0)//wait for DAC complete
   80fa0:	9b01      	ldr	r3, [sp, #4]
   80fa2:	b92b      	cbnz	r3, 80fb0 <DAC_init+0x74>
	{
		while (1)
		{
			temp = (DACC->DACC_ISR>>0)&(0x0001);//DAC not complete
   80fa4:	4b03      	ldr	r3, [pc, #12]	; (80fb4 <DAC_init+0x78>)
   80fa6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   80fa8:	f003 0301 	and.w	r3, r3, #1
   80fac:	9301      	str	r3, [sp, #4]
   80fae:	e7f9      	b.n	80fa4 <DAC_init+0x68>
		}
	} 
	
	
   80fb0:	b002      	add	sp, #8
   80fb2:	4770      	bx	lr
   80fb4:	400c8000 	.word	0x400c8000
   80fb8:	400e0600 	.word	0x400e0600

00080fbc <PIO_IO_init>:
 */ 

#include "pio_init.h"

void PIO_IO_init(uint8_t IO, Pio *PORT, uint8_t PIN, uint8_t PIO)//initialize pin as Input (1) or Output(0); PIO -> 0=PIO control, 1=A peripheral, 2=B peripheral
{
   80fbc:	b430      	push	{r4, r5}
   80fbe:	b082      	sub	sp, #8
	volatile uint32_t t1;
	// Disables the Write Protect
	PORT ->PIO_WPMR =(PIO_WPMR_WPKEY(0x50494F))|~(PIO_WPMR_WPEN);
   80fc0:	f06f 0401 	mvn.w	r4, #1
   80fc4:	f8c1 40e4 	str.w	r4, [r1, #228]	; 0xe4
	// Grabs PIO Write Protect Status
	t1 =  PORT->PIO_PSR;
   80fc8:	688c      	ldr	r4, [r1, #8]
   80fca:	9401      	str	r4, [sp, #4]
	t1 = (t1>>(PIN))&(0x1);//
   80fcc:	9c01      	ldr	r4, [sp, #4]
   80fce:	40d4      	lsrs	r4, r2
   80fd0:	f004 0401 	and.w	r4, r4, #1
   80fd4:	9401      	str	r4, [sp, #4]
	t1=(~t1)&(0x1);
   80fd6:	9c01      	ldr	r4, [sp, #4]
   80fd8:	f084 0401 	eor.w	r4, r4, #1
   80fdc:	f004 0401 	and.w	r4, r4, #1
   80fe0:	9401      	str	r4, [sp, #4]
	if (t1)//tests if PIO is active
   80fe2:	9c01      	ldr	r4, [sp, #4]
   80fe4:	b104      	cbz	r4, 80fe8 <PIO_IO_init+0x2c>
   80fe6:	e7fe      	b.n	80fe6 <PIO_IO_init+0x2a>
		while (1)
		{
			//fault pins PIO is inactive
		}
	}
	if (PIO==0)
   80fe8:	b9a3      	cbnz	r3, 81014 <PIO_IO_init+0x58>
	{
		// Enables the PIO to control
		PORT->PIO_PER |=((0x1u << PIN));//set
   80fea:	680c      	ldr	r4, [r1, #0]
   80fec:	2501      	movs	r5, #1
   80fee:	4095      	lsls	r5, r2
   80ff0:	432c      	orrs	r4, r5
   80ff2:	600c      	str	r4, [r1, #0]
		
		// Grabs PIO Controller status for respective pins
		t1 =  PORT->PIO_PSR;
   80ff4:	688c      	ldr	r4, [r1, #8]
   80ff6:	9401      	str	r4, [sp, #4]
		t1 = (t1>>(PIN)&(0x1));//
   80ff8:	9c01      	ldr	r4, [sp, #4]
   80ffa:	40d4      	lsrs	r4, r2
   80ffc:	f004 0401 	and.w	r4, r4, #1
   81000:	9401      	str	r4, [sp, #4]
		t1=(~t1)&(0x1);
   81002:	9c01      	ldr	r4, [sp, #4]
   81004:	f084 0401 	eor.w	r4, r4, #1
   81008:	f004 0401 	and.w	r4, r4, #1
   8100c:	9401      	str	r4, [sp, #4]
		if (t1)//tests if PIO is active
   8100e:	9c01      	ldr	r4, [sp, #4]
   81010:	b1e4      	cbz	r4, 8104c <PIO_IO_init+0x90>
   81012:	e7fe      	b.n	81012 <PIO_IO_init+0x56>
		}
	}
	else
	{
		// Disables the PIO to control
		PORT->PIO_PDR |=((0x1u << PIN));//set
   81014:	684c      	ldr	r4, [r1, #4]
   81016:	2501      	movs	r5, #1
   81018:	4095      	lsls	r5, r2
   8101a:	432c      	orrs	r4, r5
   8101c:	604c      	str	r4, [r1, #4]
		// Grabs PIO Controller status for respective pin
		t1 = (PORT->PIO_PSR>>(PIN)&(0x1));//
   8101e:	688c      	ldr	r4, [r1, #8]
   81020:	40d4      	lsrs	r4, r2
   81022:	f004 0401 	and.w	r4, r4, #1
   81026:	9401      	str	r4, [sp, #4]
		if (t1)//tests if PIO is active
   81028:	9c01      	ldr	r4, [sp, #4]
   8102a:	b104      	cbz	r4, 8102e <PIO_IO_init+0x72>
   8102c:	e7fe      	b.n	8102c <PIO_IO_init+0x70>
			{
				//fault pins PIO is inactive
			}
		}
		
		if (PIO == 1)//PIO Peripheral AB
   8102e:	2b01      	cmp	r3, #1
   81030:	d105      	bne.n	8103e <PIO_IO_init+0x82>
		{
			PORT->PIO_ABSR&=(~0x1)<<PIN;//set peripheral to A
   81032:	6f0c      	ldr	r4, [r1, #112]	; 0x70
   81034:	f06f 0501 	mvn.w	r5, #1
   81038:	4095      	lsls	r5, r2
   8103a:	402c      	ands	r4, r5
   8103c:	670c      	str	r4, [r1, #112]	; 0x70
		}
		if (PIO == 2)
   8103e:	2b02      	cmp	r3, #2
   81040:	d104      	bne.n	8104c <PIO_IO_init+0x90>
		{
			PORT->PIO_ABSR|=(0x1)<<PIN;//set peripheral to B
   81042:	6f0c      	ldr	r4, [r1, #112]	; 0x70
   81044:	2501      	movs	r5, #1
   81046:	4095      	lsls	r5, r2
   81048:	432c      	orrs	r4, r5
   8104a:	670c      	str	r4, [r1, #112]	; 0x70
		}
	}
	
	
	if (IO)
   8104c:	b160      	cbz	r0, 81068 <PIO_IO_init+0xac>
	{	// Disable the output line
		PORT->PIO_ODR |=(0x1u << PIN);//set
   8104e:	694c      	ldr	r4, [r1, #20]
   81050:	2501      	movs	r5, #1
   81052:	4095      	lsls	r5, r2
   81054:	432c      	orrs	r4, r5
   81056:	614c      	str	r4, [r1, #20]
		// Grabs PIO Controller Output Status for respective pins
		t1 = (PORT->PIO_OSR>>PIN)&(0x1);
   81058:	698c      	ldr	r4, [r1, #24]
   8105a:	40d4      	lsrs	r4, r2
   8105c:	f004 0401 	and.w	r4, r4, #1
   81060:	9401      	str	r4, [sp, #4]
		if (t1)//tests if I/O is set correctly
   81062:	9c01      	ldr	r4, [sp, #4]
   81064:	b18c      	cbz	r4, 8108a <PIO_IO_init+0xce>
   81066:	e7fe      	b.n	81066 <PIO_IO_init+0xaa>
			}
		}	
	} 
	else
	{	//Enable the output line
		PORT->PIO_OER |=((0x1u << PIN));//set
   81068:	690c      	ldr	r4, [r1, #16]
   8106a:	2501      	movs	r5, #1
   8106c:	4095      	lsls	r5, r2
   8106e:	432c      	orrs	r4, r5
   81070:	610c      	str	r4, [r1, #16]
		// Grabs PIO Controller Output Status for respective pins
		t1 = (PORT->PIO_OSR>>PIN);//
   81072:	698c      	ldr	r4, [r1, #24]
   81074:	40d4      	lsrs	r4, r2
   81076:	9401      	str	r4, [sp, #4]
		t1=(~(t1&(0x1)))&(0x1);
   81078:	9c01      	ldr	r4, [sp, #4]
   8107a:	f084 0401 	eor.w	r4, r4, #1
   8107e:	f004 0401 	and.w	r4, r4, #1
   81082:	9401      	str	r4, [sp, #4]
		if (t1)//tests if I/O is set correctly
   81084:	9c01      	ldr	r4, [sp, #4]
   81086:	b104      	cbz	r4, 8108a <PIO_IO_init+0xce>
   81088:	e7fe      	b.n	81088 <PIO_IO_init+0xcc>
	}
	
	
	
	// Grabs PIO Controller Input Filter Status for respective pins
	t1 = (PORT->PIO_IFER>>(PIN)&(0x0001));
   8108a:	6a0c      	ldr	r4, [r1, #32]
   8108c:	40d4      	lsrs	r4, r2
   8108e:	f004 0401 	and.w	r4, r4, #1
   81092:	9401      	str	r4, [sp, #4]
	if (t1)//test if input glitch filter is disabled on the I/O line 
   81094:	9c01      	ldr	r4, [sp, #4]
   81096:	b104      	cbz	r4, 8109a <PIO_IO_init+0xde>
   81098:	e7fe      	b.n	81098 <PIO_IO_init+0xdc>
		{
			//fault input glitch filter is enabled on the I/O line
		}
	}
	
	if ((~IO)&(0x1)&(PIO==0))
   8109a:	f080 0001 	eor.w	r0, r0, #1
   8109e:	2b00      	cmp	r3, #0
   810a0:	bf14      	ite	ne
   810a2:	2300      	movne	r3, #0
   810a4:	f000 0301 	andeq.w	r3, r0, #1
   810a8:	b1a3      	cbz	r3, 810d4 <PIO_IO_init+0x118>
	{
		// Enables Output Write Enable Register
		PORT->PIO_OWER |=((0x1u << PIN));//set
   810aa:	f8d1 00a0 	ldr.w	r0, [r1, #160]	; 0xa0
   810ae:	2401      	movs	r4, #1
   810b0:	4094      	lsls	r4, r2
   810b2:	4320      	orrs	r0, r4
   810b4:	f8c1 00a0 	str.w	r0, [r1, #160]	; 0xa0

		// GrabsPIO Output Write Status Register for respective pins
		t1 = (PORT->PIO_OWSR>>(PIN))&(0x1);
   810b8:	f8d1 10a8 	ldr.w	r1, [r1, #168]	; 0xa8
   810bc:	fa21 f202 	lsr.w	r2, r1, r2
   810c0:	f002 0201 	and.w	r2, r2, #1
   810c4:	9201      	str	r2, [sp, #4]
		if ((~t1)&(0x1))// Writing PIO_ODSR affects the I/O line. 
   810c6:	9a01      	ldr	r2, [sp, #4]
   810c8:	f012 0f01 	tst.w	r2, #1
   810cc:	d000      	beq.n	810d0 <PIO_IO_init+0x114>
   810ce:	2300      	movs	r3, #0
   810d0:	b103      	cbz	r3, 810d4 <PIO_IO_init+0x118>
   810d2:	e7fe      	b.n	810d2 <PIO_IO_init+0x116>
				//fault Writing PIO_ODSR does not affect the I/O line 
			}
		}
	}	
	
}
   810d4:	b002      	add	sp, #8
   810d6:	bc30      	pop	{r4, r5}
   810d8:	4770      	bx	lr
	...

000810dc <LED_PIO_init>:

void LED_PIO_init(void)
{
   810dc:	b538      	push	{r3, r4, r5, lr}
	//Disable PMC Write Protect Mode Register
	PMC->PMC_WPMR =PMC_WPMR_WPKEY_PASSWD|~(PMC_WPMR_WPEN);
   810de:	4b12      	ldr	r3, [pc, #72]	; (81128 <LED_PIO_init+0x4c>)
   810e0:	f06f 0201 	mvn.w	r2, #1
   810e4:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
	//Enable Peripheral Clock
	PMC->PMC_PCER0 |= (PMC_PCER0_PID11);//enable clock for port A
   810e8:	691a      	ldr	r2, [r3, #16]
   810ea:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
   810ee:	611a      	str	r2, [r3, #16]
	PMC->PMC_PCER0 |= (PMC_PCER0_PID12);//enable clock for port B
   810f0:	691a      	ldr	r2, [r3, #16]
   810f2:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
   810f6:	611a      	str	r2, [r3, #16]
	
	PIO_IO_init(Output,RED_PB26_PORT,RED_PB26_PIN,PIO_control);
   810f8:	2300      	movs	r3, #0
   810fa:	221a      	movs	r2, #26
   810fc:	490b      	ldr	r1, [pc, #44]	; (8112c <LED_PIO_init+0x50>)
   810fe:	4618      	mov	r0, r3
   81100:	4c0b      	ldr	r4, [pc, #44]	; (81130 <LED_PIO_init+0x54>)
   81102:	47a0      	blx	r4
	PIO_IO_init(Output,GREEN_PA15_PORT,GREEN_PA15_PIN,PIO_control);
   81104:	4d0b      	ldr	r5, [pc, #44]	; (81134 <LED_PIO_init+0x58>)
   81106:	2300      	movs	r3, #0
   81108:	220f      	movs	r2, #15
   8110a:	4629      	mov	r1, r5
   8110c:	4618      	mov	r0, r3
   8110e:	47a0      	blx	r4
	PIO_IO_init(Output,OUT_A0_PA16_PORT,OUT_A0_PA16_PIN,PIO_control);
   81110:	2300      	movs	r3, #0
   81112:	2210      	movs	r2, #16
   81114:	4629      	mov	r1, r5
   81116:	4618      	mov	r0, r3
   81118:	47a0      	blx	r4
	PIO_IO_init(Output,OUT_A1_PA24_PORT,OUT_A1_PA24_PIN,PIO_control);
   8111a:	2300      	movs	r3, #0
   8111c:	2218      	movs	r2, #24
   8111e:	4629      	mov	r1, r5
   81120:	4618      	mov	r0, r3
   81122:	47a0      	blx	r4
   81124:	bd38      	pop	{r3, r4, r5, pc}
   81126:	bf00      	nop
   81128:	400e0600 	.word	0x400e0600
   8112c:	400e1000 	.word	0x400e1000
   81130:	00080fbd 	.word	0x00080fbd
   81134:	400e0e00 	.word	0x400e0e00

00081138 <USART_PIO_init>:
	
}

void USART_PIO_init(void)
{
   81138:	b538      	push	{r3, r4, r5, lr}
	//Disable PMC Write Protect Mode Register
	PMC->PMC_WPMR =PMC_WPMR_WPKEY_PASSWD|~(PMC_WPMR_WPEN);
   8113a:	4b0b      	ldr	r3, [pc, #44]	; (81168 <USART_PIO_init+0x30>)
   8113c:	f06f 0201 	mvn.w	r2, #1
   81140:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
	//Enable Peripheral Clock
	PMC->PMC_PCER0 |= (PMC_PCER0_PID17);//enable clock for USART0
   81144:	691a      	ldr	r2, [r3, #16]
   81146:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
   8114a:	611a      	str	r2, [r3, #16]
	
	PIO_IO_init(Output,TXD0_PA11_PORT,TXD0_PA11_PIN,Peripheral_A);
   8114c:	4d07      	ldr	r5, [pc, #28]	; (8116c <USART_PIO_init+0x34>)
   8114e:	2301      	movs	r3, #1
   81150:	220b      	movs	r2, #11
   81152:	4629      	mov	r1, r5
   81154:	2000      	movs	r0, #0
   81156:	4c06      	ldr	r4, [pc, #24]	; (81170 <USART_PIO_init+0x38>)
   81158:	47a0      	blx	r4
	PIO_IO_init(Input,RDX0_PA10_PORT,RDX0_PA10_PIN,Peripheral_A);
   8115a:	2301      	movs	r3, #1
   8115c:	220a      	movs	r2, #10
   8115e:	4629      	mov	r1, r5
   81160:	4618      	mov	r0, r3
   81162:	47a0      	blx	r4
   81164:	bd38      	pop	{r3, r4, r5, pc}
   81166:	bf00      	nop
   81168:	400e0600 	.word	0x400e0600
   8116c:	400e0e00 	.word	0x400e0e00
   81170:	00080fbd 	.word	0x00080fbd

00081174 <TWI0_PIO_init>:
	
}

void TWI0_PIO_init(void)
{
   81174:	b538      	push	{r3, r4, r5, lr}
	//Disable PMC Write Protect Mode Register
	PMC->PMC_WPMR =PMC_WPMR_WPKEY_PASSWD|~(PMC_WPMR_WPEN);
   81176:	4b0b      	ldr	r3, [pc, #44]	; (811a4 <TWI0_PIO_init+0x30>)
   81178:	f06f 0201 	mvn.w	r2, #1
   8117c:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
	//Enable Peripheral Clock
	PMC->PMC_PCER0 |= (PMC_PCER0_PID22);//enable clock for TWI0
   81180:	691a      	ldr	r2, [r3, #16]
   81182:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
   81186:	611a      	str	r2, [r3, #16]
	
	PIO_IO_init(Output,TWD0_SCL_PA18_PORT,TWD0_SCL_PA18_PIN,Peripheral_A);
   81188:	4d07      	ldr	r5, [pc, #28]	; (811a8 <TWI0_PIO_init+0x34>)
   8118a:	2301      	movs	r3, #1
   8118c:	2212      	movs	r2, #18
   8118e:	4629      	mov	r1, r5
   81190:	2000      	movs	r0, #0
   81192:	4c06      	ldr	r4, [pc, #24]	; (811ac <TWI0_PIO_init+0x38>)
   81194:	47a0      	blx	r4
	PIO_IO_init(Output,TWD0_SDA_PA17_PORT,TWD0_SDA_PA17_PIN,Peripheral_A);
   81196:	2301      	movs	r3, #1
   81198:	2211      	movs	r2, #17
   8119a:	4629      	mov	r1, r5
   8119c:	2000      	movs	r0, #0
   8119e:	47a0      	blx	r4
   811a0:	bd38      	pop	{r3, r4, r5, pc}
   811a2:	bf00      	nop
   811a4:	400e0600 	.word	0x400e0600
   811a8:	400e0e00 	.word	0x400e0e00
   811ac:	00080fbd 	.word	0x00080fbd

000811b0 <PWM_PIO_init>:

	
}

void PWM_PIO_init(void)
{
   811b0:	b538      	push	{r3, r4, r5, lr}
	//Disable PMC Write Protect Mode Register
	PMC->PMC_WPMR =PMC_WPMR_WPKEY_PASSWD|~(PMC_WPMR_WPEN);
   811b2:	4b0d      	ldr	r3, [pc, #52]	; (811e8 <PWM_PIO_init+0x38>)
   811b4:	f06f 0201 	mvn.w	r2, #1
   811b8:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
	//Enable Peripheral Clock
	PMC->PMC_PCER0 |= (PMC_PCER1_PID36);//enable clock for PWM
   811bc:	691a      	ldr	r2, [r3, #16]
   811be:	f042 0210 	orr.w	r2, r2, #16
   811c2:	611a      	str	r2, [r3, #16]
	
	
	PIO_IO_init(Output,PWMH3_PB15_PORT,PWMH3_PB15_PIN,Peripheral_B);
   811c4:	2302      	movs	r3, #2
   811c6:	220f      	movs	r2, #15
   811c8:	4908      	ldr	r1, [pc, #32]	; (811ec <PWM_PIO_init+0x3c>)
   811ca:	2000      	movs	r0, #0
   811cc:	4c08      	ldr	r4, [pc, #32]	; (811f0 <PWM_PIO_init+0x40>)
   811ce:	47a0      	blx	r4
	PIO_IO_init(Output,PWML3_PA0_PORT,PWML3_PA0_PIN,Peripheral_B);
   811d0:	4d08      	ldr	r5, [pc, #32]	; (811f4 <PWM_PIO_init+0x44>)
   811d2:	2302      	movs	r3, #2
   811d4:	2200      	movs	r2, #0
   811d6:	4629      	mov	r1, r5
   811d8:	4610      	mov	r0, r2
   811da:	47a0      	blx	r4
	//PIO_IO_init(Output,PWMH0_PB12_PORT,PWMH0_PB12_PIN,Peripheral_B);
	PIO_IO_init(Input,PWMFI1_PA3_PORT,PWMFI1_PA3_PIN,Peripheral_B);
   811dc:	2302      	movs	r3, #2
   811de:	2205      	movs	r2, #5
   811e0:	4629      	mov	r1, r5
   811e2:	2001      	movs	r0, #1
   811e4:	47a0      	blx	r4
   811e6:	bd38      	pop	{r3, r4, r5, pc}
   811e8:	400e0600 	.word	0x400e0600
   811ec:	400e1000 	.word	0x400e1000
   811f0:	00080fbd 	.word	0x00080fbd
   811f4:	400e0e00 	.word	0x400e0e00

000811f8 <SPI_PIO_init>:
	
}

void SPI_PIO_init(void)
{
   811f8:	b538      	push	{r3, r4, r5, lr}
	//Disable PMC Write Protect Mode Register
	PMC->PMC_WPMR =PMC_WPMR_WPKEY_PASSWD|~(PMC_WPMR_WPEN);
   811fa:	4b0d      	ldr	r3, [pc, #52]	; (81230 <SPI_PIO_init+0x38>)
   811fc:	f06f 0201 	mvn.w	r2, #1
   81200:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
	//Enable Peripheral Clock
	PMC->PMC_PCER0 |= (PMC_PCER0_PID24);//enable clock for SPI0
   81204:	691a      	ldr	r2, [r3, #16]
   81206:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
   8120a:	611a      	str	r2, [r3, #16]
	
	PIO_IO_init(Output,SPI0_SPCK_PA27_PORT,SPI0_SPCK_PA27_PIN,Peripheral_A);
   8120c:	4d09      	ldr	r5, [pc, #36]	; (81234 <SPI_PIO_init+0x3c>)
   8120e:	2301      	movs	r3, #1
   81210:	221b      	movs	r2, #27
   81212:	4629      	mov	r1, r5
   81214:	2000      	movs	r0, #0
   81216:	4c08      	ldr	r4, [pc, #32]	; (81238 <SPI_PIO_init+0x40>)
   81218:	47a0      	blx	r4
	PIO_IO_init(Output,SPI0_MOSI_PA26_PORT,SPI0_MOSI_PA26_PIN,Peripheral_A);
   8121a:	2301      	movs	r3, #1
   8121c:	221a      	movs	r2, #26
   8121e:	4629      	mov	r1, r5
   81220:	2000      	movs	r0, #0
   81222:	47a0      	blx	r4
	PIO_IO_init(Input,SPI0_MISO_PA25_PORT,SPI0_MISO_PA25_PIN,Peripheral_A);
   81224:	2301      	movs	r3, #1
   81226:	2219      	movs	r2, #25
   81228:	4629      	mov	r1, r5
   8122a:	4618      	mov	r0, r3
   8122c:	47a0      	blx	r4
   8122e:	bd38      	pop	{r3, r4, r5, pc}
   81230:	400e0600 	.word	0x400e0600
   81234:	400e0e00 	.word	0x400e0e00
   81238:	00080fbd 	.word	0x00080fbd

0008123c <ADC_PIO_init>:
	
}


void ADC_PIO_init(void)
{
   8123c:	b510      	push	{r4, lr}
	//Disable PMC Write Protect Mode Register
	PMC->PMC_WPMR =PMC_WPMR_WPKEY_PASSWD|~(PMC_WPMR_WPEN);
   8123e:	4b08      	ldr	r3, [pc, #32]	; (81260 <ADC_PIO_init+0x24>)
   81240:	f06f 0201 	mvn.w	r2, #1
   81244:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
	//Enable Peripheral Clock
	PMC->PMC_PCER0 |= (PMC_PCER1_PID37);//enable clock for SPI0
   81248:	691a      	ldr	r2, [r3, #16]
   8124a:	f042 0220 	orr.w	r2, r2, #32
   8124e:	611a      	str	r2, [r3, #16]
	
	PIO_IO_init(Input,REF1V65_AD0_PA2_PORT,REF1V65_AD0_PA2_PIN,Alternate_function);
   81250:	2303      	movs	r3, #3
   81252:	2202      	movs	r2, #2
   81254:	4903      	ldr	r1, [pc, #12]	; (81264 <ADC_PIO_init+0x28>)
   81256:	2001      	movs	r0, #1
   81258:	4c03      	ldr	r4, [pc, #12]	; (81268 <ADC_PIO_init+0x2c>)
   8125a:	47a0      	blx	r4
   8125c:	bd10      	pop	{r4, pc}
   8125e:	bf00      	nop
   81260:	400e0600 	.word	0x400e0600
   81264:	400e0e00 	.word	0x400e0e00
   81268:	00080fbd 	.word	0x00080fbd

0008126c <DAC_PIO_init>:
}

void DAC_PIO_init(void)
{
   8126c:	b510      	push	{r4, lr}
	//Disable PMC Write Protect Mode Register
	PMC->PMC_WPMR =PMC_WPMR_WPKEY_PASSWD|~(PMC_WPMR_WPEN);
   8126e:	4b08      	ldr	r3, [pc, #32]	; (81290 <DAC_PIO_init+0x24>)
   81270:	f06f 0201 	mvn.w	r2, #1
   81274:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
	//Enable Peripheral Clock
	PMC->PMC_PCER0 |= (PMC_PCER1_PID38);//enable clock for SPI0
   81278:	691a      	ldr	r2, [r3, #16]
   8127a:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   8127e:	611a      	str	r2, [r3, #16]
	
	PIO_IO_init(Output,DAC1_PB16_PORT,DAC1_PB16_PIN,Alternate_function);
   81280:	2303      	movs	r3, #3
   81282:	2210      	movs	r2, #16
   81284:	4903      	ldr	r1, [pc, #12]	; (81294 <DAC_PIO_init+0x28>)
   81286:	2000      	movs	r0, #0
   81288:	4c03      	ldr	r4, [pc, #12]	; (81298 <DAC_PIO_init+0x2c>)
   8128a:	47a0      	blx	r4
   8128c:	bd10      	pop	{r4, pc}
   8128e:	bf00      	nop
   81290:	400e0600 	.word	0x400e0600
   81294:	400e1000 	.word	0x400e1000
   81298:	00080fbd 	.word	0x00080fbd

0008129c <PIO_INIT>:
	
}


void PIO_INIT(void)
{
   8129c:	b508      	push	{r3, lr}
	LED_PIO_init();
   8129e:	4b07      	ldr	r3, [pc, #28]	; (812bc <PIO_INIT+0x20>)
   812a0:	4798      	blx	r3
	USART_PIO_init();
   812a2:	4b07      	ldr	r3, [pc, #28]	; (812c0 <PIO_INIT+0x24>)
   812a4:	4798      	blx	r3
	TWI0_PIO_init();
   812a6:	4b07      	ldr	r3, [pc, #28]	; (812c4 <PIO_INIT+0x28>)
   812a8:	4798      	blx	r3
	SPI_PIO_init();
   812aa:	4b07      	ldr	r3, [pc, #28]	; (812c8 <PIO_INIT+0x2c>)
   812ac:	4798      	blx	r3
	ADC_PIO_init();
   812ae:	4b07      	ldr	r3, [pc, #28]	; (812cc <PIO_INIT+0x30>)
   812b0:	4798      	blx	r3
	DAC_PIO_init();
   812b2:	4b07      	ldr	r3, [pc, #28]	; (812d0 <PIO_INIT+0x34>)
   812b4:	4798      	blx	r3
	PWM_PIO_init();
   812b6:	4b07      	ldr	r3, [pc, #28]	; (812d4 <PIO_INIT+0x38>)
   812b8:	4798      	blx	r3
   812ba:	bd08      	pop	{r3, pc}
   812bc:	000810dd 	.word	0x000810dd
   812c0:	00081139 	.word	0x00081139
   812c4:	00081175 	.word	0x00081175
   812c8:	000811f9 	.word	0x000811f9
   812cc:	0008123d 	.word	0x0008123d
   812d0:	0008126d 	.word	0x0008126d
   812d4:	000811b1 	.word	0x000811b1

000812d8 <PWM_init_FAULT>:
	
	}

void PWM_init_FAULT(void)
{
	PWM->PWM_FMR &= ~PWM_FMR_FPOL(0b1<<1);
   812d8:	4b04      	ldr	r3, [pc, #16]	; (812ec <PWM_init_FAULT+0x14>)
   812da:	6dda      	ldr	r2, [r3, #92]	; 0x5c
   812dc:	f022 0202 	bic.w	r2, r2, #2
   812e0:	65da      	str	r2, [r3, #92]	; 0x5c
	//PWM->PWM_FPE1 |= PWM_FPE1_FPE3(0b1<<1);//enable fault protection for channel 3
	PWM->PWM_FPE1 |= PWM_FPE1_FPE0(0b1<<1);//enable fault protection for channel 0
   812e2:	6eda      	ldr	r2, [r3, #108]	; 0x6c
   812e4:	f042 0202 	orr.w	r2, r2, #2
   812e8:	66da      	str	r2, [r3, #108]	; 0x6c
   812ea:	4770      	bx	lr
   812ec:	40094000 	.word	0x40094000

000812f0 <PWM_init>:
	//update synchronous channels
	//PWM ->PWM_SCUC |=PWM_SCUC_UPDULOCK;
}
	
void PWM_init(void)//synchronous mode
{
   812f0:	b570      	push	{r4, r5, r6, lr}
	//select and divide PWM clock A and B.PWM_SCUC UPDULOCK
	//PWM ->PWM_CLK = PWM_CLK_DIVA(4)|PWM_CLK_DIVB(4)|PWM_CLK_PREA(0b1010)|PWM_CLK_PREB(0b1010); //0b1010 -> MCK/1024
	
	//Disable PMC Write Protect Mode Register
	PMC->PMC_WPMR =PMC_WPMR_WPKEY_PASSWD|~(PMC_WPMR_WPEN);
   812f2:	4b2e      	ldr	r3, [pc, #184]	; (813ac <PWM_init+0xbc>)
   812f4:	f06f 0201 	mvn.w	r2, #1
   812f8:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
	//Enable Peripheral Clock
	PMC->PMC_PCER1 |= (PMC_PCER1_PID36);//enable clock for PWM
   812fc:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
   81300:	f042 0210 	orr.w	r2, r2, #16
   81304:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
	
	// select mode
	PWM ->PWM_SCM &= ~PWM_SCM_UPDM_Msk;
   81308:	4c29      	ldr	r4, [pc, #164]	; (813b0 <PWM_init+0xc0>)
   8130a:	6a23      	ldr	r3, [r4, #32]
   8130c:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
   81310:	6223      	str	r3, [r4, #32]
	PWM ->PWM_SCM |= PWM_SCM_UPDM_MODE0;
   81312:	6a23      	ldr	r3, [r4, #32]
   81314:	6223      	str	r3, [r4, #32]
	//set channels as synchronous channels
	PWM->PWM_SCM |= PWM_SCM_SYNC1;
   81316:	6a23      	ldr	r3, [r4, #32]
   81318:	f043 0302 	orr.w	r3, r3, #2
   8131c:	6223      	str	r3, [r4, #32]
	PWM->PWM_SCM |= PWM_SCM_SYNC2;
   8131e:	6a23      	ldr	r3, [r4, #32]
   81320:	f043 0304 	orr.w	r3, r3, #4
   81324:	6223      	str	r3, [r4, #32]
	PWM->PWM_SCM |= PWM_SCM_SYNC3;
   81326:	6a23      	ldr	r3, [r4, #32]
   81328:	f043 0308 	orr.w	r3, r3, #8
   8132c:	6223      	str	r3, [r4, #32]
	
	//Enable channel 0
	PWM->PWM_ENA |= PWM_ENA_CHID0;
   8132e:	6863      	ldr	r3, [r4, #4]
   81330:	f043 0301 	orr.w	r3, r3, #1
   81334:	6063      	str	r3, [r4, #4]
	//Enable channel 1
	PWM->PWM_ENA |= PWM_ENA_CHID1;
   81336:	6863      	ldr	r3, [r4, #4]
   81338:	f043 0302 	orr.w	r3, r3, #2
   8133c:	6063      	str	r3, [r4, #4]
	//Enable channel 2
	PWM->PWM_ENA |= PWM_ENA_CHID2;
   8133e:	6863      	ldr	r3, [r4, #4]
   81340:	f043 0304 	orr.w	r3, r3, #4
   81344:	6063      	str	r3, [r4, #4]
	//Enable channel 3
	PWM->PWM_ENA |= PWM_ENA_CHID3;
   81346:	6863      	ldr	r3, [r4, #4]
   81348:	f043 0308 	orr.w	r3, r3, #8
   8134c:	6063      	str	r3, [r4, #4]
	//set frequency of PWM channel
	/*
	(MCK_DIV_16)16*(PWM_CPRDUPD_CPRDUPD)0x1f4/(MCK)80e6 =10kHz 
	*/
	//PWM Channel Period Update Register
	PWM0->PWM_CPRDUPDx |= PWM_CPRDUPD_CPRDUPD(0x1f4);//*(uint32_t *)0x40094270
   8134e:	4919      	ldr	r1, [pc, #100]	; (813b4 <PWM_init+0xc4>)
   81350:	690b      	ldr	r3, [r1, #16]
   81352:	f443 73fa 	orr.w	r3, r3, #500	; 0x1f4
   81356:	610b      	str	r3, [r1, #16]
	//PWM Channel Prescaler
	PWM0->PWM_CMRx  &= ~PWM_CMR_CPRE_Msk;//*(uint32_t *)0x40094260
   81358:	680b      	ldr	r3, [r1, #0]
   8135a:	f023 030f 	bic.w	r3, r3, #15
   8135e:	600b      	str	r3, [r1, #0]
	PWM0->PWM_CMRx |= PWM_CMR_CPRE_MCK_DIV_16;
   81360:	680b      	ldr	r3, [r1, #0]
   81362:	f043 0304 	orr.w	r3, r3, #4
   81366:	600b      	str	r3, [r1, #0]
	
	//Channel Alignment
	PWM0->PWM_CMRx |= PWM_CMR_CALG;
   81368:	680b      	ldr	r3, [r1, #0]
   8136a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   8136e:	600b      	str	r3, [r1, #0]
	// Universal Sync settings stop-------------------------------------------
	
	//PWM Channel Dead Time Update Register CPRD-CDTY
	PWM3->PWM_DTUPDx= PWM_DTUPD_DTHUPD(0xF)|PWM_DTUPD_DTLUPD(0xF);//*(uint32_t *)0x4009427C
   81370:	4d11      	ldr	r5, [pc, #68]	; (813b8 <PWM_init+0xc8>)
   81372:	f04f 120f 	mov.w	r2, #983055	; 0xf000f
   81376:	61ea      	str	r2, [r5, #28]
	// Dead Time Generator Enable
	PWM3->PWM_CMRx |= PWM_CMR_DTE; //*(uint32_t *)0x40094260
   81378:	682b      	ldr	r3, [r5, #0]
   8137a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   8137e:	602b      	str	r3, [r5, #0]
	//Invert Low signal
	//PWM3->PWM_CMRx |= PWM_CMR_DTLI;

	//PWM Channel Dead Time Update Register CPRD-CDTY
	PWM0->PWM_DTUPDx= PWM_DTUPD_DTHUPD(0xF)|PWM_DTUPD_DTLUPD(0xF);//*(uint32_t *)0x4009427C
   81380:	61ca      	str	r2, [r1, #28]
	// Dead Time Generator Enable
	PWM0->PWM_CMRx |= PWM_CMR_DTE; //*(uint32_t *)0x40094260
   81382:	680b      	ldr	r3, [r1, #0]
   81384:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   81388:	600b      	str	r3, [r1, #0]
	
	//update synchronous channels
	PWM ->PWM_SCUC |=PWM_SCUC_UPDULOCK;
   8138a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   8138c:	f043 0301 	orr.w	r3, r3, #1
   81390:	62a3      	str	r3, [r4, #40]	; 0x28
	
	Set_Duty_Cycle_Synchronous_Channels(10,PWM0);
   81392:	200a      	movs	r0, #10
   81394:	4e09      	ldr	r6, [pc, #36]	; (813bc <PWM_init+0xcc>)
   81396:	47b0      	blx	r6
	Set_Duty_Cycle_Synchronous_Channels(10,PWM3);
   81398:	4629      	mov	r1, r5
   8139a:	200a      	movs	r0, #10
   8139c:	47b0      	blx	r6
	//update synchronous channels
	PWM ->PWM_SCUC |=PWM_SCUC_UPDULOCK;
   8139e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   813a0:	f043 0301 	orr.w	r3, r3, #1
   813a4:	62a3      	str	r3, [r4, #40]	; 0x28
	PWM_init_FAULT();
   813a6:	4b06      	ldr	r3, [pc, #24]	; (813c0 <PWM_init+0xd0>)
   813a8:	4798      	blx	r3
   813aa:	bd70      	pop	{r4, r5, r6, pc}
   813ac:	400e0600 	.word	0x400e0600
   813b0:	40094000 	.word	0x40094000
   813b4:	40094200 	.word	0x40094200
   813b8:	40094260 	.word	0x40094260
   813bc:	00080ca5 	.word	0x00080ca5
   813c0:	000812d9 	.word	0x000812d9

000813c4 <SPI_init>:
#include "SPI_init_SAM.h"

void SPI_init(void)
{
	//Enable Peripheral Clock
	PMC->PMC_PCER0 |= (PMC_PCER0_PID24);//enable clock for SPI0
   813c4:	4a19      	ldr	r2, [pc, #100]	; (8142c <SPI_init+0x68>)
   813c6:	6913      	ldr	r3, [r2, #16]
   813c8:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
   813cc:	6113      	str	r3, [r2, #16]
	//Enable Peripheral SPI0
	SPI0->SPI_CR |= SPI_CR_SPIEN;
   813ce:	4b18      	ldr	r3, [pc, #96]	; (81430 <SPI_init+0x6c>)
   813d0:	681a      	ldr	r2, [r3, #0]
   813d2:	f042 0201 	orr.w	r2, r2, #1
   813d6:	601a      	str	r2, [r3, #0]
	//SCBR: Serial Clock Baud Rate
	SPI0->SPI_CSR[1] &= ~(SPI_CSR_SCBR_Msk);
   813d8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   813da:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
   813de:	635a      	str	r2, [r3, #52]	; 0x34
	SPI0->SPI_CSR[1] |= SPI_CSR_SCBR(16);
   813e0:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   813e2:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
   813e6:	635a      	str	r2, [r3, #52]	; 0x34
	//SPI is in Master mode
	SPI0->SPI_MR |= SPI_MR_MSTR;
   813e8:	685a      	ldr	r2, [r3, #4]
   813ea:	f042 0201 	orr.w	r2, r2, #1
   813ee:	605a      	str	r2, [r3, #4]
	//The Peripheral Chip Select does not rise after the last transfer is achieved
	//It remains active until a new transfer is requested on a different chip select.
	SPI0->SPI_CSR[1] |= SPI_CSR_CSAAT;
   813f0:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   813f2:	f042 0208 	orr.w	r2, r2, #8
   813f6:	635a      	str	r2, [r3, #52]	; 0x34
	//Fixed Peripheral Select.
	SPI0->SPI_MR &= ~SPI_MR_PS;
   813f8:	685a      	ldr	r2, [r3, #4]
   813fa:	f022 0202 	bic.w	r2, r2, #2
   813fe:	605a      	str	r2, [r3, #4]
	//Delay Between Chip Selects
	SPI0->SPI_MR |= SPI_MR_PCS_Msk;//reset
   81400:	685a      	ldr	r2, [r3, #4]
   81402:	f442 2270 	orr.w	r2, r2, #983040	; 0xf0000
   81406:	605a      	str	r2, [r3, #4]
	SPI0->SPI_MR &= ~SPI_MR_DLYBCS_Msk;//reset
   81408:	685a      	ldr	r2, [r3, #4]
   8140a:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
   8140e:	605a      	str	r2, [r3, #4]
	SPI0->SPI_MR |= SPI_MR_DLYBCS(6);//set delay
   81410:	685a      	ldr	r2, [r3, #4]
   81412:	f042 62c0 	orr.w	r2, r2, #100663296	; 0x6000000
   81416:	605a      	str	r2, [r3, #4]
	//Peripheral Chip Select
	SPI0->SPI_MR &= ~SPI_MR_PCS_Msk;//reset
   81418:	685a      	ldr	r2, [r3, #4]
   8141a:	f422 2270 	bic.w	r2, r2, #983040	; 0xf0000
   8141e:	605a      	str	r2, [r3, #4]
	SPI0->SPI_MR |= SPI_MR_PCS(0b1101);//select
   81420:	685a      	ldr	r2, [r3, #4]
   81422:	f442 2250 	orr.w	r2, r2, #851968	; 0xd0000
   81426:	605a      	str	r2, [r3, #4]
   81428:	4770      	bx	lr
   8142a:	bf00      	nop
   8142c:	400e0600 	.word	0x400e0600
   81430:	40008000 	.word	0x40008000

00081434 <TWI_init_RTC>:
#include "TWI_init_SAM.h"

void TWI_init_RTC(void)
{
	//Set device address
	TWI0->TWI_MMR |= TWI_MMR_DADR(0b1101111);
   81434:	4b06      	ldr	r3, [pc, #24]	; (81450 <TWI_init_RTC+0x1c>)
   81436:	685a      	ldr	r2, [r3, #4]
   81438:	f442 02de 	orr.w	r2, r2, #7274496	; 0x6f0000
   8143c:	605a      	str	r2, [r3, #4]
	//sets Internal Device Address Size to 1 Byte
	TWI0->TWI_MMR &= ~(TWI_MMR_IADRSZ_Msk);
   8143e:	685a      	ldr	r2, [r3, #4]
   81440:	f422 7240 	bic.w	r2, r2, #768	; 0x300
   81444:	605a      	str	r2, [r3, #4]
	TWI0->TWI_MMR |= (TWI_MMR_IADRSZ_1_BYTE);
   81446:	685a      	ldr	r2, [r3, #4]
   81448:	f442 7280 	orr.w	r2, r2, #256	; 0x100
   8144c:	605a      	str	r2, [r3, #4]
   8144e:	4770      	bx	lr
   81450:	4008c000 	.word	0x4008c000

00081454 <TWI_init>:
}

void TWI_init(void)
{
   81454:	b508      	push	{r3, lr}
	//Disable PMC Write Protect Mode Register
	PMC->PMC_WPMR =PMC_WPMR_WPKEY_PASSWD|~(PMC_WPMR_WPEN);
   81456:	4b0b      	ldr	r3, [pc, #44]	; (81484 <TWI_init+0x30>)
   81458:	f06f 0201 	mvn.w	r2, #1
   8145c:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
	//Enable Peripheral Clock
	PMC->PMC_PCER0 |= (PMC_PCER0_PID22);//enable clock for TWI0
   81460:	691a      	ldr	r2, [r3, #16]
   81462:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
   81466:	611a      	str	r2, [r3, #16]
	//Set clock period L and H = 1.25e-6
	TWI0->TWI_CWGR = TWI_CWGR_CLDIV(0x2F)|TWI_CWGR_CHDIV(0x2F)|TWI_CWGR_CKDIV(0x1);
   81468:	4b07      	ldr	r3, [pc, #28]	; (81488 <TWI_init+0x34>)
   8146a:	4a08      	ldr	r2, [pc, #32]	; (8148c <TWI_init+0x38>)
   8146c:	611a      	str	r2, [r3, #16]
	//Disable Slave mode
	TWI0->TWI_CR |= TWI_CR_SVDIS;
   8146e:	681a      	ldr	r2, [r3, #0]
   81470:	f042 0220 	orr.w	r2, r2, #32
   81474:	601a      	str	r2, [r3, #0]
	//Enable Master mode 
	TWI0->TWI_CR |=  TWI_CR_MSEN;
   81476:	681a      	ldr	r2, [r3, #0]
   81478:	f042 0204 	orr.w	r2, r2, #4
   8147c:	601a      	str	r2, [r3, #0]
	
	TWI_init_RTC();
   8147e:	4b04      	ldr	r3, [pc, #16]	; (81490 <TWI_init+0x3c>)
   81480:	4798      	blx	r3
   81482:	bd08      	pop	{r3, pc}
   81484:	400e0600 	.word	0x400e0600
   81488:	4008c000 	.word	0x4008c000
   8148c:	00012f2f 	.word	0x00012f2f
   81490:	00081435 	.word	0x00081435

00081494 <USART0_init>:

void USART0_init(void)//w
{
	volatile uint32_t t;
	//clear write protect
	USART0->US_WPMR =US_WPMR_WPKEY_PASSWD|~(PMC_WPMR_WPEN);
   81494:	4b24      	ldr	r3, [pc, #144]	; (81528 <USART0_init+0x94>)
   81496:	f06f 0201 	mvn.w	r2, #1
   8149a:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
	//select MCK as clock
	USART0->US_MR &= ~(US_MR_USCLKS_Msk);//reset
   8149e:	685a      	ldr	r2, [r3, #4]
   814a0:	f022 0230 	bic.w	r2, r2, #48	; 0x30
   814a4:	605a      	str	r2, [r3, #4]
	USART0->US_MR |= (US_MR_USCLKS_MCK);//set
   814a6:	685a      	ldr	r2, [r3, #4]
   814a8:	605a      	str	r2, [r3, #4]
	//set usart to normal mode
	USART0->US_MR &=~(US_MR_USART_MODE_Msk);
   814aa:	685a      	ldr	r2, [r3, #4]
   814ac:	f022 020f 	bic.w	r2, r2, #15
   814b0:	605a      	str	r2, [r3, #4]
	USART0->US_MR |=US_MR_USART_MODE_NORMAL;
   814b2:	685a      	ldr	r2, [r3, #4]
   814b4:	605a      	str	r2, [r3, #4]
	//set character length to 8 bits
	USART0->US_MR &=~(US_MR_CHRL_Msk);
   814b6:	685a      	ldr	r2, [r3, #4]
   814b8:	f022 02c0 	bic.w	r2, r2, #192	; 0xc0
   814bc:	605a      	str	r2, [r3, #4]
	USART0->US_MR |=US_MR_CHRL_8_BIT;
   814be:	685a      	ldr	r2, [r3, #4]
   814c0:	f042 02c0 	orr.w	r2, r2, #192	; 0xc0
   814c4:	605a      	str	r2, [r3, #4]
	//set parity type to no parity
	USART0->US_MR &=~(US_MR_PAR_Msk);
   814c6:	685a      	ldr	r2, [r3, #4]
   814c8:	f422 6260 	bic.w	r2, r2, #3584	; 0xe00
   814cc:	605a      	str	r2, [r3, #4]
	USART0->US_MR |=US_MR_PAR_NO;
   814ce:	685a      	ldr	r2, [r3, #4]
   814d0:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
   814d4:	605a      	str	r2, [r3, #4]
	//set baud rate
	USART0->US_BRGR &=~(US_BRGR_CD_Msk);
   814d6:	6a1a      	ldr	r2, [r3, #32]
   814d8:	0c12      	lsrs	r2, r2, #16
   814da:	0412      	lsls	r2, r2, #16
   814dc:	621a      	str	r2, [r3, #32]
	USART0->US_BRGR |=0x2B;//115200
   814de:	6a1a      	ldr	r2, [r3, #32]
   814e0:	f042 022b 	orr.w	r2, r2, #43	; 0x2b
   814e4:	621a      	str	r2, [r3, #32]
	//enable transmit and receive
	USART0->US_CR |=US_CR_RSTRX;//reset receive
   814e6:	681a      	ldr	r2, [r3, #0]
   814e8:	f042 0204 	orr.w	r2, r2, #4
   814ec:	601a      	str	r2, [r3, #0]
	USART0->US_CR &=~US_CR_RSTRX;
   814ee:	681a      	ldr	r2, [r3, #0]
   814f0:	f022 0204 	bic.w	r2, r2, #4
   814f4:	601a      	str	r2, [r3, #0]
	USART0->US_CR &=~US_CR_RXDIS;//reset disable
   814f6:	681a      	ldr	r2, [r3, #0]
   814f8:	f022 0220 	bic.w	r2, r2, #32
   814fc:	601a      	str	r2, [r3, #0]
	USART0->US_CR |=US_CR_RXEN;//enable receive
   814fe:	681a      	ldr	r2, [r3, #0]
   81500:	f042 0210 	orr.w	r2, r2, #16
   81504:	601a      	str	r2, [r3, #0]
	USART0->US_CR |=US_CR_RSTTX;//reset transmit
   81506:	681a      	ldr	r2, [r3, #0]
   81508:	f042 0208 	orr.w	r2, r2, #8
   8150c:	601a      	str	r2, [r3, #0]
	USART0->US_CR &=~US_CR_RSTTX;
   8150e:	681a      	ldr	r2, [r3, #0]
   81510:	f022 0208 	bic.w	r2, r2, #8
   81514:	601a      	str	r2, [r3, #0]
	USART0->US_CR &=~US_CR_TXDIS;//reset disable
   81516:	681a      	ldr	r2, [r3, #0]
   81518:	f022 0280 	bic.w	r2, r2, #128	; 0x80
   8151c:	601a      	str	r2, [r3, #0]
	USART0->US_CR |=US_CR_TXEN;//enable transmit
   8151e:	681a      	ldr	r2, [r3, #0]
   81520:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   81524:	601a      	str	r2, [r3, #0]
   81526:	4770      	bx	lr
   81528:	40098000 	.word	0x40098000

0008152c <__libc_init_array>:
   8152c:	b570      	push	{r4, r5, r6, lr}
   8152e:	4e0f      	ldr	r6, [pc, #60]	; (8156c <__libc_init_array+0x40>)
   81530:	4d0f      	ldr	r5, [pc, #60]	; (81570 <__libc_init_array+0x44>)
   81532:	1b76      	subs	r6, r6, r5
   81534:	10b6      	asrs	r6, r6, #2
   81536:	bf18      	it	ne
   81538:	2400      	movne	r4, #0
   8153a:	d005      	beq.n	81548 <__libc_init_array+0x1c>
   8153c:	3401      	adds	r4, #1
   8153e:	f855 3b04 	ldr.w	r3, [r5], #4
   81542:	4798      	blx	r3
   81544:	42a6      	cmp	r6, r4
   81546:	d1f9      	bne.n	8153c <__libc_init_array+0x10>
   81548:	4e0a      	ldr	r6, [pc, #40]	; (81574 <__libc_init_array+0x48>)
   8154a:	4d0b      	ldr	r5, [pc, #44]	; (81578 <__libc_init_array+0x4c>)
   8154c:	f000 f92e 	bl	817ac <_init>
   81550:	1b76      	subs	r6, r6, r5
   81552:	10b6      	asrs	r6, r6, #2
   81554:	bf18      	it	ne
   81556:	2400      	movne	r4, #0
   81558:	d006      	beq.n	81568 <__libc_init_array+0x3c>
   8155a:	3401      	adds	r4, #1
   8155c:	f855 3b04 	ldr.w	r3, [r5], #4
   81560:	4798      	blx	r3
   81562:	42a6      	cmp	r6, r4
   81564:	d1f9      	bne.n	8155a <__libc_init_array+0x2e>
   81566:	bd70      	pop	{r4, r5, r6, pc}
   81568:	bd70      	pop	{r4, r5, r6, pc}
   8156a:	bf00      	nop
   8156c:	000817b8 	.word	0x000817b8
   81570:	000817b8 	.word	0x000817b8
   81574:	000817c0 	.word	0x000817c0
   81578:	000817b8 	.word	0x000817b8

0008157c <memset>:
   8157c:	b470      	push	{r4, r5, r6}
   8157e:	0786      	lsls	r6, r0, #30
   81580:	d046      	beq.n	81610 <memset+0x94>
   81582:	1e54      	subs	r4, r2, #1
   81584:	2a00      	cmp	r2, #0
   81586:	d041      	beq.n	8160c <memset+0x90>
   81588:	b2ca      	uxtb	r2, r1
   8158a:	4603      	mov	r3, r0
   8158c:	e002      	b.n	81594 <memset+0x18>
   8158e:	f114 34ff 	adds.w	r4, r4, #4294967295
   81592:	d33b      	bcc.n	8160c <memset+0x90>
   81594:	f803 2b01 	strb.w	r2, [r3], #1
   81598:	079d      	lsls	r5, r3, #30
   8159a:	d1f8      	bne.n	8158e <memset+0x12>
   8159c:	2c03      	cmp	r4, #3
   8159e:	d92e      	bls.n	815fe <memset+0x82>
   815a0:	b2cd      	uxtb	r5, r1
   815a2:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
   815a6:	2c0f      	cmp	r4, #15
   815a8:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
   815ac:	d919      	bls.n	815e2 <memset+0x66>
   815ae:	4626      	mov	r6, r4
   815b0:	f103 0210 	add.w	r2, r3, #16
   815b4:	3e10      	subs	r6, #16
   815b6:	2e0f      	cmp	r6, #15
   815b8:	f842 5c10 	str.w	r5, [r2, #-16]
   815bc:	f842 5c0c 	str.w	r5, [r2, #-12]
   815c0:	f842 5c08 	str.w	r5, [r2, #-8]
   815c4:	f842 5c04 	str.w	r5, [r2, #-4]
   815c8:	f102 0210 	add.w	r2, r2, #16
   815cc:	d8f2      	bhi.n	815b4 <memset+0x38>
   815ce:	f1a4 0210 	sub.w	r2, r4, #16
   815d2:	f022 020f 	bic.w	r2, r2, #15
   815d6:	f004 040f 	and.w	r4, r4, #15
   815da:	3210      	adds	r2, #16
   815dc:	2c03      	cmp	r4, #3
   815de:	4413      	add	r3, r2
   815e0:	d90d      	bls.n	815fe <memset+0x82>
   815e2:	461e      	mov	r6, r3
   815e4:	4622      	mov	r2, r4
   815e6:	3a04      	subs	r2, #4
   815e8:	2a03      	cmp	r2, #3
   815ea:	f846 5b04 	str.w	r5, [r6], #4
   815ee:	d8fa      	bhi.n	815e6 <memset+0x6a>
   815f0:	1f22      	subs	r2, r4, #4
   815f2:	f022 0203 	bic.w	r2, r2, #3
   815f6:	3204      	adds	r2, #4
   815f8:	4413      	add	r3, r2
   815fa:	f004 0403 	and.w	r4, r4, #3
   815fe:	b12c      	cbz	r4, 8160c <memset+0x90>
   81600:	b2c9      	uxtb	r1, r1
   81602:	441c      	add	r4, r3
   81604:	f803 1b01 	strb.w	r1, [r3], #1
   81608:	429c      	cmp	r4, r3
   8160a:	d1fb      	bne.n	81604 <memset+0x88>
   8160c:	bc70      	pop	{r4, r5, r6}
   8160e:	4770      	bx	lr
   81610:	4614      	mov	r4, r2
   81612:	4603      	mov	r3, r0
   81614:	e7c2      	b.n	8159c <memset+0x20>
   81616:	bf00      	nop

00081618 <strncpy>:
   81618:	ea40 0301 	orr.w	r3, r0, r1
   8161c:	f013 0f03 	tst.w	r3, #3
   81620:	b470      	push	{r4, r5, r6}
   81622:	4603      	mov	r3, r0
   81624:	d024      	beq.n	81670 <strncpy+0x58>
   81626:	b1a2      	cbz	r2, 81652 <strncpy+0x3a>
   81628:	780c      	ldrb	r4, [r1, #0]
   8162a:	3a01      	subs	r2, #1
   8162c:	701c      	strb	r4, [r3, #0]
   8162e:	3101      	adds	r1, #1
   81630:	3301      	adds	r3, #1
   81632:	b13c      	cbz	r4, 81644 <strncpy+0x2c>
   81634:	b16a      	cbz	r2, 81652 <strncpy+0x3a>
   81636:	f811 4b01 	ldrb.w	r4, [r1], #1
   8163a:	3a01      	subs	r2, #1
   8163c:	f803 4b01 	strb.w	r4, [r3], #1
   81640:	2c00      	cmp	r4, #0
   81642:	d1f7      	bne.n	81634 <strncpy+0x1c>
   81644:	b12a      	cbz	r2, 81652 <strncpy+0x3a>
   81646:	2100      	movs	r1, #0
   81648:	441a      	add	r2, r3
   8164a:	f803 1b01 	strb.w	r1, [r3], #1
   8164e:	429a      	cmp	r2, r3
   81650:	d1fb      	bne.n	8164a <strncpy+0x32>
   81652:	bc70      	pop	{r4, r5, r6}
   81654:	4770      	bx	lr
   81656:	460e      	mov	r6, r1
   81658:	f851 5b04 	ldr.w	r5, [r1], #4
   8165c:	f1a5 3401 	sub.w	r4, r5, #16843009	; 0x1010101
   81660:	ea24 0405 	bic.w	r4, r4, r5
   81664:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
   81668:	d105      	bne.n	81676 <strncpy+0x5e>
   8166a:	3a04      	subs	r2, #4
   8166c:	f843 5b04 	str.w	r5, [r3], #4
   81670:	2a03      	cmp	r2, #3
   81672:	d8f0      	bhi.n	81656 <strncpy+0x3e>
   81674:	e7d7      	b.n	81626 <strncpy+0xe>
   81676:	4631      	mov	r1, r6
   81678:	e7d6      	b.n	81628 <strncpy+0x10>
   8167a:	bf00      	nop

0008167c <register_fini>:
   8167c:	4b02      	ldr	r3, [pc, #8]	; (81688 <register_fini+0xc>)
   8167e:	b113      	cbz	r3, 81686 <register_fini+0xa>
   81680:	4802      	ldr	r0, [pc, #8]	; (8168c <register_fini+0x10>)
   81682:	f000 b805 	b.w	81690 <atexit>
   81686:	4770      	bx	lr
   81688:	00000000 	.word	0x00000000
   8168c:	0008169d 	.word	0x0008169d

00081690 <atexit>:
   81690:	2300      	movs	r3, #0
   81692:	4601      	mov	r1, r0
   81694:	461a      	mov	r2, r3
   81696:	4618      	mov	r0, r3
   81698:	f000 b81e 	b.w	816d8 <__register_exitproc>

0008169c <__libc_fini_array>:
   8169c:	b538      	push	{r3, r4, r5, lr}
   8169e:	4c0a      	ldr	r4, [pc, #40]	; (816c8 <__libc_fini_array+0x2c>)
   816a0:	4d0a      	ldr	r5, [pc, #40]	; (816cc <__libc_fini_array+0x30>)
   816a2:	1b64      	subs	r4, r4, r5
   816a4:	10a4      	asrs	r4, r4, #2
   816a6:	d00a      	beq.n	816be <__libc_fini_array+0x22>
   816a8:	f104 4380 	add.w	r3, r4, #1073741824	; 0x40000000
   816ac:	3b01      	subs	r3, #1
   816ae:	eb05 0583 	add.w	r5, r5, r3, lsl #2
   816b2:	3c01      	subs	r4, #1
   816b4:	f855 3904 	ldr.w	r3, [r5], #-4
   816b8:	4798      	blx	r3
   816ba:	2c00      	cmp	r4, #0
   816bc:	d1f9      	bne.n	816b2 <__libc_fini_array+0x16>
   816be:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   816c2:	f000 b87d 	b.w	817c0 <_fini>
   816c6:	bf00      	nop
   816c8:	000817d0 	.word	0x000817d0
   816cc:	000817cc 	.word	0x000817cc

000816d0 <__retarget_lock_acquire_recursive>:
   816d0:	4770      	bx	lr
   816d2:	bf00      	nop

000816d4 <__retarget_lock_release_recursive>:
   816d4:	4770      	bx	lr
   816d6:	bf00      	nop

000816d8 <__register_exitproc>:
   816d8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   816dc:	4d2c      	ldr	r5, [pc, #176]	; (81790 <__register_exitproc+0xb8>)
   816de:	4606      	mov	r6, r0
   816e0:	6828      	ldr	r0, [r5, #0]
   816e2:	4698      	mov	r8, r3
   816e4:	460f      	mov	r7, r1
   816e6:	4691      	mov	r9, r2
   816e8:	f7ff fff2 	bl	816d0 <__retarget_lock_acquire_recursive>
   816ec:	4b29      	ldr	r3, [pc, #164]	; (81794 <__register_exitproc+0xbc>)
   816ee:	681c      	ldr	r4, [r3, #0]
   816f0:	f8d4 3148 	ldr.w	r3, [r4, #328]	; 0x148
   816f4:	2b00      	cmp	r3, #0
   816f6:	d03e      	beq.n	81776 <__register_exitproc+0x9e>
   816f8:	685a      	ldr	r2, [r3, #4]
   816fa:	2a1f      	cmp	r2, #31
   816fc:	dc1c      	bgt.n	81738 <__register_exitproc+0x60>
   816fe:	f102 0e01 	add.w	lr, r2, #1
   81702:	b176      	cbz	r6, 81722 <__register_exitproc+0x4a>
   81704:	2101      	movs	r1, #1
   81706:	eb03 0482 	add.w	r4, r3, r2, lsl #2
   8170a:	f8c4 9088 	str.w	r9, [r4, #136]	; 0x88
   8170e:	f8d3 0188 	ldr.w	r0, [r3, #392]	; 0x188
   81712:	4091      	lsls	r1, r2
   81714:	4308      	orrs	r0, r1
   81716:	2e02      	cmp	r6, #2
   81718:	f8c3 0188 	str.w	r0, [r3, #392]	; 0x188
   8171c:	f8c4 8108 	str.w	r8, [r4, #264]	; 0x108
   81720:	d023      	beq.n	8176a <__register_exitproc+0x92>
   81722:	3202      	adds	r2, #2
   81724:	f8c3 e004 	str.w	lr, [r3, #4]
   81728:	6828      	ldr	r0, [r5, #0]
   8172a:	f843 7022 	str.w	r7, [r3, r2, lsl #2]
   8172e:	f7ff ffd1 	bl	816d4 <__retarget_lock_release_recursive>
   81732:	2000      	movs	r0, #0
   81734:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   81738:	4b17      	ldr	r3, [pc, #92]	; (81798 <__register_exitproc+0xc0>)
   8173a:	b30b      	cbz	r3, 81780 <__register_exitproc+0xa8>
   8173c:	f44f 70c8 	mov.w	r0, #400	; 0x190
   81740:	f3af 8000 	nop.w
   81744:	4603      	mov	r3, r0
   81746:	b1d8      	cbz	r0, 81780 <__register_exitproc+0xa8>
   81748:	2000      	movs	r0, #0
   8174a:	f8d4 1148 	ldr.w	r1, [r4, #328]	; 0x148
   8174e:	f04f 0e01 	mov.w	lr, #1
   81752:	6058      	str	r0, [r3, #4]
   81754:	6019      	str	r1, [r3, #0]
   81756:	4602      	mov	r2, r0
   81758:	f8c4 3148 	str.w	r3, [r4, #328]	; 0x148
   8175c:	f8c3 0188 	str.w	r0, [r3, #392]	; 0x188
   81760:	f8c3 018c 	str.w	r0, [r3, #396]	; 0x18c
   81764:	2e00      	cmp	r6, #0
   81766:	d0dc      	beq.n	81722 <__register_exitproc+0x4a>
   81768:	e7cc      	b.n	81704 <__register_exitproc+0x2c>
   8176a:	f8d3 018c 	ldr.w	r0, [r3, #396]	; 0x18c
   8176e:	4301      	orrs	r1, r0
   81770:	f8c3 118c 	str.w	r1, [r3, #396]	; 0x18c
   81774:	e7d5      	b.n	81722 <__register_exitproc+0x4a>
   81776:	f504 73a6 	add.w	r3, r4, #332	; 0x14c
   8177a:	f8c4 3148 	str.w	r3, [r4, #328]	; 0x148
   8177e:	e7bb      	b.n	816f8 <__register_exitproc+0x20>
   81780:	6828      	ldr	r0, [r5, #0]
   81782:	f7ff ffa7 	bl	816d4 <__retarget_lock_release_recursive>
   81786:	f04f 30ff 	mov.w	r0, #4294967295
   8178a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   8178e:	bf00      	nop
   81790:	20000438 	.word	0x20000438
   81794:	000817a8 	.word	0x000817a8
   81798:	00000000 	.word	0x00000000
   8179c:	6c6c6548 	.word	0x6c6c6548
   817a0:	6f57206f 	.word	0x6f57206f
   817a4:	00646c72 	.word	0x00646c72

000817a8 <_global_impure_ptr>:
   817a8:	20000010                                ... 

000817ac <_init>:
   817ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   817ae:	bf00      	nop
   817b0:	bcf8      	pop	{r3, r4, r5, r6, r7}
   817b2:	bc08      	pop	{r3}
   817b4:	469e      	mov	lr, r3
   817b6:	4770      	bx	lr

000817b8 <__init_array_start>:
   817b8:	0008167d 	.word	0x0008167d

000817bc <__frame_dummy_init_array_entry>:
   817bc:	00080119                                ....

000817c0 <_fini>:
   817c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   817c2:	bf00      	nop
   817c4:	bcf8      	pop	{r3, r4, r5, r6, r7}
   817c6:	bc08      	pop	{r3}
   817c8:	469e      	mov	lr, r3
   817ca:	4770      	bx	lr

000817cc <__fini_array_start>:
   817cc:	000800f5 	.word	0x000800f5
