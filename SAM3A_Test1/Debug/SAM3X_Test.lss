
SAM3X_Test.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000025d0  00080000  00080000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     0000043c  20000000  000825d0  00020000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000a1b8  20000440  00082a10  0002043c  2**3
                  ALLOC
  3 .stack        00000400  2000a5f8  0008cbc8  0002043c  2**0
                  ALLOC
  4 .heap         00000200  2000a9f8  0008cfc8  0002043c  2**0
                  ALLOC
  5 .ARM.attributes 00000029  00000000  00000000  0002043c  2**0
                  CONTENTS, READONLY
  6 .comment      00000059  00000000  00000000  00020465  2**0
                  CONTENTS, READONLY
  7 .debug_info   0000a986  00000000  00000000  000204be  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001b8e  00000000  00000000  0002ae44  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00003d26  00000000  00000000  0002c9d2  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 000005e8  00000000  00000000  000306f8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000528  00000000  00000000  00030ce0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  00013c7b  00000000  00000000  00031208  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0000747f  00000000  00000000  00044e83  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0005b1cb  00000000  00000000  0004c302  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  0000105c  00000000  00000000  000a74d0  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00080000 <exception_table>:
   80000:	f8 a9 00 20 65 01 08 00 61 01 08 00 61 01 08 00     ... e...a...a...
   80010:	61 01 08 00 61 01 08 00 61 01 08 00 00 00 00 00     a...a...a.......
	...
   8002c:	55 04 08 00 61 01 08 00 00 00 00 00 d5 04 08 00     U...a...........
   8003c:	11 05 08 00 61 01 08 00 61 01 08 00 61 01 08 00     ....a...a...a...
   8004c:	61 01 08 00 61 01 08 00 61 01 08 00 61 01 08 00     a...a...a...a...
   8005c:	61 01 08 00 61 01 08 00 61 01 08 00 00 00 00 00     a...a...a.......
   8006c:	61 01 08 00 61 01 08 00 61 01 08 00 61 01 08 00     a...a...a...a...
	...
   80084:	61 01 08 00 61 01 08 00 61 01 08 00 61 01 08 00     a...a...a...a...
   80094:	61 01 08 00 61 01 08 00 61 01 08 00 61 01 08 00     a...a...a...a...
   800a4:	00 00 00 00 61 01 08 00 61 01 08 00 61 01 08 00     ....a...a...a...
   800b4:	61 01 08 00 61 01 08 00 61 01 08 00 61 01 08 00     a...a...a...a...
   800c4:	61 01 08 00 61 01 08 00 61 01 08 00 61 01 08 00     a...a...a...a...
   800d4:	61 01 08 00 61 01 08 00 61 01 08 00 61 01 08 00     a...a...a...a...
   800e4:	61 01 08 00 61 01 08 00 61 01 08 00 61 01 08 00     a...a...a...a...

000800f4 <__do_global_dtors_aux>:
   800f4:	b510      	push	{r4, lr}
   800f6:	4c05      	ldr	r4, [pc, #20]	; (8010c <__do_global_dtors_aux+0x18>)
   800f8:	7823      	ldrb	r3, [r4, #0]
   800fa:	b933      	cbnz	r3, 8010a <__do_global_dtors_aux+0x16>
   800fc:	4b04      	ldr	r3, [pc, #16]	; (80110 <__do_global_dtors_aux+0x1c>)
   800fe:	b113      	cbz	r3, 80106 <__do_global_dtors_aux+0x12>
   80100:	4804      	ldr	r0, [pc, #16]	; (80114 <__do_global_dtors_aux+0x20>)
   80102:	f3af 8000 	nop.w
   80106:	2301      	movs	r3, #1
   80108:	7023      	strb	r3, [r4, #0]
   8010a:	bd10      	pop	{r4, pc}
   8010c:	20000440 	.word	0x20000440
   80110:	00000000 	.word	0x00000000
   80114:	000825d0 	.word	0x000825d0

00080118 <frame_dummy>:
   80118:	4b0c      	ldr	r3, [pc, #48]	; (8014c <frame_dummy+0x34>)
   8011a:	b143      	cbz	r3, 8012e <frame_dummy+0x16>
   8011c:	480c      	ldr	r0, [pc, #48]	; (80150 <frame_dummy+0x38>)
   8011e:	b510      	push	{r4, lr}
   80120:	490c      	ldr	r1, [pc, #48]	; (80154 <frame_dummy+0x3c>)
   80122:	f3af 8000 	nop.w
   80126:	480c      	ldr	r0, [pc, #48]	; (80158 <frame_dummy+0x40>)
   80128:	6803      	ldr	r3, [r0, #0]
   8012a:	b923      	cbnz	r3, 80136 <frame_dummy+0x1e>
   8012c:	bd10      	pop	{r4, pc}
   8012e:	480a      	ldr	r0, [pc, #40]	; (80158 <frame_dummy+0x40>)
   80130:	6803      	ldr	r3, [r0, #0]
   80132:	b933      	cbnz	r3, 80142 <frame_dummy+0x2a>
   80134:	4770      	bx	lr
   80136:	4b09      	ldr	r3, [pc, #36]	; (8015c <frame_dummy+0x44>)
   80138:	2b00      	cmp	r3, #0
   8013a:	d0f7      	beq.n	8012c <frame_dummy+0x14>
   8013c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   80140:	4718      	bx	r3
   80142:	4b06      	ldr	r3, [pc, #24]	; (8015c <frame_dummy+0x44>)
   80144:	2b00      	cmp	r3, #0
   80146:	d0f5      	beq.n	80134 <frame_dummy+0x1c>
   80148:	4718      	bx	r3
   8014a:	bf00      	nop
   8014c:	00000000 	.word	0x00000000
   80150:	000825d0 	.word	0x000825d0
   80154:	20000444 	.word	0x20000444
   80158:	000825d0 	.word	0x000825d0
   8015c:	00000000 	.word	0x00000000

00080160 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
   80160:	e7fe      	b.n	80160 <Dummy_Handler>
	...

00080164 <Reset_Handler>:
{
   80164:	b508      	push	{r3, lr}
        if (pSrc != pDest) {
   80166:	4b11      	ldr	r3, [pc, #68]	; (801ac <Reset_Handler+0x48>)
   80168:	4a11      	ldr	r2, [pc, #68]	; (801b0 <Reset_Handler+0x4c>)
   8016a:	429a      	cmp	r2, r3
   8016c:	d009      	beq.n	80182 <Reset_Handler+0x1e>
   8016e:	4b0f      	ldr	r3, [pc, #60]	; (801ac <Reset_Handler+0x48>)
   80170:	4a0f      	ldr	r2, [pc, #60]	; (801b0 <Reset_Handler+0x4c>)
   80172:	e003      	b.n	8017c <Reset_Handler+0x18>
                        *pDest++ = *pSrc++;
   80174:	6811      	ldr	r1, [r2, #0]
   80176:	6019      	str	r1, [r3, #0]
   80178:	3304      	adds	r3, #4
   8017a:	3204      	adds	r2, #4
                for (; pDest < &_erelocate;) {
   8017c:	490d      	ldr	r1, [pc, #52]	; (801b4 <Reset_Handler+0x50>)
   8017e:	428b      	cmp	r3, r1
   80180:	d3f8      	bcc.n	80174 <Reset_Handler+0x10>
                        *pDest++ = *pSrc++;
   80182:	4b0d      	ldr	r3, [pc, #52]	; (801b8 <Reset_Handler+0x54>)
   80184:	e002      	b.n	8018c <Reset_Handler+0x28>
                *pDest++ = 0;
   80186:	2200      	movs	r2, #0
   80188:	601a      	str	r2, [r3, #0]
   8018a:	3304      	adds	r3, #4
        for (pDest = &_szero; pDest < &_ezero;) {
   8018c:	4a0b      	ldr	r2, [pc, #44]	; (801bc <Reset_Handler+0x58>)
   8018e:	4293      	cmp	r3, r2
   80190:	d3f9      	bcc.n	80186 <Reset_Handler+0x22>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
   80192:	4b0b      	ldr	r3, [pc, #44]	; (801c0 <Reset_Handler+0x5c>)
   80194:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
   80198:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
   8019c:	4a09      	ldr	r2, [pc, #36]	; (801c4 <Reset_Handler+0x60>)
   8019e:	6093      	str	r3, [r2, #8]
        __libc_init_array();
   801a0:	4b09      	ldr	r3, [pc, #36]	; (801c8 <Reset_Handler+0x64>)
   801a2:	4798      	blx	r3
        main();
   801a4:	4b09      	ldr	r3, [pc, #36]	; (801cc <Reset_Handler+0x68>)
   801a6:	4798      	blx	r3
   801a8:	e7fe      	b.n	801a8 <Reset_Handler+0x44>
   801aa:	bf00      	nop
   801ac:	20000000 	.word	0x20000000
   801b0:	000825d0 	.word	0x000825d0
   801b4:	2000043c 	.word	0x2000043c
   801b8:	20000440 	.word	0x20000440
   801bc:	2000a5f8 	.word	0x2000a5f8
   801c0:	00080000 	.word	0x00080000
   801c4:	e000ed00 	.word	0xe000ed00
   801c8:	00082225 	.word	0x00082225
   801cc:	00081b91 	.word	0x00081b91

000801d0 <SystemInit>:
 * Initialize the System and update the SystemFrequency variable.
 */
void SystemInit( void )
{
  /* Set FWS according to SYS_BOARD_MCKR configuration */
  EFC0->EEFC_FMR = EEFC_FMR_FWS(4);
   801d0:	f44f 6380 	mov.w	r3, #1024	; 0x400
   801d4:	4a20      	ldr	r2, [pc, #128]	; (80258 <SystemInit+0x88>)
   801d6:	6013      	str	r3, [r2, #0]
  EFC1->EEFC_FMR = EEFC_FMR_FWS(4);
   801d8:	f502 7200 	add.w	r2, r2, #512	; 0x200
   801dc:	6013      	str	r3, [r2, #0]

  /* Initialize main oscillator */
  if ( !(PMC->CKGR_MOR & CKGR_MOR_MOSCSEL) )
   801de:	4b1f      	ldr	r3, [pc, #124]	; (8025c <SystemInit+0x8c>)
   801e0:	6a1b      	ldr	r3, [r3, #32]
   801e2:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
   801e6:	d107      	bne.n	801f8 <SystemInit+0x28>
  {
    PMC->CKGR_MOR = CKGR_MOR_KEY_PASSWD | SYS_BOARD_OSCOUNT | CKGR_MOR_MOSCRCEN | CKGR_MOR_MOSCXTEN;
   801e8:	4a1d      	ldr	r2, [pc, #116]	; (80260 <SystemInit+0x90>)
   801ea:	4b1c      	ldr	r3, [pc, #112]	; (8025c <SystemInit+0x8c>)
   801ec:	621a      	str	r2, [r3, #32]
    while ( !(PMC->PMC_SR & PMC_SR_MOSCXTS) )
   801ee:	4b1b      	ldr	r3, [pc, #108]	; (8025c <SystemInit+0x8c>)
   801f0:	6e9b      	ldr	r3, [r3, #104]	; 0x68
   801f2:	f013 0f01 	tst.w	r3, #1
   801f6:	d0fa      	beq.n	801ee <SystemInit+0x1e>
    {
    }
  }

  /* Switch to 3-20MHz Xtal oscillator */
  PMC->CKGR_MOR = CKGR_MOR_KEY_PASSWD | SYS_BOARD_OSCOUNT | CKGR_MOR_MOSCRCEN | CKGR_MOR_MOSCXTEN | CKGR_MOR_MOSCSEL;
   801f8:	4a1a      	ldr	r2, [pc, #104]	; (80264 <SystemInit+0x94>)
   801fa:	4b18      	ldr	r3, [pc, #96]	; (8025c <SystemInit+0x8c>)
   801fc:	621a      	str	r2, [r3, #32]

  while ( !(PMC->PMC_SR & PMC_SR_MOSCSELS) )
   801fe:	4b17      	ldr	r3, [pc, #92]	; (8025c <SystemInit+0x8c>)
   80200:	6e9b      	ldr	r3, [r3, #104]	; 0x68
   80202:	f413 3f80 	tst.w	r3, #65536	; 0x10000
   80206:	d0fa      	beq.n	801fe <SystemInit+0x2e>
  {
  }
 	PMC->PMC_MCKR = (PMC->PMC_MCKR & ~(uint32_t)PMC_MCKR_CSS_Msk) | PMC_MCKR_CSS_MAIN_CLK;
   80208:	4a14      	ldr	r2, [pc, #80]	; (8025c <SystemInit+0x8c>)
   8020a:	6b13      	ldr	r3, [r2, #48]	; 0x30
   8020c:	f023 0303 	bic.w	r3, r3, #3
   80210:	f043 0301 	orr.w	r3, r3, #1
   80214:	6313      	str	r3, [r2, #48]	; 0x30
  while (!(PMC->PMC_SR & PMC_SR_MCKRDY))
   80216:	4b11      	ldr	r3, [pc, #68]	; (8025c <SystemInit+0x8c>)
   80218:	6e9b      	ldr	r3, [r3, #104]	; 0x68
   8021a:	f013 0f08 	tst.w	r3, #8
   8021e:	d0fa      	beq.n	80216 <SystemInit+0x46>
  {
  }

  /* Initialize PLLA */
  PMC->CKGR_PLLAR = SYS_BOARD_PLLAR;
   80220:	4a11      	ldr	r2, [pc, #68]	; (80268 <SystemInit+0x98>)
   80222:	4b0e      	ldr	r3, [pc, #56]	; (8025c <SystemInit+0x8c>)
   80224:	629a      	str	r2, [r3, #40]	; 0x28
  while ( !(PMC->PMC_SR & PMC_SR_LOCKA) )
   80226:	4b0d      	ldr	r3, [pc, #52]	; (8025c <SystemInit+0x8c>)
   80228:	6e9b      	ldr	r3, [r3, #104]	; 0x68
   8022a:	f013 0f02 	tst.w	r3, #2
   8022e:	d0fa      	beq.n	80226 <SystemInit+0x56>
  {
  }

  /* Switch to main clock */
  PMC->PMC_MCKR = (SYS_BOARD_MCKR & ~PMC_MCKR_CSS_Msk) | PMC_MCKR_CSS_MAIN_CLK;
   80230:	2211      	movs	r2, #17
   80232:	4b0a      	ldr	r3, [pc, #40]	; (8025c <SystemInit+0x8c>)
   80234:	631a      	str	r2, [r3, #48]	; 0x30
  while ( !(PMC->PMC_SR & PMC_SR_MCKRDY) )
   80236:	4b09      	ldr	r3, [pc, #36]	; (8025c <SystemInit+0x8c>)
   80238:	6e9b      	ldr	r3, [r3, #104]	; 0x68
   8023a:	f013 0f08 	tst.w	r3, #8
   8023e:	d0fa      	beq.n	80236 <SystemInit+0x66>
  {
  }

  /* Switch to PLLA */
  PMC->PMC_MCKR = SYS_BOARD_MCKR;
   80240:	2212      	movs	r2, #18
   80242:	4b06      	ldr	r3, [pc, #24]	; (8025c <SystemInit+0x8c>)
   80244:	631a      	str	r2, [r3, #48]	; 0x30
  while ( !(PMC->PMC_SR & PMC_SR_MCKRDY) )
   80246:	4b05      	ldr	r3, [pc, #20]	; (8025c <SystemInit+0x8c>)
   80248:	6e9b      	ldr	r3, [r3, #104]	; 0x68
   8024a:	f013 0f08 	tst.w	r3, #8
   8024e:	d0fa      	beq.n	80246 <SystemInit+0x76>
  {
  }

  SystemCoreClock = CHIP_FREQ_CPU_MAX;
   80250:	4a06      	ldr	r2, [pc, #24]	; (8026c <SystemInit+0x9c>)
   80252:	4b07      	ldr	r3, [pc, #28]	; (80270 <SystemInit+0xa0>)
   80254:	601a      	str	r2, [r3, #0]
   80256:	4770      	bx	lr
   80258:	400e0a00 	.word	0x400e0a00
   8025c:	400e0600 	.word	0x400e0600
   80260:	00370809 	.word	0x00370809
   80264:	01370809 	.word	0x01370809
   80268:	20273f03 	.word	0x20273f03
   8026c:	0501bd00 	.word	0x0501bd00
   80270:	20000000 	.word	0x20000000

00080274 <SystemCoreClockUpdate>:
}

void SystemCoreClockUpdate( void )
{
  /* Determine clock frequency according to clock register values */
  switch ( PMC->PMC_MCKR & PMC_MCKR_CSS_Msk )
   80274:	4b3e      	ldr	r3, [pc, #248]	; (80370 <SystemCoreClockUpdate+0xfc>)
   80276:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   80278:	f003 0303 	and.w	r3, r3, #3
   8027c:	2b03      	cmp	r3, #3
   8027e:	d83f      	bhi.n	80300 <SystemCoreClockUpdate+0x8c>
   80280:	e8df f003 	tbb	[pc, r3]
   80284:	2d2d1102 	.word	0x2d2d1102
  {
    case PMC_MCKR_CSS_SLOW_CLK: /* Slow clock */
      if (SUPC->SUPC_SR & SUPC_SR_OSCSEL)
   80288:	4b3a      	ldr	r3, [pc, #232]	; (80374 <SystemCoreClockUpdate+0x100>)
   8028a:	695b      	ldr	r3, [r3, #20]
   8028c:	f013 0f80 	tst.w	r3, #128	; 0x80
   80290:	d004      	beq.n	8029c <SystemCoreClockUpdate+0x28>
      {
        SystemCoreClock = CHIP_FREQ_XTAL_32K;
   80292:	f44f 4200 	mov.w	r2, #32768	; 0x8000
   80296:	4b38      	ldr	r3, [pc, #224]	; (80378 <SystemCoreClockUpdate+0x104>)
   80298:	601a      	str	r2, [r3, #0]
   8029a:	e031      	b.n	80300 <SystemCoreClockUpdate+0x8c>
      }
      else
      {
        SystemCoreClock = CHIP_FREQ_SLCK_RC;
   8029c:	f44f 42fa 	mov.w	r2, #32000	; 0x7d00
   802a0:	4b35      	ldr	r3, [pc, #212]	; (80378 <SystemCoreClockUpdate+0x104>)
   802a2:	601a      	str	r2, [r3, #0]
   802a4:	e02c      	b.n	80300 <SystemCoreClockUpdate+0x8c>
      }
    break;

    case PMC_MCKR_CSS_MAIN_CLK: /* Main clock */
      if (PMC->CKGR_MOR & CKGR_MOR_MOSCSEL)
   802a6:	4b32      	ldr	r3, [pc, #200]	; (80370 <SystemCoreClockUpdate+0xfc>)
   802a8:	6a1b      	ldr	r3, [r3, #32]
   802aa:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
   802ae:	d003      	beq.n	802b8 <SystemCoreClockUpdate+0x44>
      {
        SystemCoreClock = CHIP_FREQ_XTAL_12M;
   802b0:	4a32      	ldr	r2, [pc, #200]	; (8037c <SystemCoreClockUpdate+0x108>)
   802b2:	4b31      	ldr	r3, [pc, #196]	; (80378 <SystemCoreClockUpdate+0x104>)
   802b4:	601a      	str	r2, [r3, #0]
   802b6:	e023      	b.n	80300 <SystemCoreClockUpdate+0x8c>
      }
      else
      {
        SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
   802b8:	4a31      	ldr	r2, [pc, #196]	; (80380 <SystemCoreClockUpdate+0x10c>)
   802ba:	4b2f      	ldr	r3, [pc, #188]	; (80378 <SystemCoreClockUpdate+0x104>)
   802bc:	601a      	str	r2, [r3, #0]

        switch (PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk)
   802be:	4b2c      	ldr	r3, [pc, #176]	; (80370 <SystemCoreClockUpdate+0xfc>)
   802c0:	6a1b      	ldr	r3, [r3, #32]
   802c2:	f003 0370 	and.w	r3, r3, #112	; 0x70
   802c6:	2b10      	cmp	r3, #16
   802c8:	d005      	beq.n	802d6 <SystemCoreClockUpdate+0x62>
   802ca:	2b20      	cmp	r3, #32
   802cc:	d118      	bne.n	80300 <SystemCoreClockUpdate+0x8c>
          case CKGR_MOR_MOSCRCF_8_MHz:
            SystemCoreClock *= 2U;
          break;

          case CKGR_MOR_MOSCRCF_12_MHz:
            SystemCoreClock *= 3U;
   802ce:	4a2b      	ldr	r2, [pc, #172]	; (8037c <SystemCoreClockUpdate+0x108>)
   802d0:	4b29      	ldr	r3, [pc, #164]	; (80378 <SystemCoreClockUpdate+0x104>)
   802d2:	601a      	str	r2, [r3, #0]
          break;
   802d4:	e014      	b.n	80300 <SystemCoreClockUpdate+0x8c>
            SystemCoreClock *= 2U;
   802d6:	4a2b      	ldr	r2, [pc, #172]	; (80384 <SystemCoreClockUpdate+0x110>)
   802d8:	4b27      	ldr	r3, [pc, #156]	; (80378 <SystemCoreClockUpdate+0x104>)
   802da:	601a      	str	r2, [r3, #0]
          break;
   802dc:	e010      	b.n	80300 <SystemCoreClockUpdate+0x8c>
      }
    break;

    case PMC_MCKR_CSS_PLLA_CLK: /* PLLA clock */
    case PMC_MCKR_CSS_UPLL_CLK: /* UPLL clock */
      if ( PMC->CKGR_MOR & CKGR_MOR_MOSCSEL )
   802de:	4b24      	ldr	r3, [pc, #144]	; (80370 <SystemCoreClockUpdate+0xfc>)
   802e0:	6a1b      	ldr	r3, [r3, #32]
   802e2:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
   802e6:	d01a      	beq.n	8031e <SystemCoreClockUpdate+0xaa>
      {
        SystemCoreClock = CHIP_FREQ_XTAL_12M;
   802e8:	4a24      	ldr	r2, [pc, #144]	; (8037c <SystemCoreClockUpdate+0x108>)
   802ea:	4b23      	ldr	r3, [pc, #140]	; (80378 <SystemCoreClockUpdate+0x104>)
   802ec:	601a      	str	r2, [r3, #0]

          default:
          break;
        }
      }
      if ( (PMC->PMC_MCKR & PMC_MCKR_CSS_Msk) == PMC_MCKR_CSS_PLLA_CLK )
   802ee:	4b20      	ldr	r3, [pc, #128]	; (80370 <SystemCoreClockUpdate+0xfc>)
   802f0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   802f2:	f003 0303 	and.w	r3, r3, #3
   802f6:	2b02      	cmp	r3, #2
   802f8:	d024      	beq.n	80344 <SystemCoreClockUpdate+0xd0>
        SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> CKGR_PLLAR_MULA_Pos) + 1U);
        SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk) >> CKGR_PLLAR_DIVA_Pos));
      }
      else
      {
        SystemCoreClock = CHIP_FREQ_UTMIPLL / 2U;
   802fa:	4a23      	ldr	r2, [pc, #140]	; (80388 <SystemCoreClockUpdate+0x114>)
   802fc:	4b1e      	ldr	r3, [pc, #120]	; (80378 <SystemCoreClockUpdate+0x104>)
   802fe:	601a      	str	r2, [r3, #0]
      }
    break;
  }

  if ( (PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3 )
   80300:	4b1b      	ldr	r3, [pc, #108]	; (80370 <SystemCoreClockUpdate+0xfc>)
   80302:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   80304:	f003 0370 	and.w	r3, r3, #112	; 0x70
   80308:	2b70      	cmp	r3, #112	; 0x70
   8030a:	d029      	beq.n	80360 <SystemCoreClockUpdate+0xec>
  {
    SystemCoreClock /= 3U;
  }
  else
  {
    SystemCoreClock >>= ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) >> PMC_MCKR_PRES_Pos);
   8030c:	4b18      	ldr	r3, [pc, #96]	; (80370 <SystemCoreClockUpdate+0xfc>)
   8030e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
   80310:	f3c2 1202 	ubfx	r2, r2, #4, #3
   80314:	4918      	ldr	r1, [pc, #96]	; (80378 <SystemCoreClockUpdate+0x104>)
   80316:	680b      	ldr	r3, [r1, #0]
   80318:	40d3      	lsrs	r3, r2
   8031a:	600b      	str	r3, [r1, #0]
   8031c:	4770      	bx	lr
        SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
   8031e:	4a18      	ldr	r2, [pc, #96]	; (80380 <SystemCoreClockUpdate+0x10c>)
   80320:	4b15      	ldr	r3, [pc, #84]	; (80378 <SystemCoreClockUpdate+0x104>)
   80322:	601a      	str	r2, [r3, #0]
        switch ( PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk )
   80324:	4b12      	ldr	r3, [pc, #72]	; (80370 <SystemCoreClockUpdate+0xfc>)
   80326:	6a1b      	ldr	r3, [r3, #32]
   80328:	f003 0370 	and.w	r3, r3, #112	; 0x70
   8032c:	2b10      	cmp	r3, #16
   8032e:	d005      	beq.n	8033c <SystemCoreClockUpdate+0xc8>
   80330:	2b20      	cmp	r3, #32
   80332:	d1dc      	bne.n	802ee <SystemCoreClockUpdate+0x7a>
            SystemCoreClock *= 3U;
   80334:	4a11      	ldr	r2, [pc, #68]	; (8037c <SystemCoreClockUpdate+0x108>)
   80336:	4b10      	ldr	r3, [pc, #64]	; (80378 <SystemCoreClockUpdate+0x104>)
   80338:	601a      	str	r2, [r3, #0]
          break;
   8033a:	e7d8      	b.n	802ee <SystemCoreClockUpdate+0x7a>
            SystemCoreClock *= 2U;
   8033c:	4a11      	ldr	r2, [pc, #68]	; (80384 <SystemCoreClockUpdate+0x110>)
   8033e:	4b0e      	ldr	r3, [pc, #56]	; (80378 <SystemCoreClockUpdate+0x104>)
   80340:	601a      	str	r2, [r3, #0]
          break;
   80342:	e7d4      	b.n	802ee <SystemCoreClockUpdate+0x7a>
        SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> CKGR_PLLAR_MULA_Pos) + 1U);
   80344:	480a      	ldr	r0, [pc, #40]	; (80370 <SystemCoreClockUpdate+0xfc>)
   80346:	6a82      	ldr	r2, [r0, #40]	; 0x28
   80348:	f3c2 420a 	ubfx	r2, r2, #16, #11
   8034c:	490a      	ldr	r1, [pc, #40]	; (80378 <SystemCoreClockUpdate+0x104>)
   8034e:	680b      	ldr	r3, [r1, #0]
   80350:	fb02 3303 	mla	r3, r2, r3, r3
        SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk) >> CKGR_PLLAR_DIVA_Pos));
   80354:	6a82      	ldr	r2, [r0, #40]	; 0x28
   80356:	b2d2      	uxtb	r2, r2
   80358:	fbb3 f3f2 	udiv	r3, r3, r2
   8035c:	600b      	str	r3, [r1, #0]
   8035e:	e7cf      	b.n	80300 <SystemCoreClockUpdate+0x8c>
    SystemCoreClock /= 3U;
   80360:	4a05      	ldr	r2, [pc, #20]	; (80378 <SystemCoreClockUpdate+0x104>)
   80362:	6813      	ldr	r3, [r2, #0]
   80364:	4909      	ldr	r1, [pc, #36]	; (8038c <SystemCoreClockUpdate+0x118>)
   80366:	fba1 1303 	umull	r1, r3, r1, r3
   8036a:	085b      	lsrs	r3, r3, #1
   8036c:	6013      	str	r3, [r2, #0]
   8036e:	4770      	bx	lr
   80370:	400e0600 	.word	0x400e0600
   80374:	400e1a10 	.word	0x400e1a10
   80378:	20000000 	.word	0x20000000
   8037c:	00b71b00 	.word	0x00b71b00
   80380:	003d0900 	.word	0x003d0900
   80384:	007a1200 	.word	0x007a1200
   80388:	0e4e1c00 	.word	0x0e4e1c00
   8038c:	aaaaaaab 	.word	0xaaaaaaab

00080390 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
   80390:	f100 0308 	add.w	r3, r0, #8
   80394:	6043      	str	r3, [r0, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
   80396:	f04f 32ff 	mov.w	r2, #4294967295
   8039a:	6082      	str	r2, [r0, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
   8039c:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
   8039e:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
   803a0:	2300      	movs	r3, #0
   803a2:	6003      	str	r3, [r0, #0]
   803a4:	4770      	bx	lr

000803a6 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
   803a6:	2300      	movs	r3, #0
   803a8:	6103      	str	r3, [r0, #16]
   803aa:	4770      	bx	lr

000803ac <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
   803ac:	6843      	ldr	r3, [r0, #4]

	pxNewListItem->pxNext = pxIndex->pxNext;
   803ae:	685a      	ldr	r2, [r3, #4]
   803b0:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxPrevious = pxList->pxIndex;
   803b2:	6842      	ldr	r2, [r0, #4]
   803b4:	608a      	str	r2, [r1, #8]
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
   803b6:	685a      	ldr	r2, [r3, #4]
   803b8:	6091      	str	r1, [r2, #8]
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
   803ba:	6059      	str	r1, [r3, #4]
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
   803bc:	6041      	str	r1, [r0, #4]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
   803be:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
   803c0:	6803      	ldr	r3, [r0, #0]
   803c2:	3301      	adds	r3, #1
   803c4:	6003      	str	r3, [r0, #0]
   803c6:	4770      	bx	lr

000803c8 <vListInsert>:
}
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
   803c8:	b410      	push	{r4}
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
   803ca:	680c      	ldr	r4, [r1, #0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
   803cc:	f1b4 3fff 	cmp.w	r4, #4294967295
   803d0:	d002      	beq.n	803d8 <vListInsert+0x10>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
   803d2:	f100 0308 	add.w	r3, r0, #8
   803d6:	e002      	b.n	803de <vListInsert+0x16>
		pxIterator = pxList->xListEnd.pxPrevious;
   803d8:	6903      	ldr	r3, [r0, #16]
   803da:	e004      	b.n	803e6 <vListInsert+0x1e>
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
   803dc:	685b      	ldr	r3, [r3, #4]
   803de:	685a      	ldr	r2, [r3, #4]
   803e0:	6812      	ldr	r2, [r2, #0]
   803e2:	4294      	cmp	r4, r2
   803e4:	d2fa      	bcs.n	803dc <vListInsert+0x14>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
   803e6:	685a      	ldr	r2, [r3, #4]
   803e8:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
   803ea:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious = pxIterator;
   803ec:	608b      	str	r3, [r1, #8]
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
   803ee:	6059      	str	r1, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
   803f0:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
   803f2:	6803      	ldr	r3, [r0, #0]
   803f4:	3301      	adds	r3, #1
   803f6:	6003      	str	r3, [r0, #0]
}
   803f8:	bc10      	pop	{r4}
   803fa:	4770      	bx	lr

000803fc <uxListRemove>:

unsigned portBASE_TYPE uxListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
   803fc:	6843      	ldr	r3, [r0, #4]
   803fe:	6882      	ldr	r2, [r0, #8]
   80400:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
   80402:	6883      	ldr	r3, [r0, #8]
   80404:	6842      	ldr	r2, [r0, #4]
   80406:	605a      	str	r2, [r3, #4]

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
   80408:	6903      	ldr	r3, [r0, #16]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
   8040a:	685a      	ldr	r2, [r3, #4]
   8040c:	4290      	cmp	r0, r2
   8040e:	d006      	beq.n	8041e <uxListRemove+0x22>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
	}

	pxItemToRemove->pvContainer = NULL;
   80410:	2200      	movs	r2, #0
   80412:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
   80414:	681a      	ldr	r2, [r3, #0]
   80416:	3a01      	subs	r2, #1
   80418:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
   8041a:	6818      	ldr	r0, [r3, #0]
}
   8041c:	4770      	bx	lr
		pxList->pxIndex = pxItemToRemove->pxPrevious;
   8041e:	6882      	ldr	r2, [r0, #8]
   80420:	605a      	str	r2, [r3, #4]
   80422:	e7f5      	b.n	80410 <uxListRemove+0x14>

00080424 <prvPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile(
   80424:	4803      	ldr	r0, [pc, #12]	; (80434 <prvPortStartFirstTask+0x10>)
   80426:	6800      	ldr	r0, [r0, #0]
   80428:	6800      	ldr	r0, [r0, #0]
   8042a:	f380 8808 	msr	MSP, r0
   8042e:	b662      	cpsie	i
   80430:	df00      	svc	0
   80432:	bf00      	nop
   80434:	e000ed08 	.word	0xe000ed08

00080438 <pxPortInitialiseStack>:
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
   80438:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
   8043c:	f840 3c04 	str.w	r3, [r0, #-4]
	*pxTopOfStack = ( portSTACK_TYPE ) pxCode;	/* PC */
   80440:	f840 1c08 	str.w	r1, [r0, #-8]
	*pxTopOfStack = 0;	/* LR */
   80444:	2300      	movs	r3, #0
   80446:	f840 3c0c 	str.w	r3, [r0, #-12]
	*pxTopOfStack = ( portSTACK_TYPE ) pvParameters;	/* R0 */
   8044a:	f840 2c20 	str.w	r2, [r0, #-32]
}
   8044e:	3840      	subs	r0, #64	; 0x40
   80450:	4770      	bx	lr
	...

00080454 <SVC_Handler>:
	__asm volatile (
   80454:	4b06      	ldr	r3, [pc, #24]	; (80470 <pxCurrentTCBConst2>)
   80456:	6819      	ldr	r1, [r3, #0]
   80458:	6808      	ldr	r0, [r1, #0]
   8045a:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
   8045e:	f380 8809 	msr	PSP, r0
   80462:	f04f 0000 	mov.w	r0, #0
   80466:	f380 8811 	msr	BASEPRI, r0
   8046a:	f04e 0e0d 	orr.w	lr, lr, #13
   8046e:	4770      	bx	lr

00080470 <pxCurrentTCBConst2>:
   80470:	2000a53c 	.word	0x2000a53c

00080474 <vPortYieldFromISR>:
/*-----------------------------------------------------------*/

void vPortYieldFromISR( void )
{
	/* Set a PendSV to request a context switch. */
	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
   80474:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   80478:	4b01      	ldr	r3, [pc, #4]	; (80480 <vPortYieldFromISR+0xc>)
   8047a:	601a      	str	r2, [r3, #0]
   8047c:	4770      	bx	lr
   8047e:	bf00      	nop
   80480:	e000ed04 	.word	0xe000ed04

00080484 <ulPortSetInterruptMask>:
}
/*-----------------------------------------------------------*/

__attribute__(( naked )) unsigned long ulPortSetInterruptMask( void )
{
	__asm volatile														\
   80484:	f3ef 8011 	mrs	r0, BASEPRI
   80488:	f04f 01a0 	mov.w	r1, #160	; 0xa0
   8048c:	f381 8811 	msr	BASEPRI, r1
   80490:	4770      	bx	lr
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return 0;
}
   80492:	2000      	movs	r0, #0

00080494 <vPortEnterCritical>:
{
   80494:	b508      	push	{r3, lr}
	portDISABLE_INTERRUPTS();
   80496:	4b03      	ldr	r3, [pc, #12]	; (804a4 <vPortEnterCritical+0x10>)
   80498:	4798      	blx	r3
	uxCriticalNesting++;
   8049a:	4a03      	ldr	r2, [pc, #12]	; (804a8 <vPortEnterCritical+0x14>)
   8049c:	6813      	ldr	r3, [r2, #0]
   8049e:	3301      	adds	r3, #1
   804a0:	6013      	str	r3, [r2, #0]
   804a2:	bd08      	pop	{r3, pc}
   804a4:	00080485 	.word	0x00080485
   804a8:	20000004 	.word	0x20000004

000804ac <vPortClearInterruptMask>:
/*-----------------------------------------------------------*/

__attribute__(( naked )) void vPortClearInterruptMask( unsigned long ulNewMaskValue )
{
	__asm volatile													\
   804ac:	f380 8811 	msr	BASEPRI, r0
   804b0:	4770      	bx	lr
	...

000804b4 <vPortExitCritical>:
{
   804b4:	b508      	push	{r3, lr}
	uxCriticalNesting--;
   804b6:	4a05      	ldr	r2, [pc, #20]	; (804cc <vPortExitCritical+0x18>)
   804b8:	6813      	ldr	r3, [r2, #0]
   804ba:	3b01      	subs	r3, #1
   804bc:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
   804be:	b103      	cbz	r3, 804c2 <vPortExitCritical+0xe>
   804c0:	bd08      	pop	{r3, pc}
		portENABLE_INTERRUPTS();
   804c2:	2000      	movs	r0, #0
   804c4:	4b02      	ldr	r3, [pc, #8]	; (804d0 <vPortExitCritical+0x1c>)
   804c6:	4798      	blx	r3
}
   804c8:	e7fa      	b.n	804c0 <vPortExitCritical+0xc>
   804ca:	bf00      	nop
   804cc:	20000004 	.word	0x20000004
   804d0:	000804ad 	.word	0x000804ad

000804d4 <PendSV_Handler>:

__attribute__(( naked )) void PendSV_Handler( void )
{
	/* This is a naked function. */

	__asm volatile
   804d4:	f3ef 8009 	mrs	r0, PSP
   804d8:	4b0c      	ldr	r3, [pc, #48]	; (8050c <pxCurrentTCBConst>)
   804da:	681a      	ldr	r2, [r3, #0]
   804dc:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
   804e0:	6010      	str	r0, [r2, #0]
   804e2:	e92d 4008 	stmdb	sp!, {r3, lr}
   804e6:	f04f 00a0 	mov.w	r0, #160	; 0xa0
   804ea:	f380 8811 	msr	BASEPRI, r0
   804ee:	f000 ff2b 	bl	81348 <vTaskSwitchContext>
   804f2:	f04f 0000 	mov.w	r0, #0
   804f6:	f380 8811 	msr	BASEPRI, r0
   804fa:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   804fe:	6819      	ldr	r1, [r3, #0]
   80500:	6808      	ldr	r0, [r1, #0]
   80502:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
   80506:	f380 8809 	msr	PSP, r0
   8050a:	4770      	bx	lr

0008050c <pxCurrentTCBConst>:
   8050c:	2000a53c 	.word	0x2000a53c

00080510 <SysTick_Handler>:
	);
}
/*-----------------------------------------------------------*/

void SysTick_Handler( void )
{
   80510:	b508      	push	{r3, lr}
	/* If using preemption, also force a context switch. */
	#if configUSE_PREEMPTION == 1
		portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
   80512:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   80516:	4b05      	ldr	r3, [pc, #20]	; (8052c <SysTick_Handler+0x1c>)
   80518:	601a      	str	r2, [r3, #0]
	to generate the tick interrupt. */
	#if configUSE_TICKLESS_IDLE == 1
		portNVIC_SYSTICK_LOAD_REG = ulTimerReloadValueForOneTick;
	#endif

	( void ) portSET_INTERRUPT_MASK_FROM_ISR();
   8051a:	4b05      	ldr	r3, [pc, #20]	; (80530 <SysTick_Handler+0x20>)
   8051c:	4798      	blx	r3
	{
		vTaskIncrementTick();
   8051e:	4b05      	ldr	r3, [pc, #20]	; (80534 <SysTick_Handler+0x24>)
   80520:	4798      	blx	r3
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( 0 );
   80522:	2000      	movs	r0, #0
   80524:	4b04      	ldr	r3, [pc, #16]	; (80538 <SysTick_Handler+0x28>)
   80526:	4798      	blx	r3
   80528:	bd08      	pop	{r3, pc}
   8052a:	bf00      	nop
   8052c:	e000ed04 	.word	0xe000ed04
   80530:	00080485 	.word	0x00080485
   80534:	0008101d 	.word	0x0008101d
   80538:	000804ad 	.word	0x000804ad

0008053c <vPortSetupTimerInterrupt>:
		ulStoppedTimerCompensation = 45UL / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;;
   8053c:	4b06      	ldr	r3, [pc, #24]	; (80558 <vPortSetupTimerInterrupt+0x1c>)
   8053e:	681b      	ldr	r3, [r3, #0]
   80540:	4a06      	ldr	r2, [pc, #24]	; (8055c <vPortSetupTimerInterrupt+0x20>)
   80542:	fba2 2303 	umull	r2, r3, r2, r3
   80546:	099b      	lsrs	r3, r3, #6
   80548:	3b01      	subs	r3, #1
   8054a:	4a05      	ldr	r2, [pc, #20]	; (80560 <vPortSetupTimerInterrupt+0x24>)
   8054c:	6013      	str	r3, [r2, #0]
	portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT;
   8054e:	2207      	movs	r2, #7
   80550:	4b04      	ldr	r3, [pc, #16]	; (80564 <vPortSetupTimerInterrupt+0x28>)
   80552:	601a      	str	r2, [r3, #0]
   80554:	4770      	bx	lr
   80556:	bf00      	nop
   80558:	20000000 	.word	0x20000000
   8055c:	10624dd3 	.word	0x10624dd3
   80560:	e000e014 	.word	0xe000e014
   80564:	e000e010 	.word	0xe000e010

00080568 <xPortStartScheduler>:
{
   80568:	b510      	push	{r4, lr}
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
   8056a:	4b09      	ldr	r3, [pc, #36]	; (80590 <xPortStartScheduler+0x28>)
   8056c:	681a      	ldr	r2, [r3, #0]
   8056e:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
   80572:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
   80574:	681a      	ldr	r2, [r3, #0]
   80576:	f042 4270 	orr.w	r2, r2, #4026531840	; 0xf0000000
   8057a:	601a      	str	r2, [r3, #0]
	vPortSetupTimerInterrupt();
   8057c:	4b05      	ldr	r3, [pc, #20]	; (80594 <xPortStartScheduler+0x2c>)
   8057e:	4798      	blx	r3
	uxCriticalNesting = 0;
   80580:	2400      	movs	r4, #0
   80582:	4b05      	ldr	r3, [pc, #20]	; (80598 <xPortStartScheduler+0x30>)
   80584:	601c      	str	r4, [r3, #0]
	prvPortStartFirstTask();
   80586:	4b05      	ldr	r3, [pc, #20]	; (8059c <xPortStartScheduler+0x34>)
   80588:	4798      	blx	r3
}
   8058a:	4620      	mov	r0, r4
   8058c:	bd10      	pop	{r4, pc}
   8058e:	bf00      	nop
   80590:	e000ed20 	.word	0xe000ed20
   80594:	0008053d 	.word	0x0008053d
   80598:	20000004 	.word	0x20000004
   8059c:	00080425 	.word	0x00080425

000805a0 <prvHeapInit>:
	/* This just exists to keep the linker quiet. */
}
/*-----------------------------------------------------------*/

static void prvHeapInit( void )
{
   805a0:	b410      	push	{r4}
	/* Ensure the start of the heap is aligned. */
	configASSERT( ( ( ( unsigned long ) xHeap.ucHeap ) & ( ( unsigned long ) portBYTE_ALIGNMENT_MASK ) ) == 0UL );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) xHeap.ucHeap;
   805a2:	4b0d      	ldr	r3, [pc, #52]	; (805d8 <prvHeapInit+0x38>)
   805a4:	f103 0208 	add.w	r2, r3, #8
   805a8:	601a      	str	r2, [r3, #0]
	xStart.xBlockSize = ( size_t ) 0;
   805aa:	2100      	movs	r1, #0
   805ac:	6059      	str	r1, [r3, #4]

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	pucHeapEnd = xHeap.ucHeap + xTotalHeapSize;
	pucHeapEnd -= heapSTRUCT_SIZE;
	pxEnd = ( void * ) pucHeapEnd;
   805ae:	f649 70f0 	movw	r0, #40944	; 0x9ff0
   805b2:	4402      	add	r2, r0
   805b4:	4c09      	ldr	r4, [pc, #36]	; (805dc <prvHeapInit+0x3c>)
   805b6:	f8c4 2750 	str.w	r2, [r4, #1872]	; 0x750
	configASSERT( ( ( ( unsigned long ) pxEnd ) & ( ( unsigned long ) portBYTE_ALIGNMENT_MASK ) ) == 0UL );
	pxEnd->xBlockSize = 0;
   805ba:	f649 74fc 	movw	r4, #40956	; 0x9ffc
   805be:	5119      	str	r1, [r3, r4]
	pxEnd->pxNextFreeBlock = NULL;
   805c0:	f649 74f8 	movw	r4, #40952	; 0x9ff8
   805c4:	5119      	str	r1, [r3, r4]

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) xHeap.ucHeap;
	pxFirstFreeBlock->xBlockSize = xTotalHeapSize - heapSTRUCT_SIZE;
   805c6:	60d8      	str	r0, [r3, #12]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
   805c8:	609a      	str	r2, [r3, #8]

	/* The heap now contains pxEnd. */
	xFreeBytesRemaining -= heapSTRUCT_SIZE;
   805ca:	4a05      	ldr	r2, [pc, #20]	; (805e0 <prvHeapInit+0x40>)
   805cc:	6813      	ldr	r3, [r2, #0]
   805ce:	3b10      	subs	r3, #16
   805d0:	6013      	str	r3, [r2, #0]
}
   805d2:	bc10      	pop	{r4}
   805d4:	4770      	bx	lr
   805d6:	bf00      	nop
   805d8:	20000460 	.word	0x20000460
   805dc:	20009d18 	.word	0x20009d18
   805e0:	20000008 	.word	0x20000008

000805e4 <prvInsertBlockIntoFreeList>:
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( xBlockLink *pxBlockToInsert )
{
   805e4:	b410      	push	{r4}
xBlockLink *pxIterator;
unsigned char *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
   805e6:	4a13      	ldr	r2, [pc, #76]	; (80634 <prvInsertBlockIntoFreeList+0x50>)
   805e8:	e000      	b.n	805ec <prvInsertBlockIntoFreeList+0x8>
   805ea:	461a      	mov	r2, r3
   805ec:	6813      	ldr	r3, [r2, #0]
   805ee:	4283      	cmp	r3, r0
   805f0:	d3fb      	bcc.n	805ea <prvInsertBlockIntoFreeList+0x6>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */	
	puc = ( unsigned char * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( unsigned char * ) pxBlockToInsert )
   805f2:	6851      	ldr	r1, [r2, #4]
   805f4:	1854      	adds	r4, r2, r1
   805f6:	42a0      	cmp	r0, r4
   805f8:	d009      	beq.n	8060e <prvInsertBlockIntoFreeList+0x2a>
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( unsigned char * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( unsigned char * ) pxIterator->pxNextFreeBlock )
   805fa:	6841      	ldr	r1, [r0, #4]
   805fc:	1844      	adds	r4, r0, r1
   805fe:	42a3      	cmp	r3, r4
   80600:	d00a      	beq.n	80618 <prvInsertBlockIntoFreeList+0x34>
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;		
   80602:	6003      	str	r3, [r0, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
   80604:	4290      	cmp	r0, r2
   80606:	d000      	beq.n	8060a <prvInsertBlockIntoFreeList+0x26>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
   80608:	6010      	str	r0, [r2, #0]
	}
}
   8060a:	bc10      	pop	{r4}
   8060c:	4770      	bx	lr
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
   8060e:	6840      	ldr	r0, [r0, #4]
   80610:	4401      	add	r1, r0
   80612:	6051      	str	r1, [r2, #4]
		pxBlockToInsert = pxIterator;
   80614:	4610      	mov	r0, r2
   80616:	e7f0      	b.n	805fa <prvInsertBlockIntoFreeList+0x16>
		if( pxIterator->pxNextFreeBlock != pxEnd )
   80618:	4c07      	ldr	r4, [pc, #28]	; (80638 <prvInsertBlockIntoFreeList+0x54>)
   8061a:	f8d4 4750 	ldr.w	r4, [r4, #1872]	; 0x750
   8061e:	42a3      	cmp	r3, r4
   80620:	d006      	beq.n	80630 <prvInsertBlockIntoFreeList+0x4c>
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
   80622:	685b      	ldr	r3, [r3, #4]
   80624:	4419      	add	r1, r3
   80626:	6041      	str	r1, [r0, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
   80628:	6813      	ldr	r3, [r2, #0]
   8062a:	681b      	ldr	r3, [r3, #0]
   8062c:	6003      	str	r3, [r0, #0]
   8062e:	e7e9      	b.n	80604 <prvInsertBlockIntoFreeList+0x20>
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
   80630:	6004      	str	r4, [r0, #0]
   80632:	e7e7      	b.n	80604 <prvInsertBlockIntoFreeList+0x20>
   80634:	20000460 	.word	0x20000460
   80638:	20009d18 	.word	0x20009d18

0008063c <pvPortMalloc>:
{
   8063c:	b570      	push	{r4, r5, r6, lr}
   8063e:	4605      	mov	r5, r0
	vTaskSuspendAll();
   80640:	4b22      	ldr	r3, [pc, #136]	; (806cc <pvPortMalloc+0x90>)
   80642:	4798      	blx	r3
		if( pxEnd == NULL )
   80644:	4b22      	ldr	r3, [pc, #136]	; (806d0 <pvPortMalloc+0x94>)
   80646:	f8d3 3750 	ldr.w	r3, [r3, #1872]	; 0x750
   8064a:	b17b      	cbz	r3, 8066c <pvPortMalloc+0x30>
		if( xWantedSize > 0 )
   8064c:	b135      	cbz	r5, 8065c <pvPortMalloc+0x20>
			xWantedSize += heapSTRUCT_SIZE;
   8064e:	3510      	adds	r5, #16
			if( xWantedSize & portBYTE_ALIGNMENT_MASK )
   80650:	f015 0f07 	tst.w	r5, #7
   80654:	d002      	beq.n	8065c <pvPortMalloc+0x20>
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
   80656:	f025 0507 	bic.w	r5, r5, #7
   8065a:	3508      	adds	r5, #8
		if( ( xWantedSize > 0 ) && ( xWantedSize < xTotalHeapSize ) )
   8065c:	1e6a      	subs	r2, r5, #1
   8065e:	f649 73fe 	movw	r3, #40958	; 0x9ffe
   80662:	429a      	cmp	r2, r3
   80664:	d82a      	bhi.n	806bc <pvPortMalloc+0x80>
			pxBlock = xStart.pxNextFreeBlock;
   80666:	4a1b      	ldr	r2, [pc, #108]	; (806d4 <pvPortMalloc+0x98>)
   80668:	6814      	ldr	r4, [r2, #0]
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
   8066a:	e004      	b.n	80676 <pvPortMalloc+0x3a>
			prvHeapInit();
   8066c:	4b1a      	ldr	r3, [pc, #104]	; (806d8 <pvPortMalloc+0x9c>)
   8066e:	4798      	blx	r3
   80670:	e7ec      	b.n	8064c <pvPortMalloc+0x10>
				pxPreviousBlock = pxBlock;
   80672:	4622      	mov	r2, r4
				pxBlock = pxBlock->pxNextFreeBlock;
   80674:	461c      	mov	r4, r3
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
   80676:	6863      	ldr	r3, [r4, #4]
   80678:	429d      	cmp	r5, r3
   8067a:	d902      	bls.n	80682 <pvPortMalloc+0x46>
   8067c:	6823      	ldr	r3, [r4, #0]
   8067e:	2b00      	cmp	r3, #0
   80680:	d1f7      	bne.n	80672 <pvPortMalloc+0x36>
			if( pxBlock != pxEnd )
   80682:	4b13      	ldr	r3, [pc, #76]	; (806d0 <pvPortMalloc+0x94>)
   80684:	f8d3 3750 	ldr.w	r3, [r3, #1872]	; 0x750
   80688:	429c      	cmp	r4, r3
   8068a:	d019      	beq.n	806c0 <pvPortMalloc+0x84>
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
   8068c:	6816      	ldr	r6, [r2, #0]
   8068e:	3610      	adds	r6, #16
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
   80690:	6823      	ldr	r3, [r4, #0]
   80692:	6013      	str	r3, [r2, #0]
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
   80694:	6863      	ldr	r3, [r4, #4]
   80696:	1b5b      	subs	r3, r3, r5
   80698:	2b20      	cmp	r3, #32
   8069a:	d809      	bhi.n	806b0 <pvPortMalloc+0x74>
				xFreeBytesRemaining -= pxBlock->xBlockSize;
   8069c:	6861      	ldr	r1, [r4, #4]
   8069e:	4a0f      	ldr	r2, [pc, #60]	; (806dc <pvPortMalloc+0xa0>)
   806a0:	6813      	ldr	r3, [r2, #0]
   806a2:	1a5b      	subs	r3, r3, r1
   806a4:	6013      	str	r3, [r2, #0]
	xTaskResumeAll();
   806a6:	4b0e      	ldr	r3, [pc, #56]	; (806e0 <pvPortMalloc+0xa4>)
   806a8:	4798      	blx	r3
		if( pvReturn == NULL )
   806aa:	b15e      	cbz	r6, 806c4 <pvPortMalloc+0x88>
}
   806ac:	4630      	mov	r0, r6
   806ae:	bd70      	pop	{r4, r5, r6, pc}
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
   806b0:	1960      	adds	r0, r4, r5
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
   806b2:	6043      	str	r3, [r0, #4]
					pxBlock->xBlockSize = xWantedSize;
   806b4:	6065      	str	r5, [r4, #4]
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
   806b6:	4b0b      	ldr	r3, [pc, #44]	; (806e4 <pvPortMalloc+0xa8>)
   806b8:	4798      	blx	r3
   806ba:	e7ef      	b.n	8069c <pvPortMalloc+0x60>
void *pvReturn = NULL;
   806bc:	2600      	movs	r6, #0
   806be:	e7f2      	b.n	806a6 <pvPortMalloc+0x6a>
   806c0:	2600      	movs	r6, #0
   806c2:	e7f0      	b.n	806a6 <pvPortMalloc+0x6a>
			vApplicationMallocFailedHook();
   806c4:	4b08      	ldr	r3, [pc, #32]	; (806e8 <pvPortMalloc+0xac>)
   806c6:	4798      	blx	r3
	return pvReturn;
   806c8:	e7f0      	b.n	806ac <pvPortMalloc+0x70>
   806ca:	bf00      	nop
   806cc:	00080fe9 	.word	0x00080fe9
   806d0:	20009d18 	.word	0x20009d18
   806d4:	20000460 	.word	0x20000460
   806d8:	000805a1 	.word	0x000805a1
   806dc:	20000008 	.word	0x20000008
   806e0:	00081125 	.word	0x00081125
   806e4:	000805e5 	.word	0x000805e5
   806e8:	00081c45 	.word	0x00081c45

000806ec <vPortFree>:
	if( pv != NULL )
   806ec:	b188      	cbz	r0, 80712 <vPortFree+0x26>
{
   806ee:	b538      	push	{r3, r4, r5, lr}
   806f0:	4604      	mov	r4, r0
		puc -= heapSTRUCT_SIZE;
   806f2:	f1a0 0510 	sub.w	r5, r0, #16
		vTaskSuspendAll();
   806f6:	4b07      	ldr	r3, [pc, #28]	; (80714 <vPortFree+0x28>)
   806f8:	4798      	blx	r3
			xFreeBytesRemaining += pxLink->xBlockSize;
   806fa:	f854 1c0c 	ldr.w	r1, [r4, #-12]
   806fe:	4a06      	ldr	r2, [pc, #24]	; (80718 <vPortFree+0x2c>)
   80700:	6813      	ldr	r3, [r2, #0]
   80702:	440b      	add	r3, r1
   80704:	6013      	str	r3, [r2, #0]
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );			
   80706:	4628      	mov	r0, r5
   80708:	4b04      	ldr	r3, [pc, #16]	; (8071c <vPortFree+0x30>)
   8070a:	4798      	blx	r3
		xTaskResumeAll();
   8070c:	4b04      	ldr	r3, [pc, #16]	; (80720 <vPortFree+0x34>)
   8070e:	4798      	blx	r3
   80710:	bd38      	pop	{r3, r4, r5, pc}
   80712:	4770      	bx	lr
   80714:	00080fe9 	.word	0x00080fe9
   80718:	20000008 	.word	0x20000008
   8071c:	000805e5 	.word	0x000805e5
   80720:	00081125 	.word	0x00081125

00080724 <prvIsQueueFull>:
	return xReturn;
}
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
   80724:	b538      	push	{r3, r4, r5, lr}
   80726:	4605      	mov	r5, r0
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
   80728:	4b05      	ldr	r3, [pc, #20]	; (80740 <prvIsQueueFull+0x1c>)
   8072a:	4798      	blx	r3
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
   8072c:	6bac      	ldr	r4, [r5, #56]	; 0x38
   8072e:	6beb      	ldr	r3, [r5, #60]	; 0x3c
   80730:	429c      	cmp	r4, r3
   80732:	bf14      	ite	ne
   80734:	2400      	movne	r4, #0
   80736:	2401      	moveq	r4, #1
	taskEXIT_CRITICAL();
   80738:	4b02      	ldr	r3, [pc, #8]	; (80744 <prvIsQueueFull+0x20>)
   8073a:	4798      	blx	r3

	return xReturn;
}
   8073c:	4620      	mov	r0, r4
   8073e:	bd38      	pop	{r3, r4, r5, pc}
   80740:	00080495 	.word	0x00080495
   80744:	000804b5 	.word	0x000804b5

00080748 <prvIsQueueEmpty>:
{
   80748:	b510      	push	{r4, lr}
   8074a:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
   8074c:	4b04      	ldr	r3, [pc, #16]	; (80760 <prvIsQueueEmpty+0x18>)
   8074e:	4798      	blx	r3
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
   80750:	6ba4      	ldr	r4, [r4, #56]	; 0x38
   80752:	fab4 f484 	clz	r4, r4
   80756:	0964      	lsrs	r4, r4, #5
	taskEXIT_CRITICAL();
   80758:	4b02      	ldr	r3, [pc, #8]	; (80764 <prvIsQueueEmpty+0x1c>)
   8075a:	4798      	blx	r3
}
   8075c:	4620      	mov	r0, r4
   8075e:	bd10      	pop	{r4, pc}
   80760:	00080495 	.word	0x00080495
   80764:	000804b5 	.word	0x000804b5

00080768 <prvCopyDataToQueue>:
{
   80768:	b510      	push	{r4, lr}
   8076a:	4604      	mov	r4, r0
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
   8076c:	6c03      	ldr	r3, [r0, #64]	; 0x40
   8076e:	b95b      	cbnz	r3, 80788 <prvCopyDataToQueue+0x20>
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   80770:	6803      	ldr	r3, [r0, #0]
   80772:	b11b      	cbz	r3, 8077c <prvCopyDataToQueue+0x14>
	++( pxQueue->uxMessagesWaiting );
   80774:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   80776:	3301      	adds	r3, #1
   80778:	63a3      	str	r3, [r4, #56]	; 0x38
   8077a:	bd10      	pop	{r4, pc}
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
   8077c:	6840      	ldr	r0, [r0, #4]
   8077e:	4b12      	ldr	r3, [pc, #72]	; (807c8 <prvCopyDataToQueue+0x60>)
   80780:	4798      	blx	r3
				pxQueue->pxMutexHolder = NULL;
   80782:	2300      	movs	r3, #0
   80784:	6063      	str	r3, [r4, #4]
   80786:	e7f5      	b.n	80774 <prvCopyDataToQueue+0xc>
	else if( xPosition == queueSEND_TO_BACK )
   80788:	b96a      	cbnz	r2, 807a6 <prvCopyDataToQueue+0x3e>
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
   8078a:	461a      	mov	r2, r3
   8078c:	6880      	ldr	r0, [r0, #8]
   8078e:	4b0f      	ldr	r3, [pc, #60]	; (807cc <prvCopyDataToQueue+0x64>)
   80790:	4798      	blx	r3
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
   80792:	6c22      	ldr	r2, [r4, #64]	; 0x40
   80794:	68a3      	ldr	r3, [r4, #8]
   80796:	4413      	add	r3, r2
   80798:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
   8079a:	6862      	ldr	r2, [r4, #4]
   8079c:	4293      	cmp	r3, r2
   8079e:	d3e9      	bcc.n	80774 <prvCopyDataToQueue+0xc>
			pxQueue->pcWriteTo = pxQueue->pcHead;
   807a0:	6823      	ldr	r3, [r4, #0]
   807a2:	60a3      	str	r3, [r4, #8]
   807a4:	e7e6      	b.n	80774 <prvCopyDataToQueue+0xc>
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
   807a6:	461a      	mov	r2, r3
   807a8:	68c0      	ldr	r0, [r0, #12]
   807aa:	4b08      	ldr	r3, [pc, #32]	; (807cc <prvCopyDataToQueue+0x64>)
   807ac:	4798      	blx	r3
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
   807ae:	6c22      	ldr	r2, [r4, #64]	; 0x40
   807b0:	4252      	negs	r2, r2
   807b2:	68e3      	ldr	r3, [r4, #12]
   807b4:	4413      	add	r3, r2
   807b6:	60e3      	str	r3, [r4, #12]
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
   807b8:	6821      	ldr	r1, [r4, #0]
   807ba:	428b      	cmp	r3, r1
   807bc:	d2da      	bcs.n	80774 <prvCopyDataToQueue+0xc>
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
   807be:	6863      	ldr	r3, [r4, #4]
   807c0:	441a      	add	r2, r3
   807c2:	60e2      	str	r2, [r4, #12]
   807c4:	e7d6      	b.n	80774 <prvCopyDataToQueue+0xc>
   807c6:	bf00      	nop
   807c8:	00081661 	.word	0x00081661
   807cc:	00082275 	.word	0x00082275

000807d0 <prvCopyDataFromQueue>:
{
   807d0:	b538      	push	{r3, r4, r5, lr}
   807d2:	4603      	mov	r3, r0
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
   807d4:	6800      	ldr	r0, [r0, #0]
   807d6:	b158      	cbz	r0, 807f0 <prvCopyDataFromQueue+0x20>
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
   807d8:	6c1a      	ldr	r2, [r3, #64]	; 0x40
   807da:	68dc      	ldr	r4, [r3, #12]
   807dc:	4414      	add	r4, r2
   807de:	60dc      	str	r4, [r3, #12]
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
   807e0:	685d      	ldr	r5, [r3, #4]
   807e2:	42ac      	cmp	r4, r5
   807e4:	d300      	bcc.n	807e8 <prvCopyDataFromQueue+0x18>
			pxQueue->pcReadFrom = pxQueue->pcHead;
   807e6:	60d8      	str	r0, [r3, #12]
   807e8:	4608      	mov	r0, r1
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
   807ea:	68d9      	ldr	r1, [r3, #12]
   807ec:	4b01      	ldr	r3, [pc, #4]	; (807f4 <prvCopyDataFromQueue+0x24>)
   807ee:	4798      	blx	r3
   807f0:	bd38      	pop	{r3, r4, r5, pc}
   807f2:	bf00      	nop
   807f4:	00082275 	.word	0x00082275

000807f8 <prvUnlockQueue>:
{
   807f8:	b510      	push	{r4, lr}
   807fa:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
   807fc:	4b19      	ldr	r3, [pc, #100]	; (80864 <prvUnlockQueue+0x6c>)
   807fe:	4798      	blx	r3
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
   80800:	e002      	b.n	80808 <prvUnlockQueue+0x10>
				--( pxQueue->xTxLock );
   80802:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   80804:	3b01      	subs	r3, #1
   80806:	64a3      	str	r3, [r4, #72]	; 0x48
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
   80808:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   8080a:	2b00      	cmp	r3, #0
   8080c:	dd0a      	ble.n	80824 <prvUnlockQueue+0x2c>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   8080e:	6a63      	ldr	r3, [r4, #36]	; 0x24
   80810:	b143      	cbz	r3, 80824 <prvUnlockQueue+0x2c>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   80812:	f104 0024 	add.w	r0, r4, #36	; 0x24
   80816:	4b14      	ldr	r3, [pc, #80]	; (80868 <prvUnlockQueue+0x70>)
   80818:	4798      	blx	r3
   8081a:	2800      	cmp	r0, #0
   8081c:	d0f1      	beq.n	80802 <prvUnlockQueue+0xa>
					vTaskMissedYield();
   8081e:	4b13      	ldr	r3, [pc, #76]	; (8086c <prvUnlockQueue+0x74>)
   80820:	4798      	blx	r3
   80822:	e7ee      	b.n	80802 <prvUnlockQueue+0xa>
		pxQueue->xTxLock = queueUNLOCKED;
   80824:	f04f 33ff 	mov.w	r3, #4294967295
   80828:	64a3      	str	r3, [r4, #72]	; 0x48
	taskEXIT_CRITICAL();
   8082a:	4b11      	ldr	r3, [pc, #68]	; (80870 <prvUnlockQueue+0x78>)
   8082c:	4798      	blx	r3
	taskENTER_CRITICAL();
   8082e:	4b0d      	ldr	r3, [pc, #52]	; (80864 <prvUnlockQueue+0x6c>)
   80830:	4798      	blx	r3
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
   80832:	e002      	b.n	8083a <prvUnlockQueue+0x42>
				--( pxQueue->xRxLock );
   80834:	6c63      	ldr	r3, [r4, #68]	; 0x44
   80836:	3b01      	subs	r3, #1
   80838:	6463      	str	r3, [r4, #68]	; 0x44
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
   8083a:	6c63      	ldr	r3, [r4, #68]	; 0x44
   8083c:	2b00      	cmp	r3, #0
   8083e:	dd0a      	ble.n	80856 <prvUnlockQueue+0x5e>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   80840:	6923      	ldr	r3, [r4, #16]
   80842:	b143      	cbz	r3, 80856 <prvUnlockQueue+0x5e>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   80844:	f104 0010 	add.w	r0, r4, #16
   80848:	4b07      	ldr	r3, [pc, #28]	; (80868 <prvUnlockQueue+0x70>)
   8084a:	4798      	blx	r3
   8084c:	2800      	cmp	r0, #0
   8084e:	d0f1      	beq.n	80834 <prvUnlockQueue+0x3c>
					vTaskMissedYield();
   80850:	4b06      	ldr	r3, [pc, #24]	; (8086c <prvUnlockQueue+0x74>)
   80852:	4798      	blx	r3
   80854:	e7ee      	b.n	80834 <prvUnlockQueue+0x3c>
		pxQueue->xRxLock = queueUNLOCKED;
   80856:	f04f 33ff 	mov.w	r3, #4294967295
   8085a:	6463      	str	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();
   8085c:	4b04      	ldr	r3, [pc, #16]	; (80870 <prvUnlockQueue+0x78>)
   8085e:	4798      	blx	r3
   80860:	bd10      	pop	{r4, pc}
   80862:	bf00      	nop
   80864:	00080495 	.word	0x00080495
   80868:	00081479 	.word	0x00081479
   8086c:	000815a5 	.word	0x000815a5
   80870:	000804b5 	.word	0x000804b5

00080874 <xQueueGenericReset>:
{
   80874:	b538      	push	{r3, r4, r5, lr}
	configASSERT( pxQueue );
   80876:	b308      	cbz	r0, 808bc <xQueueGenericReset+0x48>
   80878:	460d      	mov	r5, r1
   8087a:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
   8087c:	4b17      	ldr	r3, [pc, #92]	; (808dc <xQueueGenericReset+0x68>)
   8087e:	4798      	blx	r3
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
   80880:	6821      	ldr	r1, [r4, #0]
   80882:	6be2      	ldr	r2, [r4, #60]	; 0x3c
   80884:	6c23      	ldr	r3, [r4, #64]	; 0x40
   80886:	fb03 1002 	mla	r0, r3, r2, r1
   8088a:	6060      	str	r0, [r4, #4]
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
   8088c:	2000      	movs	r0, #0
   8088e:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
   80890:	60a1      	str	r1, [r4, #8]
		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
   80892:	3a01      	subs	r2, #1
   80894:	fb02 1303 	mla	r3, r2, r3, r1
   80898:	60e3      	str	r3, [r4, #12]
		pxQueue->xRxLock = queueUNLOCKED;
   8089a:	f04f 33ff 	mov.w	r3, #4294967295
   8089e:	6463      	str	r3, [r4, #68]	; 0x44
		pxQueue->xTxLock = queueUNLOCKED;
   808a0:	64a3      	str	r3, [r4, #72]	; 0x48
		if( xNewQueue == pdFALSE )
   808a2:	b995      	cbnz	r5, 808ca <xQueueGenericReset+0x56>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   808a4:	6923      	ldr	r3, [r4, #16]
   808a6:	b12b      	cbz	r3, 808b4 <xQueueGenericReset+0x40>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
   808a8:	f104 0010 	add.w	r0, r4, #16
   808ac:	4b0c      	ldr	r3, [pc, #48]	; (808e0 <xQueueGenericReset+0x6c>)
   808ae:	4798      	blx	r3
   808b0:	2801      	cmp	r0, #1
   808b2:	d007      	beq.n	808c4 <xQueueGenericReset+0x50>
	taskEXIT_CRITICAL();
   808b4:	4b0b      	ldr	r3, [pc, #44]	; (808e4 <xQueueGenericReset+0x70>)
   808b6:	4798      	blx	r3
}
   808b8:	2001      	movs	r0, #1
   808ba:	bd38      	pop	{r3, r4, r5, pc}
	configASSERT( pxQueue );
   808bc:	4b0a      	ldr	r3, [pc, #40]	; (808e8 <xQueueGenericReset+0x74>)
   808be:	4798      	blx	r3
   808c0:	bf00      	nop
   808c2:	e7fd      	b.n	808c0 <xQueueGenericReset+0x4c>
					portYIELD_WITHIN_API();
   808c4:	4b09      	ldr	r3, [pc, #36]	; (808ec <xQueueGenericReset+0x78>)
   808c6:	4798      	blx	r3
   808c8:	e7f4      	b.n	808b4 <xQueueGenericReset+0x40>
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
   808ca:	f104 0010 	add.w	r0, r4, #16
   808ce:	4d08      	ldr	r5, [pc, #32]	; (808f0 <xQueueGenericReset+0x7c>)
   808d0:	47a8      	blx	r5
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
   808d2:	f104 0024 	add.w	r0, r4, #36	; 0x24
   808d6:	47a8      	blx	r5
   808d8:	e7ec      	b.n	808b4 <xQueueGenericReset+0x40>
   808da:	bf00      	nop
   808dc:	00080495 	.word	0x00080495
   808e0:	00081479 	.word	0x00081479
   808e4:	000804b5 	.word	0x000804b5
   808e8:	00080485 	.word	0x00080485
   808ec:	00080475 	.word	0x00080475
   808f0:	00080391 	.word	0x00080391

000808f4 <xQueueGenericCreate>:
{
   808f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
   808f6:	b1f0      	cbz	r0, 80936 <xQueueGenericCreate+0x42>
   808f8:	460d      	mov	r5, r1
   808fa:	4617      	mov	r7, r2
   808fc:	4606      	mov	r6, r0
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
   808fe:	2050      	movs	r0, #80	; 0x50
   80900:	4b11      	ldr	r3, [pc, #68]	; (80948 <xQueueGenericCreate+0x54>)
   80902:	4798      	blx	r3
		if( pxNewQueue != NULL )
   80904:	4604      	mov	r4, r0
   80906:	b1c0      	cbz	r0, 8093a <xQueueGenericCreate+0x46>
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
   80908:	fb05 f006 	mul.w	r0, r5, r6
			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
   8090c:	3001      	adds	r0, #1
   8090e:	4b0e      	ldr	r3, [pc, #56]	; (80948 <xQueueGenericCreate+0x54>)
   80910:	4798      	blx	r3
   80912:	6020      	str	r0, [r4, #0]
			if( pxNewQueue->pcHead != NULL )
   80914:	b150      	cbz	r0, 8092c <xQueueGenericCreate+0x38>
				pxNewQueue->uxLength = uxQueueLength;
   80916:	63e6      	str	r6, [r4, #60]	; 0x3c
				pxNewQueue->uxItemSize = uxItemSize;
   80918:	6425      	str	r5, [r4, #64]	; 0x40
				xQueueGenericReset( pxNewQueue, pdTRUE );
   8091a:	2101      	movs	r1, #1
   8091c:	4620      	mov	r0, r4
   8091e:	4b0b      	ldr	r3, [pc, #44]	; (8094c <xQueueGenericCreate+0x58>)
   80920:	4798      	blx	r3
					pxNewQueue->ucQueueType = ucQueueType;
   80922:	f884 704d 	strb.w	r7, [r4, #77]	; 0x4d
	configASSERT( xReturn );
   80926:	b154      	cbz	r4, 8093e <xQueueGenericCreate+0x4a>
}
   80928:	4620      	mov	r0, r4
   8092a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				vPortFree( pxNewQueue );
   8092c:	4620      	mov	r0, r4
   8092e:	4b08      	ldr	r3, [pc, #32]	; (80950 <xQueueGenericCreate+0x5c>)
   80930:	4798      	blx	r3
xQueueHandle xReturn = NULL;
   80932:	2400      	movs	r4, #0
   80934:	e7f7      	b.n	80926 <xQueueGenericCreate+0x32>
   80936:	2400      	movs	r4, #0
   80938:	e7f5      	b.n	80926 <xQueueGenericCreate+0x32>
   8093a:	2400      	movs	r4, #0
   8093c:	e7f3      	b.n	80926 <xQueueGenericCreate+0x32>
	configASSERT( xReturn );
   8093e:	4b05      	ldr	r3, [pc, #20]	; (80954 <xQueueGenericCreate+0x60>)
   80940:	4798      	blx	r3
   80942:	bf00      	nop
   80944:	e7fd      	b.n	80942 <xQueueGenericCreate+0x4e>
   80946:	bf00      	nop
   80948:	0008063d 	.word	0x0008063d
   8094c:	00080875 	.word	0x00080875
   80950:	000806ed 	.word	0x000806ed
   80954:	00080485 	.word	0x00080485

00080958 <xQueueGenericSend>:
{
   80958:	b5f0      	push	{r4, r5, r6, r7, lr}
   8095a:	b085      	sub	sp, #20
   8095c:	9201      	str	r2, [sp, #4]
	configASSERT( pxQueue );
   8095e:	b138      	cbz	r0, 80970 <xQueueGenericSend+0x18>
   80960:	460e      	mov	r6, r1
   80962:	461f      	mov	r7, r3
   80964:	4604      	mov	r4, r0
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
   80966:	b139      	cbz	r1, 80978 <xQueueGenericSend+0x20>
   80968:	2301      	movs	r3, #1
   8096a:	b15b      	cbz	r3, 80984 <xQueueGenericSend+0x2c>
   8096c:	2500      	movs	r5, #0
   8096e:	e036      	b.n	809de <xQueueGenericSend+0x86>
	configASSERT( pxQueue );
   80970:	4b38      	ldr	r3, [pc, #224]	; (80a54 <xQueueGenericSend+0xfc>)
   80972:	4798      	blx	r3
   80974:	bf00      	nop
   80976:	e7fd      	b.n	80974 <xQueueGenericSend+0x1c>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
   80978:	6c03      	ldr	r3, [r0, #64]	; 0x40
   8097a:	b90b      	cbnz	r3, 80980 <xQueueGenericSend+0x28>
   8097c:	2301      	movs	r3, #1
   8097e:	e7f4      	b.n	8096a <xQueueGenericSend+0x12>
   80980:	2300      	movs	r3, #0
   80982:	e7f2      	b.n	8096a <xQueueGenericSend+0x12>
   80984:	4b33      	ldr	r3, [pc, #204]	; (80a54 <xQueueGenericSend+0xfc>)
   80986:	4798      	blx	r3
   80988:	bf00      	nop
   8098a:	e7fd      	b.n	80988 <xQueueGenericSend+0x30>
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
   8098c:	463a      	mov	r2, r7
   8098e:	4631      	mov	r1, r6
   80990:	4620      	mov	r0, r4
   80992:	4b31      	ldr	r3, [pc, #196]	; (80a58 <xQueueGenericSend+0x100>)
   80994:	4798      	blx	r3
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   80996:	6a63      	ldr	r3, [r4, #36]	; 0x24
   80998:	b923      	cbnz	r3, 809a4 <xQueueGenericSend+0x4c>
				taskEXIT_CRITICAL();
   8099a:	4b30      	ldr	r3, [pc, #192]	; (80a5c <xQueueGenericSend+0x104>)
   8099c:	4798      	blx	r3
				return pdPASS;
   8099e:	2001      	movs	r0, #1
}
   809a0:	b005      	add	sp, #20
   809a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
   809a4:	f104 0024 	add.w	r0, r4, #36	; 0x24
   809a8:	4b2d      	ldr	r3, [pc, #180]	; (80a60 <xQueueGenericSend+0x108>)
   809aa:	4798      	blx	r3
   809ac:	2801      	cmp	r0, #1
   809ae:	d1f4      	bne.n	8099a <xQueueGenericSend+0x42>
						portYIELD_WITHIN_API();
   809b0:	4b2c      	ldr	r3, [pc, #176]	; (80a64 <xQueueGenericSend+0x10c>)
   809b2:	4798      	blx	r3
   809b4:	e7f1      	b.n	8099a <xQueueGenericSend+0x42>
					taskEXIT_CRITICAL();
   809b6:	4b29      	ldr	r3, [pc, #164]	; (80a5c <xQueueGenericSend+0x104>)
   809b8:	4798      	blx	r3
					return errQUEUE_FULL;
   809ba:	2000      	movs	r0, #0
   809bc:	e7f0      	b.n	809a0 <xQueueGenericSend+0x48>
					vTaskSetTimeOutState( &xTimeOut );
   809be:	a802      	add	r0, sp, #8
   809c0:	4b29      	ldr	r3, [pc, #164]	; (80a68 <xQueueGenericSend+0x110>)
   809c2:	4798      	blx	r3
					xEntryTimeSet = pdTRUE;
   809c4:	2501      	movs	r5, #1
   809c6:	e015      	b.n	809f4 <xQueueGenericSend+0x9c>
		prvLockQueue( pxQueue );
   809c8:	2300      	movs	r3, #0
   809ca:	6463      	str	r3, [r4, #68]	; 0x44
   809cc:	e01c      	b.n	80a08 <xQueueGenericSend+0xb0>
   809ce:	2300      	movs	r3, #0
   809d0:	64a3      	str	r3, [r4, #72]	; 0x48
   809d2:	e01d      	b.n	80a10 <xQueueGenericSend+0xb8>
				prvUnlockQueue( pxQueue );
   809d4:	4620      	mov	r0, r4
   809d6:	4b25      	ldr	r3, [pc, #148]	; (80a6c <xQueueGenericSend+0x114>)
   809d8:	4798      	blx	r3
				( void ) xTaskResumeAll();
   809da:	4b25      	ldr	r3, [pc, #148]	; (80a70 <xQueueGenericSend+0x118>)
   809dc:	4798      	blx	r3
		taskENTER_CRITICAL();
   809de:	4b25      	ldr	r3, [pc, #148]	; (80a74 <xQueueGenericSend+0x11c>)
   809e0:	4798      	blx	r3
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
   809e2:	6ba2      	ldr	r2, [r4, #56]	; 0x38
   809e4:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   809e6:	429a      	cmp	r2, r3
   809e8:	d3d0      	bcc.n	8098c <xQueueGenericSend+0x34>
				if( xTicksToWait == ( portTickType ) 0 )
   809ea:	9b01      	ldr	r3, [sp, #4]
   809ec:	2b00      	cmp	r3, #0
   809ee:	d0e2      	beq.n	809b6 <xQueueGenericSend+0x5e>
				else if( xEntryTimeSet == pdFALSE )
   809f0:	2d00      	cmp	r5, #0
   809f2:	d0e4      	beq.n	809be <xQueueGenericSend+0x66>
		taskEXIT_CRITICAL();
   809f4:	4b19      	ldr	r3, [pc, #100]	; (80a5c <xQueueGenericSend+0x104>)
   809f6:	4798      	blx	r3
		vTaskSuspendAll();
   809f8:	4b1f      	ldr	r3, [pc, #124]	; (80a78 <xQueueGenericSend+0x120>)
   809fa:	4798      	blx	r3
		prvLockQueue( pxQueue );
   809fc:	4b1d      	ldr	r3, [pc, #116]	; (80a74 <xQueueGenericSend+0x11c>)
   809fe:	4798      	blx	r3
   80a00:	6c63      	ldr	r3, [r4, #68]	; 0x44
   80a02:	f1b3 3fff 	cmp.w	r3, #4294967295
   80a06:	d0df      	beq.n	809c8 <xQueueGenericSend+0x70>
   80a08:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   80a0a:	f1b3 3fff 	cmp.w	r3, #4294967295
   80a0e:	d0de      	beq.n	809ce <xQueueGenericSend+0x76>
   80a10:	4b12      	ldr	r3, [pc, #72]	; (80a5c <xQueueGenericSend+0x104>)
   80a12:	4798      	blx	r3
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   80a14:	a901      	add	r1, sp, #4
   80a16:	a802      	add	r0, sp, #8
   80a18:	4b18      	ldr	r3, [pc, #96]	; (80a7c <xQueueGenericSend+0x124>)
   80a1a:	4798      	blx	r3
   80a1c:	b998      	cbnz	r0, 80a46 <xQueueGenericSend+0xee>
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
   80a1e:	4620      	mov	r0, r4
   80a20:	4b17      	ldr	r3, [pc, #92]	; (80a80 <xQueueGenericSend+0x128>)
   80a22:	4798      	blx	r3
   80a24:	2800      	cmp	r0, #0
   80a26:	d0d5      	beq.n	809d4 <xQueueGenericSend+0x7c>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
   80a28:	9901      	ldr	r1, [sp, #4]
   80a2a:	f104 0010 	add.w	r0, r4, #16
   80a2e:	4b15      	ldr	r3, [pc, #84]	; (80a84 <xQueueGenericSend+0x12c>)
   80a30:	4798      	blx	r3
				prvUnlockQueue( pxQueue );
   80a32:	4620      	mov	r0, r4
   80a34:	4b0d      	ldr	r3, [pc, #52]	; (80a6c <xQueueGenericSend+0x114>)
   80a36:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
   80a38:	4b0d      	ldr	r3, [pc, #52]	; (80a70 <xQueueGenericSend+0x118>)
   80a3a:	4798      	blx	r3
   80a3c:	2800      	cmp	r0, #0
   80a3e:	d1ce      	bne.n	809de <xQueueGenericSend+0x86>
					portYIELD_WITHIN_API();
   80a40:	4b08      	ldr	r3, [pc, #32]	; (80a64 <xQueueGenericSend+0x10c>)
   80a42:	4798      	blx	r3
   80a44:	e7cb      	b.n	809de <xQueueGenericSend+0x86>
			prvUnlockQueue( pxQueue );
   80a46:	4620      	mov	r0, r4
   80a48:	4b08      	ldr	r3, [pc, #32]	; (80a6c <xQueueGenericSend+0x114>)
   80a4a:	4798      	blx	r3
			( void ) xTaskResumeAll();
   80a4c:	4b08      	ldr	r3, [pc, #32]	; (80a70 <xQueueGenericSend+0x118>)
   80a4e:	4798      	blx	r3
			return errQUEUE_FULL;
   80a50:	2000      	movs	r0, #0
   80a52:	e7a5      	b.n	809a0 <xQueueGenericSend+0x48>
   80a54:	00080485 	.word	0x00080485
   80a58:	00080769 	.word	0x00080769
   80a5c:	000804b5 	.word	0x000804b5
   80a60:	00081479 	.word	0x00081479
   80a64:	00080475 	.word	0x00080475
   80a68:	000814f9 	.word	0x000814f9
   80a6c:	000807f9 	.word	0x000807f9
   80a70:	00081125 	.word	0x00081125
   80a74:	00080495 	.word	0x00080495
   80a78:	00080fe9 	.word	0x00080fe9
   80a7c:	0008151d 	.word	0x0008151d
   80a80:	00080725 	.word	0x00080725
   80a84:	000813d5 	.word	0x000813d5

00080a88 <xQueueGenericSendFromISR>:
{
   80a88:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	configASSERT( pxQueue );
   80a8c:	b150      	cbz	r0, 80aa4 <xQueueGenericSendFromISR+0x1c>
   80a8e:	460e      	mov	r6, r1
   80a90:	4615      	mov	r5, r2
   80a92:	4698      	mov	r8, r3
   80a94:	4604      	mov	r4, r0
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
   80a96:	b149      	cbz	r1, 80aac <xQueueGenericSendFromISR+0x24>
   80a98:	2301      	movs	r3, #1
   80a9a:	b96b      	cbnz	r3, 80ab8 <xQueueGenericSendFromISR+0x30>
   80a9c:	4b1d      	ldr	r3, [pc, #116]	; (80b14 <xQueueGenericSendFromISR+0x8c>)
   80a9e:	4798      	blx	r3
   80aa0:	bf00      	nop
   80aa2:	e7fd      	b.n	80aa0 <xQueueGenericSendFromISR+0x18>
	configASSERT( pxQueue );
   80aa4:	4b1b      	ldr	r3, [pc, #108]	; (80b14 <xQueueGenericSendFromISR+0x8c>)
   80aa6:	4798      	blx	r3
   80aa8:	bf00      	nop
   80aaa:	e7fd      	b.n	80aa8 <xQueueGenericSendFromISR+0x20>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
   80aac:	6c03      	ldr	r3, [r0, #64]	; 0x40
   80aae:	b90b      	cbnz	r3, 80ab4 <xQueueGenericSendFromISR+0x2c>
   80ab0:	2301      	movs	r3, #1
   80ab2:	e7f2      	b.n	80a9a <xQueueGenericSendFromISR+0x12>
   80ab4:	2300      	movs	r3, #0
   80ab6:	e7f0      	b.n	80a9a <xQueueGenericSendFromISR+0x12>
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   80ab8:	4b16      	ldr	r3, [pc, #88]	; (80b14 <xQueueGenericSendFromISR+0x8c>)
   80aba:	4798      	blx	r3
   80abc:	4607      	mov	r7, r0
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
   80abe:	6ba2      	ldr	r2, [r4, #56]	; 0x38
   80ac0:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   80ac2:	429a      	cmp	r2, r3
   80ac4:	d306      	bcc.n	80ad4 <xQueueGenericSendFromISR+0x4c>
			xReturn = errQUEUE_FULL;
   80ac6:	2400      	movs	r4, #0
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   80ac8:	4638      	mov	r0, r7
   80aca:	4b13      	ldr	r3, [pc, #76]	; (80b18 <xQueueGenericSendFromISR+0x90>)
   80acc:	4798      	blx	r3
}
   80ace:	4620      	mov	r0, r4
   80ad0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
   80ad4:	4642      	mov	r2, r8
   80ad6:	4631      	mov	r1, r6
   80ad8:	4620      	mov	r0, r4
   80ada:	4b10      	ldr	r3, [pc, #64]	; (80b1c <xQueueGenericSendFromISR+0x94>)
   80adc:	4798      	blx	r3
			if( pxQueue->xTxLock == queueUNLOCKED )
   80ade:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   80ae0:	f1b3 3fff 	cmp.w	r3, #4294967295
   80ae4:	d10a      	bne.n	80afc <xQueueGenericSendFromISR+0x74>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   80ae6:	6a63      	ldr	r3, [r4, #36]	; 0x24
   80ae8:	b16b      	cbz	r3, 80b06 <xQueueGenericSendFromISR+0x7e>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   80aea:	f104 0024 	add.w	r0, r4, #36	; 0x24
   80aee:	4b0c      	ldr	r3, [pc, #48]	; (80b20 <xQueueGenericSendFromISR+0x98>)
   80af0:	4798      	blx	r3
   80af2:	b150      	cbz	r0, 80b0a <xQueueGenericSendFromISR+0x82>
						if( pxHigherPriorityTaskWoken != NULL )
   80af4:	b15d      	cbz	r5, 80b0e <xQueueGenericSendFromISR+0x86>
							*pxHigherPriorityTaskWoken = pdTRUE;
   80af6:	2401      	movs	r4, #1
   80af8:	602c      	str	r4, [r5, #0]
   80afa:	e7e5      	b.n	80ac8 <xQueueGenericSendFromISR+0x40>
				++( pxQueue->xTxLock );
   80afc:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   80afe:	3301      	adds	r3, #1
   80b00:	64a3      	str	r3, [r4, #72]	; 0x48
			xReturn = pdPASS;
   80b02:	2401      	movs	r4, #1
   80b04:	e7e0      	b.n	80ac8 <xQueueGenericSendFromISR+0x40>
   80b06:	2401      	movs	r4, #1
   80b08:	e7de      	b.n	80ac8 <xQueueGenericSendFromISR+0x40>
   80b0a:	2401      	movs	r4, #1
   80b0c:	e7dc      	b.n	80ac8 <xQueueGenericSendFromISR+0x40>
   80b0e:	2401      	movs	r4, #1
   80b10:	e7da      	b.n	80ac8 <xQueueGenericSendFromISR+0x40>
   80b12:	bf00      	nop
   80b14:	00080485 	.word	0x00080485
   80b18:	000804ad 	.word	0x000804ad
   80b1c:	00080769 	.word	0x00080769
   80b20:	00081479 	.word	0x00081479

00080b24 <xQueueGenericReceive>:
{
   80b24:	b5f0      	push	{r4, r5, r6, r7, lr}
   80b26:	b085      	sub	sp, #20
   80b28:	9201      	str	r2, [sp, #4]
	configASSERT( pxQueue );
   80b2a:	b138      	cbz	r0, 80b3c <xQueueGenericReceive+0x18>
   80b2c:	460e      	mov	r6, r1
   80b2e:	461f      	mov	r7, r3
   80b30:	4604      	mov	r4, r0
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
   80b32:	b139      	cbz	r1, 80b44 <xQueueGenericReceive+0x20>
   80b34:	2301      	movs	r3, #1
   80b36:	b15b      	cbz	r3, 80b50 <xQueueGenericReceive+0x2c>
   80b38:	2500      	movs	r5, #0
   80b3a:	e053      	b.n	80be4 <xQueueGenericReceive+0xc0>
	configASSERT( pxQueue );
   80b3c:	4b48      	ldr	r3, [pc, #288]	; (80c60 <xQueueGenericReceive+0x13c>)
   80b3e:	4798      	blx	r3
   80b40:	bf00      	nop
   80b42:	e7fd      	b.n	80b40 <xQueueGenericReceive+0x1c>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
   80b44:	6c03      	ldr	r3, [r0, #64]	; 0x40
   80b46:	b90b      	cbnz	r3, 80b4c <xQueueGenericReceive+0x28>
   80b48:	2301      	movs	r3, #1
   80b4a:	e7f4      	b.n	80b36 <xQueueGenericReceive+0x12>
   80b4c:	2300      	movs	r3, #0
   80b4e:	e7f2      	b.n	80b36 <xQueueGenericReceive+0x12>
   80b50:	4b43      	ldr	r3, [pc, #268]	; (80c60 <xQueueGenericReceive+0x13c>)
   80b52:	4798      	blx	r3
   80b54:	bf00      	nop
   80b56:	e7fd      	b.n	80b54 <xQueueGenericReceive+0x30>
				pcOriginalReadPosition = pxQueue->pcReadFrom;
   80b58:	68e5      	ldr	r5, [r4, #12]
				prvCopyDataFromQueue( pxQueue, pvBuffer );
   80b5a:	4631      	mov	r1, r6
   80b5c:	4620      	mov	r0, r4
   80b5e:	4b41      	ldr	r3, [pc, #260]	; (80c64 <xQueueGenericReceive+0x140>)
   80b60:	4798      	blx	r3
				if( xJustPeeking == pdFALSE )
   80b62:	b9b7      	cbnz	r7, 80b92 <xQueueGenericReceive+0x6e>
					--( pxQueue->uxMessagesWaiting );
   80b64:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   80b66:	3b01      	subs	r3, #1
   80b68:	63a3      	str	r3, [r4, #56]	; 0x38
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   80b6a:	6823      	ldr	r3, [r4, #0]
   80b6c:	b913      	cbnz	r3, 80b74 <xQueueGenericReceive+0x50>
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
   80b6e:	4b3e      	ldr	r3, [pc, #248]	; (80c68 <xQueueGenericReceive+0x144>)
   80b70:	4798      	blx	r3
   80b72:	6060      	str	r0, [r4, #4]
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   80b74:	6923      	ldr	r3, [r4, #16]
   80b76:	b13b      	cbz	r3, 80b88 <xQueueGenericReceive+0x64>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
   80b78:	f104 0010 	add.w	r0, r4, #16
   80b7c:	4b3b      	ldr	r3, [pc, #236]	; (80c6c <xQueueGenericReceive+0x148>)
   80b7e:	4798      	blx	r3
   80b80:	2801      	cmp	r0, #1
   80b82:	d101      	bne.n	80b88 <xQueueGenericReceive+0x64>
							portYIELD_WITHIN_API();
   80b84:	4b3a      	ldr	r3, [pc, #232]	; (80c70 <xQueueGenericReceive+0x14c>)
   80b86:	4798      	blx	r3
				taskEXIT_CRITICAL();
   80b88:	4b3a      	ldr	r3, [pc, #232]	; (80c74 <xQueueGenericReceive+0x150>)
   80b8a:	4798      	blx	r3
				return pdPASS;
   80b8c:	2001      	movs	r0, #1
}
   80b8e:	b005      	add	sp, #20
   80b90:	bdf0      	pop	{r4, r5, r6, r7, pc}
					pxQueue->pcReadFrom = pcOriginalReadPosition;
   80b92:	60e5      	str	r5, [r4, #12]
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   80b94:	6a63      	ldr	r3, [r4, #36]	; 0x24
   80b96:	2b00      	cmp	r3, #0
   80b98:	d0f6      	beq.n	80b88 <xQueueGenericReceive+0x64>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   80b9a:	f104 0024 	add.w	r0, r4, #36	; 0x24
   80b9e:	4b33      	ldr	r3, [pc, #204]	; (80c6c <xQueueGenericReceive+0x148>)
   80ba0:	4798      	blx	r3
   80ba2:	2800      	cmp	r0, #0
   80ba4:	d0f0      	beq.n	80b88 <xQueueGenericReceive+0x64>
							portYIELD_WITHIN_API();
   80ba6:	4b32      	ldr	r3, [pc, #200]	; (80c70 <xQueueGenericReceive+0x14c>)
   80ba8:	4798      	blx	r3
   80baa:	e7ed      	b.n	80b88 <xQueueGenericReceive+0x64>
					taskEXIT_CRITICAL();
   80bac:	4b31      	ldr	r3, [pc, #196]	; (80c74 <xQueueGenericReceive+0x150>)
   80bae:	4798      	blx	r3
					return errQUEUE_EMPTY;
   80bb0:	2000      	movs	r0, #0
   80bb2:	e7ec      	b.n	80b8e <xQueueGenericReceive+0x6a>
					vTaskSetTimeOutState( &xTimeOut );
   80bb4:	a802      	add	r0, sp, #8
   80bb6:	4b30      	ldr	r3, [pc, #192]	; (80c78 <xQueueGenericReceive+0x154>)
   80bb8:	4798      	blx	r3
					xEntryTimeSet = pdTRUE;
   80bba:	2501      	movs	r5, #1
   80bbc:	e01c      	b.n	80bf8 <xQueueGenericReceive+0xd4>
		prvLockQueue( pxQueue );
   80bbe:	2300      	movs	r3, #0
   80bc0:	6463      	str	r3, [r4, #68]	; 0x44
   80bc2:	e023      	b.n	80c0c <xQueueGenericReceive+0xe8>
   80bc4:	2300      	movs	r3, #0
   80bc6:	64a3      	str	r3, [r4, #72]	; 0x48
   80bc8:	e024      	b.n	80c14 <xQueueGenericReceive+0xf0>
						portENTER_CRITICAL();
   80bca:	4b2c      	ldr	r3, [pc, #176]	; (80c7c <xQueueGenericReceive+0x158>)
   80bcc:	4798      	blx	r3
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
   80bce:	6860      	ldr	r0, [r4, #4]
   80bd0:	4b2b      	ldr	r3, [pc, #172]	; (80c80 <xQueueGenericReceive+0x15c>)
   80bd2:	4798      	blx	r3
						portEXIT_CRITICAL();
   80bd4:	4b27      	ldr	r3, [pc, #156]	; (80c74 <xQueueGenericReceive+0x150>)
   80bd6:	4798      	blx	r3
   80bd8:	e02b      	b.n	80c32 <xQueueGenericReceive+0x10e>
				prvUnlockQueue( pxQueue );
   80bda:	4620      	mov	r0, r4
   80bdc:	4b29      	ldr	r3, [pc, #164]	; (80c84 <xQueueGenericReceive+0x160>)
   80bde:	4798      	blx	r3
				( void ) xTaskResumeAll();
   80be0:	4b29      	ldr	r3, [pc, #164]	; (80c88 <xQueueGenericReceive+0x164>)
   80be2:	4798      	blx	r3
		taskENTER_CRITICAL();
   80be4:	4b25      	ldr	r3, [pc, #148]	; (80c7c <xQueueGenericReceive+0x158>)
   80be6:	4798      	blx	r3
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
   80be8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   80bea:	2b00      	cmp	r3, #0
   80bec:	d1b4      	bne.n	80b58 <xQueueGenericReceive+0x34>
				if( xTicksToWait == ( portTickType ) 0 )
   80bee:	9b01      	ldr	r3, [sp, #4]
   80bf0:	2b00      	cmp	r3, #0
   80bf2:	d0db      	beq.n	80bac <xQueueGenericReceive+0x88>
				else if( xEntryTimeSet == pdFALSE )
   80bf4:	2d00      	cmp	r5, #0
   80bf6:	d0dd      	beq.n	80bb4 <xQueueGenericReceive+0x90>
		taskEXIT_CRITICAL();
   80bf8:	4b1e      	ldr	r3, [pc, #120]	; (80c74 <xQueueGenericReceive+0x150>)
   80bfa:	4798      	blx	r3
		vTaskSuspendAll();
   80bfc:	4b23      	ldr	r3, [pc, #140]	; (80c8c <xQueueGenericReceive+0x168>)
   80bfe:	4798      	blx	r3
		prvLockQueue( pxQueue );
   80c00:	4b1e      	ldr	r3, [pc, #120]	; (80c7c <xQueueGenericReceive+0x158>)
   80c02:	4798      	blx	r3
   80c04:	6c63      	ldr	r3, [r4, #68]	; 0x44
   80c06:	f1b3 3fff 	cmp.w	r3, #4294967295
   80c0a:	d0d8      	beq.n	80bbe <xQueueGenericReceive+0x9a>
   80c0c:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   80c0e:	f1b3 3fff 	cmp.w	r3, #4294967295
   80c12:	d0d7      	beq.n	80bc4 <xQueueGenericReceive+0xa0>
   80c14:	4b17      	ldr	r3, [pc, #92]	; (80c74 <xQueueGenericReceive+0x150>)
   80c16:	4798      	blx	r3
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   80c18:	a901      	add	r1, sp, #4
   80c1a:	a802      	add	r0, sp, #8
   80c1c:	4b1c      	ldr	r3, [pc, #112]	; (80c90 <xQueueGenericReceive+0x16c>)
   80c1e:	4798      	blx	r3
   80c20:	b9b0      	cbnz	r0, 80c50 <xQueueGenericReceive+0x12c>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   80c22:	4620      	mov	r0, r4
   80c24:	4b1b      	ldr	r3, [pc, #108]	; (80c94 <xQueueGenericReceive+0x170>)
   80c26:	4798      	blx	r3
   80c28:	2800      	cmp	r0, #0
   80c2a:	d0d6      	beq.n	80bda <xQueueGenericReceive+0xb6>
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   80c2c:	6823      	ldr	r3, [r4, #0]
   80c2e:	2b00      	cmp	r3, #0
   80c30:	d0cb      	beq.n	80bca <xQueueGenericReceive+0xa6>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
   80c32:	9901      	ldr	r1, [sp, #4]
   80c34:	f104 0024 	add.w	r0, r4, #36	; 0x24
   80c38:	4b17      	ldr	r3, [pc, #92]	; (80c98 <xQueueGenericReceive+0x174>)
   80c3a:	4798      	blx	r3
				prvUnlockQueue( pxQueue );
   80c3c:	4620      	mov	r0, r4
   80c3e:	4b11      	ldr	r3, [pc, #68]	; (80c84 <xQueueGenericReceive+0x160>)
   80c40:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
   80c42:	4b11      	ldr	r3, [pc, #68]	; (80c88 <xQueueGenericReceive+0x164>)
   80c44:	4798      	blx	r3
   80c46:	2800      	cmp	r0, #0
   80c48:	d1cc      	bne.n	80be4 <xQueueGenericReceive+0xc0>
					portYIELD_WITHIN_API();
   80c4a:	4b09      	ldr	r3, [pc, #36]	; (80c70 <xQueueGenericReceive+0x14c>)
   80c4c:	4798      	blx	r3
   80c4e:	e7c9      	b.n	80be4 <xQueueGenericReceive+0xc0>
			prvUnlockQueue( pxQueue );
   80c50:	4620      	mov	r0, r4
   80c52:	4b0c      	ldr	r3, [pc, #48]	; (80c84 <xQueueGenericReceive+0x160>)
   80c54:	4798      	blx	r3
			( void ) xTaskResumeAll();
   80c56:	4b0c      	ldr	r3, [pc, #48]	; (80c88 <xQueueGenericReceive+0x164>)
   80c58:	4798      	blx	r3
			return errQUEUE_EMPTY;
   80c5a:	2000      	movs	r0, #0
   80c5c:	e797      	b.n	80b8e <xQueueGenericReceive+0x6a>
   80c5e:	bf00      	nop
   80c60:	00080485 	.word	0x00080485
   80c64:	000807d1 	.word	0x000807d1
   80c68:	000815b5 	.word	0x000815b5
   80c6c:	00081479 	.word	0x00081479
   80c70:	00080475 	.word	0x00080475
   80c74:	000804b5 	.word	0x000804b5
   80c78:	000814f9 	.word	0x000814f9
   80c7c:	00080495 	.word	0x00080495
   80c80:	000815e1 	.word	0x000815e1
   80c84:	000807f9 	.word	0x000807f9
   80c88:	00081125 	.word	0x00081125
   80c8c:	00080fe9 	.word	0x00080fe9
   80c90:	0008151d 	.word	0x0008151d
   80c94:	00080749 	.word	0x00080749
   80c98:	000813d5 	.word	0x000813d5

00080c9c <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if configUSE_TIMERS == 1

	void vQueueWaitForMessageRestricted( xQueueHandle pxQueue, portTickType xTicksToWait )
	{
   80c9c:	b538      	push	{r3, r4, r5, lr}
   80c9e:	4604      	mov	r4, r0
   80ca0:	460d      	mov	r5, r1
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
   80ca2:	4b0f      	ldr	r3, [pc, #60]	; (80ce0 <vQueueWaitForMessageRestricted+0x44>)
   80ca4:	4798      	blx	r3
   80ca6:	6c63      	ldr	r3, [r4, #68]	; 0x44
   80ca8:	f1b3 3fff 	cmp.w	r3, #4294967295
   80cac:	d00b      	beq.n	80cc6 <vQueueWaitForMessageRestricted+0x2a>
   80cae:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   80cb0:	f1b3 3fff 	cmp.w	r3, #4294967295
   80cb4:	d00a      	beq.n	80ccc <vQueueWaitForMessageRestricted+0x30>
   80cb6:	4b0b      	ldr	r3, [pc, #44]	; (80ce4 <vQueueWaitForMessageRestricted+0x48>)
   80cb8:	4798      	blx	r3
		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0U )
   80cba:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   80cbc:	b14b      	cbz	r3, 80cd2 <vQueueWaitForMessageRestricted+0x36>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
		}
		prvUnlockQueue( pxQueue );
   80cbe:	4620      	mov	r0, r4
   80cc0:	4b09      	ldr	r3, [pc, #36]	; (80ce8 <vQueueWaitForMessageRestricted+0x4c>)
   80cc2:	4798      	blx	r3
   80cc4:	bd38      	pop	{r3, r4, r5, pc}
		prvLockQueue( pxQueue );
   80cc6:	2300      	movs	r3, #0
   80cc8:	6463      	str	r3, [r4, #68]	; 0x44
   80cca:	e7f0      	b.n	80cae <vQueueWaitForMessageRestricted+0x12>
   80ccc:	2300      	movs	r3, #0
   80cce:	64a3      	str	r3, [r4, #72]	; 0x48
   80cd0:	e7f1      	b.n	80cb6 <vQueueWaitForMessageRestricted+0x1a>
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
   80cd2:	4629      	mov	r1, r5
   80cd4:	f104 0024 	add.w	r0, r4, #36	; 0x24
   80cd8:	4b04      	ldr	r3, [pc, #16]	; (80cec <vQueueWaitForMessageRestricted+0x50>)
   80cda:	4798      	blx	r3
   80cdc:	e7ef      	b.n	80cbe <vQueueWaitForMessageRestricted+0x22>
   80cde:	bf00      	nop
   80ce0:	00080495 	.word	0x00080495
   80ce4:	000804b5 	.word	0x000804b5
   80ce8:	000807f9 	.word	0x000807f9
   80cec:	00081435 	.word	0x00081435

00080cf0 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
   80cf0:	b538      	push	{r3, r4, r5, lr}
   80cf2:	4605      	mov	r5, r0
		want to allocate and clean RAM statically. */
		portCLEAN_UP_TCB( pxTCB );

		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
   80cf4:	6b00      	ldr	r0, [r0, #48]	; 0x30
   80cf6:	4c02      	ldr	r4, [pc, #8]	; (80d00 <prvDeleteTCB+0x10>)
   80cf8:	47a0      	blx	r4
		vPortFree( pxTCB );
   80cfa:	4628      	mov	r0, r5
   80cfc:	47a0      	blx	r4
   80cfe:	bd38      	pop	{r3, r4, r5, pc}
   80d00:	000806ed 	.word	0x000806ed

00080d04 <prvAllocateTCBAndStack>:
{
   80d04:	b570      	push	{r4, r5, r6, lr}
   80d06:	4606      	mov	r6, r0
   80d08:	460c      	mov	r4, r1
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
   80d0a:	204c      	movs	r0, #76	; 0x4c
   80d0c:	4b0b      	ldr	r3, [pc, #44]	; (80d3c <prvAllocateTCBAndStack+0x38>)
   80d0e:	4798      	blx	r3
	if( pxNewTCB != NULL )
   80d10:	4605      	mov	r5, r0
   80d12:	b138      	cbz	r0, 80d24 <prvAllocateTCBAndStack+0x20>
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
   80d14:	b144      	cbz	r4, 80d28 <prvAllocateTCBAndStack+0x24>
   80d16:	632c      	str	r4, [r5, #48]	; 0x30
		if( pxNewTCB->pxStack == NULL )
   80d18:	b15c      	cbz	r4, 80d32 <prvAllocateTCBAndStack+0x2e>
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
   80d1a:	00b2      	lsls	r2, r6, #2
   80d1c:	21a5      	movs	r1, #165	; 0xa5
   80d1e:	4620      	mov	r0, r4
   80d20:	4b07      	ldr	r3, [pc, #28]	; (80d40 <prvAllocateTCBAndStack+0x3c>)
   80d22:	4798      	blx	r3
}
   80d24:	4628      	mov	r0, r5
   80d26:	bd70      	pop	{r4, r5, r6, pc}
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
   80d28:	00b0      	lsls	r0, r6, #2
   80d2a:	4b04      	ldr	r3, [pc, #16]	; (80d3c <prvAllocateTCBAndStack+0x38>)
   80d2c:	4798      	blx	r3
   80d2e:	4604      	mov	r4, r0
   80d30:	e7f1      	b.n	80d16 <prvAllocateTCBAndStack+0x12>
			vPortFree( pxNewTCB );
   80d32:	4628      	mov	r0, r5
   80d34:	4b03      	ldr	r3, [pc, #12]	; (80d44 <prvAllocateTCBAndStack+0x40>)
   80d36:	4798      	blx	r3
			pxNewTCB = NULL;
   80d38:	2500      	movs	r5, #0
   80d3a:	e7f3      	b.n	80d24 <prvAllocateTCBAndStack+0x20>
   80d3c:	0008063d 	.word	0x0008063d
   80d40:	00082361 	.word	0x00082361
   80d44:	000806ed 	.word	0x000806ed

00080d48 <prvInitialiseTCBVariables>:
{
   80d48:	b570      	push	{r4, r5, r6, lr}
   80d4a:	4604      	mov	r4, r0
   80d4c:	4615      	mov	r5, r2
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
   80d4e:	220a      	movs	r2, #10
   80d50:	3034      	adds	r0, #52	; 0x34
   80d52:	4b0b      	ldr	r3, [pc, #44]	; (80d80 <prvInitialiseTCBVariables+0x38>)
   80d54:	4798      	blx	r3
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
   80d56:	2300      	movs	r3, #0
   80d58:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
	if( uxPriority >= configMAX_PRIORITIES )
   80d5c:	2d04      	cmp	r5, #4
   80d5e:	d900      	bls.n	80d62 <prvInitialiseTCBVariables+0x1a>
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
   80d60:	2504      	movs	r5, #4
	pxTCB->uxPriority = uxPriority;
   80d62:	62e5      	str	r5, [r4, #44]	; 0x2c
		pxTCB->uxBasePriority = uxPriority;
   80d64:	64a5      	str	r5, [r4, #72]	; 0x48
	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
   80d66:	1d20      	adds	r0, r4, #4
   80d68:	4e06      	ldr	r6, [pc, #24]	; (80d84 <prvInitialiseTCBVariables+0x3c>)
   80d6a:	47b0      	blx	r6
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
   80d6c:	f104 0018 	add.w	r0, r4, #24
   80d70:	47b0      	blx	r6
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
   80d72:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
   80d74:	f1c5 0505 	rsb	r5, r5, #5
   80d78:	61a5      	str	r5, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
   80d7a:	6264      	str	r4, [r4, #36]	; 0x24
   80d7c:	bd70      	pop	{r4, r5, r6, pc}
   80d7e:	bf00      	nop
   80d80:	000823fd 	.word	0x000823fd
   80d84:	000803a7 	.word	0x000803a7

00080d88 <prvInitialiseTaskLists>:
{
   80d88:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
   80d8a:	2400      	movs	r4, #0
   80d8c:	2c04      	cmp	r4, #4
   80d8e:	d917      	bls.n	80dc0 <prvInitialiseTaskLists+0x38>
	vListInitialise( ( xList * ) &xDelayedTaskList1 );
   80d90:	4c0f      	ldr	r4, [pc, #60]	; (80dd0 <prvInitialiseTaskLists+0x48>)
   80d92:	f104 0764 	add.w	r7, r4, #100	; 0x64
   80d96:	4638      	mov	r0, r7
   80d98:	4d0e      	ldr	r5, [pc, #56]	; (80dd4 <prvInitialiseTaskLists+0x4c>)
   80d9a:	47a8      	blx	r5
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
   80d9c:	f104 0678 	add.w	r6, r4, #120	; 0x78
   80da0:	4630      	mov	r0, r6
   80da2:	47a8      	blx	r5
	vListInitialise( ( xList * ) &xPendingReadyList );
   80da4:	f104 008c 	add.w	r0, r4, #140	; 0x8c
   80da8:	47a8      	blx	r5
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
   80daa:	f104 00a0 	add.w	r0, r4, #160	; 0xa0
   80dae:	47a8      	blx	r5
		vListInitialise( ( xList * ) &xSuspendedTaskList );
   80db0:	f104 00b4 	add.w	r0, r4, #180	; 0xb4
   80db4:	47a8      	blx	r5
	pxDelayedTaskList = &xDelayedTaskList1;
   80db6:	f8c4 70c8 	str.w	r7, [r4, #200]	; 0xc8
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
   80dba:	f8c4 60cc 	str.w	r6, [r4, #204]	; 0xcc
   80dbe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
   80dc0:	2014      	movs	r0, #20
   80dc2:	4b03      	ldr	r3, [pc, #12]	; (80dd0 <prvInitialiseTaskLists+0x48>)
   80dc4:	fb00 3004 	mla	r0, r0, r4, r3
   80dc8:	4b02      	ldr	r3, [pc, #8]	; (80dd4 <prvInitialiseTaskLists+0x4c>)
   80dca:	4798      	blx	r3
	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
   80dcc:	3401      	adds	r4, #1
   80dce:	e7dd      	b.n	80d8c <prvInitialiseTaskLists+0x4>
   80dd0:	2000a46c 	.word	0x2000a46c
   80dd4:	00080391 	.word	0x00080391

00080dd8 <prvAddCurrentTaskToDelayedList>:
{
   80dd8:	b510      	push	{r4, lr}
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
   80dda:	4b10      	ldr	r3, [pc, #64]	; (80e1c <prvAddCurrentTaskToDelayedList+0x44>)
   80ddc:	f8d3 20d0 	ldr.w	r2, [r3, #208]	; 0xd0
   80de0:	6050      	str	r0, [r2, #4]
	if( xTimeToWake < xTickCount )
   80de2:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
   80de6:	4298      	cmp	r0, r3
   80de8:	d30f      	bcc.n	80e0a <prvAddCurrentTaskToDelayedList+0x32>
   80dea:	4604      	mov	r4, r0
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
   80dec:	4b0b      	ldr	r3, [pc, #44]	; (80e1c <prvAddCurrentTaskToDelayedList+0x44>)
   80dee:	f8d3 00c8 	ldr.w	r0, [r3, #200]	; 0xc8
   80df2:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   80df6:	3104      	adds	r1, #4
   80df8:	4b09      	ldr	r3, [pc, #36]	; (80e20 <prvAddCurrentTaskToDelayedList+0x48>)
   80dfa:	4798      	blx	r3
		if( xTimeToWake < xNextTaskUnblockTime )
   80dfc:	4b09      	ldr	r3, [pc, #36]	; (80e24 <prvAddCurrentTaskToDelayedList+0x4c>)
   80dfe:	681b      	ldr	r3, [r3, #0]
   80e00:	429c      	cmp	r4, r3
   80e02:	d201      	bcs.n	80e08 <prvAddCurrentTaskToDelayedList+0x30>
			xNextTaskUnblockTime = xTimeToWake;
   80e04:	4b07      	ldr	r3, [pc, #28]	; (80e24 <prvAddCurrentTaskToDelayedList+0x4c>)
   80e06:	601c      	str	r4, [r3, #0]
   80e08:	bd10      	pop	{r4, pc}
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
   80e0a:	4b04      	ldr	r3, [pc, #16]	; (80e1c <prvAddCurrentTaskToDelayedList+0x44>)
   80e0c:	f8d3 00cc 	ldr.w	r0, [r3, #204]	; 0xcc
   80e10:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   80e14:	3104      	adds	r1, #4
   80e16:	4b02      	ldr	r3, [pc, #8]	; (80e20 <prvAddCurrentTaskToDelayedList+0x48>)
   80e18:	4798      	blx	r3
   80e1a:	bd10      	pop	{r4, pc}
   80e1c:	2000a46c 	.word	0x2000a46c
   80e20:	000803c9 	.word	0x000803c9
   80e24:	2000000c 	.word	0x2000000c

00080e28 <xTaskGenericCreate>:
{
   80e28:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   80e2c:	b083      	sub	sp, #12
   80e2e:	9e0c      	ldr	r6, [sp, #48]	; 0x30
   80e30:	f8dd 8034 	ldr.w	r8, [sp, #52]	; 0x34
	configASSERT( pxTaskCode );
   80e34:	b148      	cbz	r0, 80e4a <xTaskGenericCreate+0x22>
   80e36:	468b      	mov	fp, r1
   80e38:	4617      	mov	r7, r2
   80e3a:	469a      	mov	sl, r3
   80e3c:	4681      	mov	r9, r0
	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
   80e3e:	2e04      	cmp	r6, #4
   80e40:	d907      	bls.n	80e52 <xTaskGenericCreate+0x2a>
   80e42:	4b44      	ldr	r3, [pc, #272]	; (80f54 <xTaskGenericCreate+0x12c>)
   80e44:	4798      	blx	r3
   80e46:	bf00      	nop
   80e48:	e7fd      	b.n	80e46 <xTaskGenericCreate+0x1e>
	configASSERT( pxTaskCode );
   80e4a:	4b42      	ldr	r3, [pc, #264]	; (80f54 <xTaskGenericCreate+0x12c>)
   80e4c:	4798      	blx	r3
   80e4e:	bf00      	nop
   80e50:	e7fd      	b.n	80e4e <xTaskGenericCreate+0x26>
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
   80e52:	990e      	ldr	r1, [sp, #56]	; 0x38
   80e54:	4610      	mov	r0, r2
   80e56:	4b40      	ldr	r3, [pc, #256]	; (80f58 <xTaskGenericCreate+0x130>)
   80e58:	4798      	blx	r3
	if( pxNewTCB != NULL )
   80e5a:	4604      	mov	r4, r0
   80e5c:	2800      	cmp	r0, #0
   80e5e:	d068      	beq.n	80f32 <xTaskGenericCreate+0x10a>
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
   80e60:	6b03      	ldr	r3, [r0, #48]	; 0x30
   80e62:	f107 4580 	add.w	r5, r7, #1073741824	; 0x40000000
   80e66:	3d01      	subs	r5, #1
   80e68:	eb03 0385 	add.w	r3, r3, r5, lsl #2
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK  ) );
   80e6c:	f023 0507 	bic.w	r5, r3, #7
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
   80e70:	9700      	str	r7, [sp, #0]
   80e72:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   80e74:	4632      	mov	r2, r6
   80e76:	4659      	mov	r1, fp
   80e78:	4f38      	ldr	r7, [pc, #224]	; (80f5c <xTaskGenericCreate+0x134>)
   80e7a:	47b8      	blx	r7
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
   80e7c:	4652      	mov	r2, sl
   80e7e:	4649      	mov	r1, r9
   80e80:	4628      	mov	r0, r5
   80e82:	4b37      	ldr	r3, [pc, #220]	; (80f60 <xTaskGenericCreate+0x138>)
   80e84:	4798      	blx	r3
   80e86:	6020      	str	r0, [r4, #0]
		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
   80e88:	f010 0f07 	tst.w	r0, #7
   80e8c:	d11d      	bne.n	80eca <xTaskGenericCreate+0xa2>
		if( ( void * ) pxCreatedTask != NULL )
   80e8e:	f1b8 0f00 	cmp.w	r8, #0
   80e92:	d001      	beq.n	80e98 <xTaskGenericCreate+0x70>
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
   80e94:	f8c8 4000 	str.w	r4, [r8]
		taskENTER_CRITICAL();
   80e98:	4b32      	ldr	r3, [pc, #200]	; (80f64 <xTaskGenericCreate+0x13c>)
   80e9a:	4798      	blx	r3
			uxCurrentNumberOfTasks++;
   80e9c:	4b32      	ldr	r3, [pc, #200]	; (80f68 <xTaskGenericCreate+0x140>)
   80e9e:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
   80ea2:	3201      	adds	r2, #1
   80ea4:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
			if( pxCurrentTCB == NULL )
   80ea8:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
   80eac:	b18b      	cbz	r3, 80ed2 <xTaskGenericCreate+0xaa>
				if( xSchedulerRunning == pdFALSE )
   80eae:	4b2e      	ldr	r3, [pc, #184]	; (80f68 <xTaskGenericCreate+0x140>)
   80eb0:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
   80eb4:	b9b3      	cbnz	r3, 80ee4 <xTaskGenericCreate+0xbc>
					if( pxCurrentTCB->uxPriority <= uxPriority )
   80eb6:	4b2c      	ldr	r3, [pc, #176]	; (80f68 <xTaskGenericCreate+0x140>)
   80eb8:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
   80ebc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   80ebe:	429e      	cmp	r6, r3
   80ec0:	d310      	bcc.n	80ee4 <xTaskGenericCreate+0xbc>
						pxCurrentTCB = pxNewTCB;
   80ec2:	4b29      	ldr	r3, [pc, #164]	; (80f68 <xTaskGenericCreate+0x140>)
   80ec4:	f8c3 40d0 	str.w	r4, [r3, #208]	; 0xd0
   80ec8:	e00c      	b.n	80ee4 <xTaskGenericCreate+0xbc>
		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
   80eca:	4b22      	ldr	r3, [pc, #136]	; (80f54 <xTaskGenericCreate+0x12c>)
   80ecc:	4798      	blx	r3
   80ece:	bf00      	nop
   80ed0:	e7fd      	b.n	80ece <xTaskGenericCreate+0xa6>
				pxCurrentTCB =  pxNewTCB;
   80ed2:	4b25      	ldr	r3, [pc, #148]	; (80f68 <xTaskGenericCreate+0x140>)
   80ed4:	f8c3 40d0 	str.w	r4, [r3, #208]	; 0xd0
				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
   80ed8:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
   80edc:	2b01      	cmp	r3, #1
   80ede:	d101      	bne.n	80ee4 <xTaskGenericCreate+0xbc>
					prvInitialiseTaskLists();
   80ee0:	4b22      	ldr	r3, [pc, #136]	; (80f6c <xTaskGenericCreate+0x144>)
   80ee2:	4798      	blx	r3
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
   80ee4:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   80ee6:	4a20      	ldr	r2, [pc, #128]	; (80f68 <xTaskGenericCreate+0x140>)
   80ee8:	f8d2 2108 	ldr.w	r2, [r2, #264]	; 0x108
   80eec:	4293      	cmp	r3, r2
   80eee:	d902      	bls.n	80ef6 <xTaskGenericCreate+0xce>
				uxTopUsedPriority = pxNewTCB->uxPriority;
   80ef0:	4a1d      	ldr	r2, [pc, #116]	; (80f68 <xTaskGenericCreate+0x140>)
   80ef2:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
				pxNewTCB->uxTCBNumber = uxTaskNumber;
   80ef6:	491c      	ldr	r1, [pc, #112]	; (80f68 <xTaskGenericCreate+0x140>)
   80ef8:	f8d1 210c 	ldr.w	r2, [r1, #268]	; 0x10c
   80efc:	6422      	str	r2, [r4, #64]	; 0x40
			uxTaskNumber++;
   80efe:	3201      	adds	r2, #1
   80f00:	f8c1 210c 	str.w	r2, [r1, #268]	; 0x10c
			prvAddTaskToReadyQueue( pxNewTCB );
   80f04:	f8d1 2110 	ldr.w	r2, [r1, #272]	; 0x110
   80f08:	4293      	cmp	r3, r2
   80f0a:	d901      	bls.n	80f10 <xTaskGenericCreate+0xe8>
   80f0c:	f8c1 3110 	str.w	r3, [r1, #272]	; 0x110
   80f10:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   80f14:	009a      	lsls	r2, r3, #2
   80f16:	1d21      	adds	r1, r4, #4
   80f18:	4813      	ldr	r0, [pc, #76]	; (80f68 <xTaskGenericCreate+0x140>)
   80f1a:	4410      	add	r0, r2
   80f1c:	4b14      	ldr	r3, [pc, #80]	; (80f70 <xTaskGenericCreate+0x148>)
   80f1e:	4798      	blx	r3
		taskEXIT_CRITICAL();
   80f20:	4b14      	ldr	r3, [pc, #80]	; (80f74 <xTaskGenericCreate+0x14c>)
   80f22:	4798      	blx	r3
			xReturn = pdPASS;
   80f24:	2401      	movs	r4, #1
	if( xReturn == pdPASS )
   80f26:	2c01      	cmp	r4, #1
   80f28:	d006      	beq.n	80f38 <xTaskGenericCreate+0x110>
}
   80f2a:	4620      	mov	r0, r4
   80f2c:	b003      	add	sp, #12
   80f2e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
   80f32:	f04f 34ff 	mov.w	r4, #4294967295
   80f36:	e7f6      	b.n	80f26 <xTaskGenericCreate+0xfe>
		if( xSchedulerRunning != pdFALSE )
   80f38:	4b0b      	ldr	r3, [pc, #44]	; (80f68 <xTaskGenericCreate+0x140>)
   80f3a:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
   80f3e:	2b00      	cmp	r3, #0
   80f40:	d0f3      	beq.n	80f2a <xTaskGenericCreate+0x102>
			if( pxCurrentTCB->uxPriority < uxPriority )
   80f42:	4b09      	ldr	r3, [pc, #36]	; (80f68 <xTaskGenericCreate+0x140>)
   80f44:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
   80f48:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   80f4a:	429e      	cmp	r6, r3
   80f4c:	d9ed      	bls.n	80f2a <xTaskGenericCreate+0x102>
				portYIELD_WITHIN_API();
   80f4e:	4b0a      	ldr	r3, [pc, #40]	; (80f78 <xTaskGenericCreate+0x150>)
   80f50:	4798      	blx	r3
	return xReturn;
   80f52:	e7ea      	b.n	80f2a <xTaskGenericCreate+0x102>
   80f54:	00080485 	.word	0x00080485
   80f58:	00080d05 	.word	0x00080d05
   80f5c:	00080d49 	.word	0x00080d49
   80f60:	00080439 	.word	0x00080439
   80f64:	00080495 	.word	0x00080495
   80f68:	2000a46c 	.word	0x2000a46c
   80f6c:	00080d89 	.word	0x00080d89
   80f70:	000803ad 	.word	0x000803ad
   80f74:	000804b5 	.word	0x000804b5
   80f78:	00080475 	.word	0x00080475

00080f7c <vTaskStartScheduler>:
{
   80f7c:	b510      	push	{r4, lr}
   80f7e:	b084      	sub	sp, #16
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
   80f80:	2300      	movs	r3, #0
   80f82:	9303      	str	r3, [sp, #12]
   80f84:	9302      	str	r3, [sp, #8]
   80f86:	9301      	str	r3, [sp, #4]
   80f88:	9300      	str	r3, [sp, #0]
   80f8a:	2282      	movs	r2, #130	; 0x82
   80f8c:	490f      	ldr	r1, [pc, #60]	; (80fcc <vTaskStartScheduler+0x50>)
   80f8e:	4810      	ldr	r0, [pc, #64]	; (80fd0 <vTaskStartScheduler+0x54>)
   80f90:	4c10      	ldr	r4, [pc, #64]	; (80fd4 <vTaskStartScheduler+0x58>)
   80f92:	47a0      	blx	r4
   80f94:	4604      	mov	r4, r0
		if( xReturn == pdPASS )
   80f96:	2801      	cmp	r0, #1
   80f98:	d004      	beq.n	80fa4 <vTaskStartScheduler+0x28>
	if( xReturn == pdPASS )
   80f9a:	2c01      	cmp	r4, #1
   80f9c:	d006      	beq.n	80fac <vTaskStartScheduler+0x30>
	configASSERT( xReturn );
   80f9e:	b18c      	cbz	r4, 80fc4 <vTaskStartScheduler+0x48>
}
   80fa0:	b004      	add	sp, #16
   80fa2:	bd10      	pop	{r4, pc}
			xReturn = xTimerCreateTimerTask();
   80fa4:	4b0c      	ldr	r3, [pc, #48]	; (80fd8 <vTaskStartScheduler+0x5c>)
   80fa6:	4798      	blx	r3
   80fa8:	4604      	mov	r4, r0
   80faa:	e7f6      	b.n	80f9a <vTaskStartScheduler+0x1e>
		portDISABLE_INTERRUPTS();
   80fac:	4b0b      	ldr	r3, [pc, #44]	; (80fdc <vTaskStartScheduler+0x60>)
   80fae:	4798      	blx	r3
		xSchedulerRunning = pdTRUE;
   80fb0:	4b0b      	ldr	r3, [pc, #44]	; (80fe0 <vTaskStartScheduler+0x64>)
   80fb2:	2201      	movs	r2, #1
   80fb4:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
		xTickCount = ( portTickType ) 0U;
   80fb8:	2200      	movs	r2, #0
   80fba:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
		if( xPortStartScheduler() != pdFALSE )
   80fbe:	4b09      	ldr	r3, [pc, #36]	; (80fe4 <vTaskStartScheduler+0x68>)
   80fc0:	4798      	blx	r3
   80fc2:	e7ec      	b.n	80f9e <vTaskStartScheduler+0x22>
	configASSERT( xReturn );
   80fc4:	4b05      	ldr	r3, [pc, #20]	; (80fdc <vTaskStartScheduler+0x60>)
   80fc6:	4798      	blx	r3
   80fc8:	bf00      	nop
   80fca:	e7fd      	b.n	80fc8 <vTaskStartScheduler+0x4c>
   80fcc:	00082594 	.word	0x00082594
   80fd0:	00081329 	.word	0x00081329
   80fd4:	00080e29 	.word	0x00080e29
   80fd8:	00081765 	.word	0x00081765
   80fdc:	00080485 	.word	0x00080485
   80fe0:	2000a46c 	.word	0x2000a46c
   80fe4:	00080569 	.word	0x00080569

00080fe8 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
   80fe8:	4a03      	ldr	r2, [pc, #12]	; (80ff8 <vTaskSuspendAll+0x10>)
   80fea:	f8d2 3118 	ldr.w	r3, [r2, #280]	; 0x118
   80fee:	3301      	adds	r3, #1
   80ff0:	f8c2 3118 	str.w	r3, [r2, #280]	; 0x118
   80ff4:	4770      	bx	lr
   80ff6:	bf00      	nop
   80ff8:	2000a46c 	.word	0x2000a46c

00080ffc <xTaskGetTickCount>:
{
   80ffc:	b510      	push	{r4, lr}
	taskENTER_CRITICAL();
   80ffe:	4b04      	ldr	r3, [pc, #16]	; (81010 <xTaskGetTickCount+0x14>)
   81000:	4798      	blx	r3
		xTicks = xTickCount;
   81002:	4b04      	ldr	r3, [pc, #16]	; (81014 <xTaskGetTickCount+0x18>)
   81004:	f8d3 40d4 	ldr.w	r4, [r3, #212]	; 0xd4
	taskEXIT_CRITICAL();
   81008:	4b03      	ldr	r3, [pc, #12]	; (81018 <xTaskGetTickCount+0x1c>)
   8100a:	4798      	blx	r3
}
   8100c:	4620      	mov	r0, r4
   8100e:	bd10      	pop	{r4, pc}
   81010:	00080495 	.word	0x00080495
   81014:	2000a46c 	.word	0x2000a46c
   81018:	000804b5 	.word	0x000804b5

0008101c <vTaskIncrementTick>:
{
   8101c:	b538      	push	{r3, r4, r5, lr}
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
   8101e:	4b3c      	ldr	r3, [pc, #240]	; (81110 <vTaskIncrementTick+0xf4>)
   81020:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
   81024:	2b00      	cmp	r3, #0
   81026:	d16c      	bne.n	81102 <vTaskIncrementTick+0xe6>
		++xTickCount;
   81028:	4b39      	ldr	r3, [pc, #228]	; (81110 <vTaskIncrementTick+0xf4>)
   8102a:	f8d3 20d4 	ldr.w	r2, [r3, #212]	; 0xd4
   8102e:	3201      	adds	r2, #1
   81030:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
		if( xTickCount == ( portTickType ) 0U )
   81034:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
   81038:	b9d3      	cbnz	r3, 81070 <vTaskIncrementTick+0x54>
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
   8103a:	4b35      	ldr	r3, [pc, #212]	; (81110 <vTaskIncrementTick+0xf4>)
   8103c:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
   81040:	681b      	ldr	r3, [r3, #0]
   81042:	b9eb      	cbnz	r3, 81080 <vTaskIncrementTick+0x64>
			pxTemp = pxDelayedTaskList;
   81044:	4b32      	ldr	r3, [pc, #200]	; (81110 <vTaskIncrementTick+0xf4>)
   81046:	f8d3 20c8 	ldr.w	r2, [r3, #200]	; 0xc8
			pxDelayedTaskList = pxOverflowDelayedTaskList;
   8104a:	f8d3 10cc 	ldr.w	r1, [r3, #204]	; 0xcc
   8104e:	f8c3 10c8 	str.w	r1, [r3, #200]	; 0xc8
			pxOverflowDelayedTaskList = pxTemp;
   81052:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc
			xNumOfOverflows++;
   81056:	f8d3 211c 	ldr.w	r2, [r3, #284]	; 0x11c
   8105a:	3201      	adds	r2, #1
   8105c:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   81060:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
   81064:	681b      	ldr	r3, [r3, #0]
   81066:	b97b      	cbnz	r3, 81088 <vTaskIncrementTick+0x6c>
				xNextTaskUnblockTime = portMAX_DELAY;
   81068:	f04f 32ff 	mov.w	r2, #4294967295
   8106c:	4b29      	ldr	r3, [pc, #164]	; (81114 <vTaskIncrementTick+0xf8>)
   8106e:	601a      	str	r2, [r3, #0]
		prvCheckDelayedTasks();
   81070:	4b27      	ldr	r3, [pc, #156]	; (81110 <vTaskIncrementTick+0xf4>)
   81072:	f8d3 20d4 	ldr.w	r2, [r3, #212]	; 0xd4
   81076:	4b27      	ldr	r3, [pc, #156]	; (81114 <vTaskIncrementTick+0xf8>)
   81078:	681b      	ldr	r3, [r3, #0]
   8107a:	429a      	cmp	r2, r3
   8107c:	d21d      	bcs.n	810ba <vTaskIncrementTick+0x9e>
   8107e:	e046      	b.n	8110e <vTaskIncrementTick+0xf2>
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
   81080:	4b25      	ldr	r3, [pc, #148]	; (81118 <vTaskIncrementTick+0xfc>)
   81082:	4798      	blx	r3
   81084:	bf00      	nop
   81086:	e7fd      	b.n	81084 <vTaskIncrementTick+0x68>
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
   81088:	4b21      	ldr	r3, [pc, #132]	; (81110 <vTaskIncrementTick+0xf4>)
   8108a:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
   8108e:	68db      	ldr	r3, [r3, #12]
   81090:	68db      	ldr	r3, [r3, #12]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
   81092:	685a      	ldr	r2, [r3, #4]
   81094:	4b1f      	ldr	r3, [pc, #124]	; (81114 <vTaskIncrementTick+0xf8>)
   81096:	601a      	str	r2, [r3, #0]
   81098:	e7ea      	b.n	81070 <vTaskIncrementTick+0x54>
		prvCheckDelayedTasks();
   8109a:	f04f 32ff 	mov.w	r2, #4294967295
   8109e:	4b1d      	ldr	r3, [pc, #116]	; (81114 <vTaskIncrementTick+0xf8>)
   810a0:	601a      	str	r2, [r3, #0]
   810a2:	bd38      	pop	{r3, r4, r5, pc}
   810a4:	4b1b      	ldr	r3, [pc, #108]	; (81114 <vTaskIncrementTick+0xf8>)
   810a6:	601a      	str	r2, [r3, #0]
   810a8:	bd38      	pop	{r3, r4, r5, pc}
   810aa:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   810ae:	009a      	lsls	r2, r3, #2
   810b0:	4629      	mov	r1, r5
   810b2:	4817      	ldr	r0, [pc, #92]	; (81110 <vTaskIncrementTick+0xf4>)
   810b4:	4410      	add	r0, r2
   810b6:	4b19      	ldr	r3, [pc, #100]	; (8111c <vTaskIncrementTick+0x100>)
   810b8:	4798      	blx	r3
   810ba:	4b15      	ldr	r3, [pc, #84]	; (81110 <vTaskIncrementTick+0xf4>)
   810bc:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
   810c0:	681b      	ldr	r3, [r3, #0]
   810c2:	2b00      	cmp	r3, #0
   810c4:	d0e9      	beq.n	8109a <vTaskIncrementTick+0x7e>
   810c6:	4b12      	ldr	r3, [pc, #72]	; (81110 <vTaskIncrementTick+0xf4>)
   810c8:	f8d3 20c8 	ldr.w	r2, [r3, #200]	; 0xc8
   810cc:	68d2      	ldr	r2, [r2, #12]
   810ce:	68d4      	ldr	r4, [r2, #12]
   810d0:	6862      	ldr	r2, [r4, #4]
   810d2:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
   810d6:	429a      	cmp	r2, r3
   810d8:	d8e4      	bhi.n	810a4 <vTaskIncrementTick+0x88>
   810da:	1d25      	adds	r5, r4, #4
   810dc:	4628      	mov	r0, r5
   810de:	4b10      	ldr	r3, [pc, #64]	; (81120 <vTaskIncrementTick+0x104>)
   810e0:	4798      	blx	r3
   810e2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   810e4:	b11b      	cbz	r3, 810ee <vTaskIncrementTick+0xd2>
   810e6:	f104 0018 	add.w	r0, r4, #24
   810ea:	4b0d      	ldr	r3, [pc, #52]	; (81120 <vTaskIncrementTick+0x104>)
   810ec:	4798      	blx	r3
   810ee:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   810f0:	4a07      	ldr	r2, [pc, #28]	; (81110 <vTaskIncrementTick+0xf4>)
   810f2:	f8d2 2110 	ldr.w	r2, [r2, #272]	; 0x110
   810f6:	4293      	cmp	r3, r2
   810f8:	d9d7      	bls.n	810aa <vTaskIncrementTick+0x8e>
   810fa:	4a05      	ldr	r2, [pc, #20]	; (81110 <vTaskIncrementTick+0xf4>)
   810fc:	f8c2 3110 	str.w	r3, [r2, #272]	; 0x110
   81100:	e7d3      	b.n	810aa <vTaskIncrementTick+0x8e>
		++uxMissedTicks;
   81102:	4a03      	ldr	r2, [pc, #12]	; (81110 <vTaskIncrementTick+0xf4>)
   81104:	f8d2 3120 	ldr.w	r3, [r2, #288]	; 0x120
   81108:	3301      	adds	r3, #1
   8110a:	f8c2 3120 	str.w	r3, [r2, #288]	; 0x120
   8110e:	bd38      	pop	{r3, r4, r5, pc}
   81110:	2000a46c 	.word	0x2000a46c
   81114:	2000000c 	.word	0x2000000c
   81118:	00080485 	.word	0x00080485
   8111c:	000803ad 	.word	0x000803ad
   81120:	000803fd 	.word	0x000803fd

00081124 <xTaskResumeAll>:
{
   81124:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	configASSERT( uxSchedulerSuspended );
   81128:	4b34      	ldr	r3, [pc, #208]	; (811fc <xTaskResumeAll+0xd8>)
   8112a:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
   8112e:	b91b      	cbnz	r3, 81138 <xTaskResumeAll+0x14>
   81130:	4b33      	ldr	r3, [pc, #204]	; (81200 <xTaskResumeAll+0xdc>)
   81132:	4798      	blx	r3
   81134:	bf00      	nop
   81136:	e7fd      	b.n	81134 <xTaskResumeAll+0x10>
	taskENTER_CRITICAL();
   81138:	4b32      	ldr	r3, [pc, #200]	; (81204 <xTaskResumeAll+0xe0>)
   8113a:	4798      	blx	r3
		--uxSchedulerSuspended;
   8113c:	4b2f      	ldr	r3, [pc, #188]	; (811fc <xTaskResumeAll+0xd8>)
   8113e:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
   81142:	3a01      	subs	r2, #1
   81144:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
   81148:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
   8114c:	2b00      	cmp	r3, #0
   8114e:	d152      	bne.n	811f6 <xTaskResumeAll+0xd2>
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
   81150:	4b2a      	ldr	r3, [pc, #168]	; (811fc <xTaskResumeAll+0xd8>)
   81152:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
   81156:	b33b      	cbz	r3, 811a8 <xTaskResumeAll+0x84>
   81158:	2400      	movs	r4, #0
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
   8115a:	4b28      	ldr	r3, [pc, #160]	; (811fc <xTaskResumeAll+0xd8>)
   8115c:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
   81160:	b343      	cbz	r3, 811b4 <xTaskResumeAll+0x90>
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
   81162:	4e26      	ldr	r6, [pc, #152]	; (811fc <xTaskResumeAll+0xd8>)
   81164:	f8d6 3098 	ldr.w	r3, [r6, #152]	; 0x98
   81168:	68dd      	ldr	r5, [r3, #12]
					uxListRemove( &( pxTCB->xEventListItem ) );
   8116a:	f105 0018 	add.w	r0, r5, #24
   8116e:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 81218 <xTaskResumeAll+0xf4>
   81172:	47c0      	blx	r8
					uxListRemove( &( pxTCB->xGenericListItem ) );
   81174:	1d2f      	adds	r7, r5, #4
   81176:	4638      	mov	r0, r7
   81178:	47c0      	blx	r8
					prvAddTaskToReadyQueue( pxTCB );
   8117a:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
   8117c:	f8d6 2110 	ldr.w	r2, [r6, #272]	; 0x110
   81180:	4293      	cmp	r3, r2
   81182:	d901      	bls.n	81188 <xTaskResumeAll+0x64>
   81184:	f8c6 3110 	str.w	r3, [r6, #272]	; 0x110
   81188:	4e1c      	ldr	r6, [pc, #112]	; (811fc <xTaskResumeAll+0xd8>)
   8118a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   8118e:	0098      	lsls	r0, r3, #2
   81190:	4639      	mov	r1, r7
   81192:	4430      	add	r0, r6
   81194:	4b1c      	ldr	r3, [pc, #112]	; (81208 <xTaskResumeAll+0xe4>)
   81196:	4798      	blx	r3
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   81198:	6aea      	ldr	r2, [r5, #44]	; 0x2c
   8119a:	f8d6 30d0 	ldr.w	r3, [r6, #208]	; 0xd0
   8119e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   811a0:	429a      	cmp	r2, r3
   811a2:	d3da      	bcc.n	8115a <xTaskResumeAll+0x36>
						xYieldRequired = pdTRUE;
   811a4:	2401      	movs	r4, #1
   811a6:	e7d8      	b.n	8115a <xTaskResumeAll+0x36>
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
   811a8:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
   811aa:	4b18      	ldr	r3, [pc, #96]	; (8120c <xTaskResumeAll+0xe8>)
   811ac:	4798      	blx	r3
}
   811ae:	4620      	mov	r0, r4
   811b0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
   811b4:	4b11      	ldr	r3, [pc, #68]	; (811fc <xTaskResumeAll+0xd8>)
   811b6:	f8d3 3120 	ldr.w	r3, [r3, #288]	; 0x120
   811ba:	b9ab      	cbnz	r3, 811e8 <xTaskResumeAll+0xc4>
				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
   811bc:	b924      	cbnz	r4, 811c8 <xTaskResumeAll+0xa4>
   811be:	4b0f      	ldr	r3, [pc, #60]	; (811fc <xTaskResumeAll+0xd8>)
   811c0:	f8d3 3124 	ldr.w	r3, [r3, #292]	; 0x124
   811c4:	2b01      	cmp	r3, #1
   811c6:	d1f0      	bne.n	811aa <xTaskResumeAll+0x86>
					xMissedYield = pdFALSE;
   811c8:	2200      	movs	r2, #0
   811ca:	4b0c      	ldr	r3, [pc, #48]	; (811fc <xTaskResumeAll+0xd8>)
   811cc:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
					portYIELD_WITHIN_API();
   811d0:	4b0f      	ldr	r3, [pc, #60]	; (81210 <xTaskResumeAll+0xec>)
   811d2:	4798      	blx	r3
					xAlreadyYielded = pdTRUE;
   811d4:	2401      	movs	r4, #1
   811d6:	e7e8      	b.n	811aa <xTaskResumeAll+0x86>
						vTaskIncrementTick();
   811d8:	4b0e      	ldr	r3, [pc, #56]	; (81214 <xTaskResumeAll+0xf0>)
   811da:	4798      	blx	r3
						--uxMissedTicks;
   811dc:	4a07      	ldr	r2, [pc, #28]	; (811fc <xTaskResumeAll+0xd8>)
   811de:	f8d2 3120 	ldr.w	r3, [r2, #288]	; 0x120
   811e2:	3b01      	subs	r3, #1
   811e4:	f8c2 3120 	str.w	r3, [r2, #288]	; 0x120
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
   811e8:	4b04      	ldr	r3, [pc, #16]	; (811fc <xTaskResumeAll+0xd8>)
   811ea:	f8d3 3120 	ldr.w	r3, [r3, #288]	; 0x120
   811ee:	2b00      	cmp	r3, #0
   811f0:	d1f2      	bne.n	811d8 <xTaskResumeAll+0xb4>
						xYieldRequired = pdTRUE;
   811f2:	2401      	movs	r4, #1
   811f4:	e7e2      	b.n	811bc <xTaskResumeAll+0x98>
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
   811f6:	2400      	movs	r4, #0
   811f8:	e7d7      	b.n	811aa <xTaskResumeAll+0x86>
   811fa:	bf00      	nop
   811fc:	2000a46c 	.word	0x2000a46c
   81200:	00080485 	.word	0x00080485
   81204:	00080495 	.word	0x00080495
   81208:	000803ad 	.word	0x000803ad
   8120c:	000804b5 	.word	0x000804b5
   81210:	00080475 	.word	0x00080475
   81214:	0008101d 	.word	0x0008101d
   81218:	000803fd 	.word	0x000803fd

0008121c <vTaskDelayUntil>:
	{
   8121c:	b538      	push	{r3, r4, r5, lr}
		configASSERT( pxPreviousWakeTime );
   8121e:	b130      	cbz	r0, 8122e <vTaskDelayUntil+0x12>
   81220:	460c      	mov	r4, r1
   81222:	4605      	mov	r5, r0
		configASSERT( ( xTimeIncrement > 0U ) );
   81224:	b939      	cbnz	r1, 81236 <vTaskDelayUntil+0x1a>
   81226:	4b1e      	ldr	r3, [pc, #120]	; (812a0 <vTaskDelayUntil+0x84>)
   81228:	4798      	blx	r3
   8122a:	bf00      	nop
   8122c:	e7fd      	b.n	8122a <vTaskDelayUntil+0xe>
		configASSERT( pxPreviousWakeTime );
   8122e:	4b1c      	ldr	r3, [pc, #112]	; (812a0 <vTaskDelayUntil+0x84>)
   81230:	4798      	blx	r3
   81232:	bf00      	nop
   81234:	e7fd      	b.n	81232 <vTaskDelayUntil+0x16>
		vTaskSuspendAll();
   81236:	4b1b      	ldr	r3, [pc, #108]	; (812a4 <vTaskDelayUntil+0x88>)
   81238:	4798      	blx	r3
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
   8123a:	682b      	ldr	r3, [r5, #0]
   8123c:	441c      	add	r4, r3
			if( xTickCount < *pxPreviousWakeTime )
   8123e:	4a1a      	ldr	r2, [pc, #104]	; (812a8 <vTaskDelayUntil+0x8c>)
   81240:	f8d2 20d4 	ldr.w	r2, [r2, #212]	; 0xd4
   81244:	4293      	cmp	r3, r2
   81246:	d90d      	bls.n	81264 <vTaskDelayUntil+0x48>
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
   81248:	42a3      	cmp	r3, r4
   8124a:	d914      	bls.n	81276 <vTaskDelayUntil+0x5a>
   8124c:	4b16      	ldr	r3, [pc, #88]	; (812a8 <vTaskDelayUntil+0x8c>)
   8124e:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
   81252:	429c      	cmp	r4, r3
   81254:	d811      	bhi.n	8127a <vTaskDelayUntil+0x5e>
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
   81256:	2300      	movs	r3, #0
			*pxPreviousWakeTime = xTimeToWake;
   81258:	602c      	str	r4, [r5, #0]
			if( xShouldDelay != pdFALSE )
   8125a:	b9a3      	cbnz	r3, 81286 <vTaskDelayUntil+0x6a>
		xAlreadyYielded = xTaskResumeAll();
   8125c:	4b13      	ldr	r3, [pc, #76]	; (812ac <vTaskDelayUntil+0x90>)
   8125e:	4798      	blx	r3
		if( xAlreadyYielded == pdFALSE )
   81260:	b1d8      	cbz	r0, 8129a <vTaskDelayUntil+0x7e>
   81262:	bd38      	pop	{r3, r4, r5, pc}
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
   81264:	42a3      	cmp	r3, r4
   81266:	d80a      	bhi.n	8127e <vTaskDelayUntil+0x62>
   81268:	4b0f      	ldr	r3, [pc, #60]	; (812a8 <vTaskDelayUntil+0x8c>)
   8126a:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
   8126e:	429c      	cmp	r4, r3
   81270:	d807      	bhi.n	81282 <vTaskDelayUntil+0x66>
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
   81272:	2300      	movs	r3, #0
   81274:	e7f0      	b.n	81258 <vTaskDelayUntil+0x3c>
   81276:	2300      	movs	r3, #0
   81278:	e7ee      	b.n	81258 <vTaskDelayUntil+0x3c>
					xShouldDelay = pdTRUE;
   8127a:	2301      	movs	r3, #1
   8127c:	e7ec      	b.n	81258 <vTaskDelayUntil+0x3c>
					xShouldDelay = pdTRUE;
   8127e:	2301      	movs	r3, #1
   81280:	e7ea      	b.n	81258 <vTaskDelayUntil+0x3c>
   81282:	2301      	movs	r3, #1
   81284:	e7e8      	b.n	81258 <vTaskDelayUntil+0x3c>
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
   81286:	4b08      	ldr	r3, [pc, #32]	; (812a8 <vTaskDelayUntil+0x8c>)
   81288:	f8d3 00d0 	ldr.w	r0, [r3, #208]	; 0xd0
   8128c:	3004      	adds	r0, #4
   8128e:	4b08      	ldr	r3, [pc, #32]	; (812b0 <vTaskDelayUntil+0x94>)
   81290:	4798      	blx	r3
				prvAddCurrentTaskToDelayedList( xTimeToWake );
   81292:	4620      	mov	r0, r4
   81294:	4b07      	ldr	r3, [pc, #28]	; (812b4 <vTaskDelayUntil+0x98>)
   81296:	4798      	blx	r3
   81298:	e7e0      	b.n	8125c <vTaskDelayUntil+0x40>
			portYIELD_WITHIN_API();
   8129a:	4b07      	ldr	r3, [pc, #28]	; (812b8 <vTaskDelayUntil+0x9c>)
   8129c:	4798      	blx	r3
	}
   8129e:	e7e0      	b.n	81262 <vTaskDelayUntil+0x46>
   812a0:	00080485 	.word	0x00080485
   812a4:	00080fe9 	.word	0x00080fe9
   812a8:	2000a46c 	.word	0x2000a46c
   812ac:	00081125 	.word	0x00081125
   812b0:	000803fd 	.word	0x000803fd
   812b4:	00080dd9 	.word	0x00080dd9
   812b8:	00080475 	.word	0x00080475

000812bc <prvCheckTasksWaitingTermination>:
{
   812bc:	b538      	push	{r3, r4, r5, lr}
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
   812be:	4b13      	ldr	r3, [pc, #76]	; (8130c <prvCheckTasksWaitingTermination+0x50>)
   812c0:	f8d3 3114 	ldr.w	r3, [r3, #276]	; 0x114
   812c4:	b30b      	cbz	r3, 8130a <prvCheckTasksWaitingTermination+0x4e>
			vTaskSuspendAll();
   812c6:	4b12      	ldr	r3, [pc, #72]	; (81310 <prvCheckTasksWaitingTermination+0x54>)
   812c8:	4798      	blx	r3
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
   812ca:	4b10      	ldr	r3, [pc, #64]	; (8130c <prvCheckTasksWaitingTermination+0x50>)
   812cc:	f8d3 40a0 	ldr.w	r4, [r3, #160]	; 0xa0
			xTaskResumeAll();
   812d0:	4b10      	ldr	r3, [pc, #64]	; (81314 <prvCheckTasksWaitingTermination+0x58>)
   812d2:	4798      	blx	r3
			if( xListIsEmpty == pdFALSE )
   812d4:	2c00      	cmp	r4, #0
   812d6:	d0f2      	beq.n	812be <prvCheckTasksWaitingTermination+0x2>
				taskENTER_CRITICAL();
   812d8:	4b0f      	ldr	r3, [pc, #60]	; (81318 <prvCheckTasksWaitingTermination+0x5c>)
   812da:	4798      	blx	r3
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
   812dc:	4c0b      	ldr	r4, [pc, #44]	; (8130c <prvCheckTasksWaitingTermination+0x50>)
   812de:	f8d4 30ac 	ldr.w	r3, [r4, #172]	; 0xac
   812e2:	68dd      	ldr	r5, [r3, #12]
					uxListRemove( &( pxTCB->xGenericListItem ) );
   812e4:	1d28      	adds	r0, r5, #4
   812e6:	4b0d      	ldr	r3, [pc, #52]	; (8131c <prvCheckTasksWaitingTermination+0x60>)
   812e8:	4798      	blx	r3
					--uxCurrentNumberOfTasks;
   812ea:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
   812ee:	3b01      	subs	r3, #1
   812f0:	f8c4 3100 	str.w	r3, [r4, #256]	; 0x100
					--uxTasksDeleted;
   812f4:	f8d4 3114 	ldr.w	r3, [r4, #276]	; 0x114
   812f8:	3b01      	subs	r3, #1
   812fa:	f8c4 3114 	str.w	r3, [r4, #276]	; 0x114
				taskEXIT_CRITICAL();
   812fe:	4b08      	ldr	r3, [pc, #32]	; (81320 <prvCheckTasksWaitingTermination+0x64>)
   81300:	4798      	blx	r3
				prvDeleteTCB( pxTCB );
   81302:	4628      	mov	r0, r5
   81304:	4b07      	ldr	r3, [pc, #28]	; (81324 <prvCheckTasksWaitingTermination+0x68>)
   81306:	4798      	blx	r3
   81308:	e7d9      	b.n	812be <prvCheckTasksWaitingTermination+0x2>
}
   8130a:	bd38      	pop	{r3, r4, r5, pc}
   8130c:	2000a46c 	.word	0x2000a46c
   81310:	00080fe9 	.word	0x00080fe9
   81314:	00081125 	.word	0x00081125
   81318:	00080495 	.word	0x00080495
   8131c:	000803fd 	.word	0x000803fd
   81320:	000804b5 	.word	0x000804b5
   81324:	00080cf1 	.word	0x00080cf1

00081328 <prvIdleTask>:
{
   81328:	b508      	push	{r3, lr}
		prvCheckTasksWaitingTermination();
   8132a:	4b04      	ldr	r3, [pc, #16]	; (8133c <prvIdleTask+0x14>)
   8132c:	4798      	blx	r3
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
   8132e:	4b04      	ldr	r3, [pc, #16]	; (81340 <prvIdleTask+0x18>)
   81330:	681b      	ldr	r3, [r3, #0]
   81332:	2b01      	cmp	r3, #1
   81334:	d9f9      	bls.n	8132a <prvIdleTask+0x2>
				taskYIELD();
   81336:	4b03      	ldr	r3, [pc, #12]	; (81344 <prvIdleTask+0x1c>)
   81338:	4798      	blx	r3
   8133a:	e7f6      	b.n	8132a <prvIdleTask+0x2>
   8133c:	000812bd 	.word	0x000812bd
   81340:	2000a46c 	.word	0x2000a46c
   81344:	00080475 	.word	0x00080475

00081348 <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
   81348:	4b20      	ldr	r3, [pc, #128]	; (813cc <vTaskSwitchContext+0x84>)
   8134a:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
   8134e:	b99b      	cbnz	r3, 81378 <vTaskSwitchContext+0x30>
{
   81350:	b510      	push	{r4, lr}
		taskSELECT_HIGHEST_PRIORITY_TASK();
   81352:	491e      	ldr	r1, [pc, #120]	; (813cc <vTaskSwitchContext+0x84>)
   81354:	f8d1 3110 	ldr.w	r3, [r1, #272]	; 0x110
   81358:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   8135c:	009a      	lsls	r2, r3, #2
   8135e:	588b      	ldr	r3, [r1, r2]
   81360:	b99b      	cbnz	r3, 8138a <vTaskSwitchContext+0x42>
   81362:	4b1a      	ldr	r3, [pc, #104]	; (813cc <vTaskSwitchContext+0x84>)
   81364:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
   81368:	b15b      	cbz	r3, 81382 <vTaskSwitchContext+0x3a>
   8136a:	4a18      	ldr	r2, [pc, #96]	; (813cc <vTaskSwitchContext+0x84>)
   8136c:	f8d2 3110 	ldr.w	r3, [r2, #272]	; 0x110
   81370:	3b01      	subs	r3, #1
   81372:	f8c2 3110 	str.w	r3, [r2, #272]	; 0x110
   81376:	e7ec      	b.n	81352 <vTaskSwitchContext+0xa>
		xMissedYield = pdTRUE;
   81378:	2201      	movs	r2, #1
   8137a:	4b14      	ldr	r3, [pc, #80]	; (813cc <vTaskSwitchContext+0x84>)
   8137c:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
   81380:	4770      	bx	lr
		taskSELECT_HIGHEST_PRIORITY_TASK();
   81382:	4b13      	ldr	r3, [pc, #76]	; (813d0 <vTaskSwitchContext+0x88>)
   81384:	4798      	blx	r3
   81386:	bf00      	nop
   81388:	e7fd      	b.n	81386 <vTaskSwitchContext+0x3e>
   8138a:	460a      	mov	r2, r1
   8138c:	f8d1 3110 	ldr.w	r3, [r1, #272]	; 0x110
   81390:	0099      	lsls	r1, r3, #2
   81392:	18cc      	adds	r4, r1, r3
   81394:	00a0      	lsls	r0, r4, #2
   81396:	4410      	add	r0, r2
   81398:	6844      	ldr	r4, [r0, #4]
   8139a:	6864      	ldr	r4, [r4, #4]
   8139c:	6044      	str	r4, [r0, #4]
   8139e:	4419      	add	r1, r3
   813a0:	0088      	lsls	r0, r1, #2
   813a2:	4601      	mov	r1, r0
   813a4:	3008      	adds	r0, #8
   813a6:	4402      	add	r2, r0
   813a8:	4294      	cmp	r4, r2
   813aa:	d009      	beq.n	813c0 <vTaskSwitchContext+0x78>
   813ac:	4907      	ldr	r1, [pc, #28]	; (813cc <vTaskSwitchContext+0x84>)
   813ae:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   813b2:	009a      	lsls	r2, r3, #2
   813b4:	440a      	add	r2, r1
   813b6:	6853      	ldr	r3, [r2, #4]
   813b8:	68db      	ldr	r3, [r3, #12]
   813ba:	f8c1 30d0 	str.w	r3, [r1, #208]	; 0xd0
   813be:	bd10      	pop	{r4, pc}
   813c0:	6860      	ldr	r0, [r4, #4]
   813c2:	4a02      	ldr	r2, [pc, #8]	; (813cc <vTaskSwitchContext+0x84>)
   813c4:	440a      	add	r2, r1
   813c6:	6050      	str	r0, [r2, #4]
   813c8:	e7f0      	b.n	813ac <vTaskSwitchContext+0x64>
   813ca:	bf00      	nop
   813cc:	2000a46c 	.word	0x2000a46c
   813d0:	00080485 	.word	0x00080485

000813d4 <vTaskPlaceOnEventList>:
{
   813d4:	b538      	push	{r3, r4, r5, lr}
	configASSERT( pxEventList );
   813d6:	b1a8      	cbz	r0, 81404 <vTaskPlaceOnEventList+0x30>
   813d8:	460c      	mov	r4, r1
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
   813da:	4d10      	ldr	r5, [pc, #64]	; (8141c <vTaskPlaceOnEventList+0x48>)
   813dc:	f8d5 10d0 	ldr.w	r1, [r5, #208]	; 0xd0
   813e0:	3118      	adds	r1, #24
   813e2:	4b0f      	ldr	r3, [pc, #60]	; (81420 <vTaskPlaceOnEventList+0x4c>)
   813e4:	4798      	blx	r3
	if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
   813e6:	f8d5 00d0 	ldr.w	r0, [r5, #208]	; 0xd0
   813ea:	3004      	adds	r0, #4
   813ec:	4b0d      	ldr	r3, [pc, #52]	; (81424 <vTaskPlaceOnEventList+0x50>)
   813ee:	4798      	blx	r3
		if( xTicksToWait == portMAX_DELAY )
   813f0:	f1b4 3fff 	cmp.w	r4, #4294967295
   813f4:	d00a      	beq.n	8140c <vTaskPlaceOnEventList+0x38>
			xTimeToWake = xTickCount + xTicksToWait;
   813f6:	4b09      	ldr	r3, [pc, #36]	; (8141c <vTaskPlaceOnEventList+0x48>)
   813f8:	f8d3 00d4 	ldr.w	r0, [r3, #212]	; 0xd4
			prvAddCurrentTaskToDelayedList( xTimeToWake );
   813fc:	4420      	add	r0, r4
   813fe:	4b0a      	ldr	r3, [pc, #40]	; (81428 <vTaskPlaceOnEventList+0x54>)
   81400:	4798      	blx	r3
   81402:	bd38      	pop	{r3, r4, r5, pc}
	configASSERT( pxEventList );
   81404:	4b09      	ldr	r3, [pc, #36]	; (8142c <vTaskPlaceOnEventList+0x58>)
   81406:	4798      	blx	r3
   81408:	bf00      	nop
   8140a:	e7fd      	b.n	81408 <vTaskPlaceOnEventList+0x34>
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
   8140c:	4628      	mov	r0, r5
   8140e:	f8d5 10d0 	ldr.w	r1, [r5, #208]	; 0xd0
   81412:	3104      	adds	r1, #4
   81414:	30b4      	adds	r0, #180	; 0xb4
   81416:	4b06      	ldr	r3, [pc, #24]	; (81430 <vTaskPlaceOnEventList+0x5c>)
   81418:	4798      	blx	r3
   8141a:	bd38      	pop	{r3, r4, r5, pc}
   8141c:	2000a46c 	.word	0x2000a46c
   81420:	000803c9 	.word	0x000803c9
   81424:	000803fd 	.word	0x000803fd
   81428:	00080dd9 	.word	0x00080dd9
   8142c:	00080485 	.word	0x00080485
   81430:	000803ad 	.word	0x000803ad

00081434 <vTaskPlaceOnEventListRestricted>:
	{
   81434:	b538      	push	{r3, r4, r5, lr}
		configASSERT( pxEventList );
   81436:	b188      	cbz	r0, 8145c <vTaskPlaceOnEventListRestricted+0x28>
   81438:	460d      	mov	r5, r1
		vListInsertEnd( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
   8143a:	4c0a      	ldr	r4, [pc, #40]	; (81464 <vTaskPlaceOnEventListRestricted+0x30>)
   8143c:	f8d4 10d0 	ldr.w	r1, [r4, #208]	; 0xd0
   81440:	3118      	adds	r1, #24
   81442:	4b09      	ldr	r3, [pc, #36]	; (81468 <vTaskPlaceOnEventListRestricted+0x34>)
   81444:	4798      	blx	r3
		if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
   81446:	f8d4 00d0 	ldr.w	r0, [r4, #208]	; 0xd0
   8144a:	3004      	adds	r0, #4
   8144c:	4b07      	ldr	r3, [pc, #28]	; (8146c <vTaskPlaceOnEventListRestricted+0x38>)
   8144e:	4798      	blx	r3
		xTimeToWake = xTickCount + xTicksToWait;
   81450:	f8d4 00d4 	ldr.w	r0, [r4, #212]	; 0xd4
		prvAddCurrentTaskToDelayedList( xTimeToWake );
   81454:	4428      	add	r0, r5
   81456:	4b06      	ldr	r3, [pc, #24]	; (81470 <vTaskPlaceOnEventListRestricted+0x3c>)
   81458:	4798      	blx	r3
   8145a:	bd38      	pop	{r3, r4, r5, pc}
		configASSERT( pxEventList );
   8145c:	4b05      	ldr	r3, [pc, #20]	; (81474 <vTaskPlaceOnEventListRestricted+0x40>)
   8145e:	4798      	blx	r3
   81460:	bf00      	nop
   81462:	e7fd      	b.n	81460 <vTaskPlaceOnEventListRestricted+0x2c>
   81464:	2000a46c 	.word	0x2000a46c
   81468:	000803ad 	.word	0x000803ad
   8146c:	000803fd 	.word	0x000803fd
   81470:	00080dd9 	.word	0x00080dd9
   81474:	00080485 	.word	0x00080485

00081478 <xTaskRemoveFromEventList>:
{
   81478:	b538      	push	{r3, r4, r5, lr}
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
   8147a:	68c3      	ldr	r3, [r0, #12]
   8147c:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
   8147e:	b334      	cbz	r4, 814ce <xTaskRemoveFromEventList+0x56>
	uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
   81480:	f104 0518 	add.w	r5, r4, #24
   81484:	4628      	mov	r0, r5
   81486:	4b17      	ldr	r3, [pc, #92]	; (814e4 <xTaskRemoveFromEventList+0x6c>)
   81488:	4798      	blx	r3
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
   8148a:	4b17      	ldr	r3, [pc, #92]	; (814e8 <xTaskRemoveFromEventList+0x70>)
   8148c:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
   81490:	bb0b      	cbnz	r3, 814d6 <xTaskRemoveFromEventList+0x5e>
		uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
   81492:	1d25      	adds	r5, r4, #4
   81494:	4628      	mov	r0, r5
   81496:	4b13      	ldr	r3, [pc, #76]	; (814e4 <xTaskRemoveFromEventList+0x6c>)
   81498:	4798      	blx	r3
		prvAddTaskToReadyQueue( pxUnblockedTCB );
   8149a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   8149c:	4a12      	ldr	r2, [pc, #72]	; (814e8 <xTaskRemoveFromEventList+0x70>)
   8149e:	f8d2 2110 	ldr.w	r2, [r2, #272]	; 0x110
   814a2:	4293      	cmp	r3, r2
   814a4:	d902      	bls.n	814ac <xTaskRemoveFromEventList+0x34>
   814a6:	4a10      	ldr	r2, [pc, #64]	; (814e8 <xTaskRemoveFromEventList+0x70>)
   814a8:	f8c2 3110 	str.w	r3, [r2, #272]	; 0x110
   814ac:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   814b0:	009a      	lsls	r2, r3, #2
   814b2:	4629      	mov	r1, r5
   814b4:	480c      	ldr	r0, [pc, #48]	; (814e8 <xTaskRemoveFromEventList+0x70>)
   814b6:	4410      	add	r0, r2
   814b8:	4b0c      	ldr	r3, [pc, #48]	; (814ec <xTaskRemoveFromEventList+0x74>)
   814ba:	4798      	blx	r3
	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
   814bc:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   814be:	4b0a      	ldr	r3, [pc, #40]	; (814e8 <xTaskRemoveFromEventList+0x70>)
   814c0:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
   814c4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   814c6:	429a      	cmp	r2, r3
   814c8:	d20a      	bcs.n	814e0 <xTaskRemoveFromEventList+0x68>
		xReturn = pdFALSE;
   814ca:	2000      	movs	r0, #0
}
   814cc:	bd38      	pop	{r3, r4, r5, pc}
	configASSERT( pxUnblockedTCB );
   814ce:	4b08      	ldr	r3, [pc, #32]	; (814f0 <xTaskRemoveFromEventList+0x78>)
   814d0:	4798      	blx	r3
   814d2:	bf00      	nop
   814d4:	e7fd      	b.n	814d2 <xTaskRemoveFromEventList+0x5a>
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
   814d6:	4629      	mov	r1, r5
   814d8:	4806      	ldr	r0, [pc, #24]	; (814f4 <xTaskRemoveFromEventList+0x7c>)
   814da:	4b04      	ldr	r3, [pc, #16]	; (814ec <xTaskRemoveFromEventList+0x74>)
   814dc:	4798      	blx	r3
   814de:	e7ed      	b.n	814bc <xTaskRemoveFromEventList+0x44>
		xReturn = pdTRUE;
   814e0:	2001      	movs	r0, #1
   814e2:	bd38      	pop	{r3, r4, r5, pc}
   814e4:	000803fd 	.word	0x000803fd
   814e8:	2000a46c 	.word	0x2000a46c
   814ec:	000803ad 	.word	0x000803ad
   814f0:	00080485 	.word	0x00080485
   814f4:	2000a4f8 	.word	0x2000a4f8

000814f8 <vTaskSetTimeOutState>:
{
   814f8:	b508      	push	{r3, lr}
	configASSERT( pxTimeOut );
   814fa:	b138      	cbz	r0, 8150c <vTaskSetTimeOutState+0x14>
	pxTimeOut->xOverflowCount = xNumOfOverflows;
   814fc:	4a05      	ldr	r2, [pc, #20]	; (81514 <vTaskSetTimeOutState+0x1c>)
   814fe:	f8d2 111c 	ldr.w	r1, [r2, #284]	; 0x11c
   81502:	6001      	str	r1, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
   81504:	f8d2 20d4 	ldr.w	r2, [r2, #212]	; 0xd4
   81508:	6042      	str	r2, [r0, #4]
   8150a:	bd08      	pop	{r3, pc}
	configASSERT( pxTimeOut );
   8150c:	4b02      	ldr	r3, [pc, #8]	; (81518 <vTaskSetTimeOutState+0x20>)
   8150e:	4798      	blx	r3
   81510:	bf00      	nop
   81512:	e7fd      	b.n	81510 <vTaskSetTimeOutState+0x18>
   81514:	2000a46c 	.word	0x2000a46c
   81518:	00080485 	.word	0x00080485

0008151c <xTaskCheckForTimeOut>:
{
   8151c:	b538      	push	{r3, r4, r5, lr}
	configASSERT( pxTimeOut );
   8151e:	b300      	cbz	r0, 81562 <xTaskCheckForTimeOut+0x46>
   81520:	460d      	mov	r5, r1
   81522:	4604      	mov	r4, r0
	configASSERT( pxTicksToWait );
   81524:	b309      	cbz	r1, 8156a <xTaskCheckForTimeOut+0x4e>
	taskENTER_CRITICAL();
   81526:	4b1a      	ldr	r3, [pc, #104]	; (81590 <xTaskCheckForTimeOut+0x74>)
   81528:	4798      	blx	r3
			if( *pxTicksToWait == portMAX_DELAY )
   8152a:	682b      	ldr	r3, [r5, #0]
   8152c:	f1b3 3fff 	cmp.w	r3, #4294967295
   81530:	d02a      	beq.n	81588 <xTaskCheckForTimeOut+0x6c>
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
   81532:	6821      	ldr	r1, [r4, #0]
   81534:	4a17      	ldr	r2, [pc, #92]	; (81594 <xTaskCheckForTimeOut+0x78>)
   81536:	f8d2 211c 	ldr.w	r2, [r2, #284]	; 0x11c
   8153a:	4291      	cmp	r1, r2
   8153c:	d005      	beq.n	8154a <xTaskCheckForTimeOut+0x2e>
   8153e:	6861      	ldr	r1, [r4, #4]
   81540:	4a14      	ldr	r2, [pc, #80]	; (81594 <xTaskCheckForTimeOut+0x78>)
   81542:	f8d2 20d4 	ldr.w	r2, [r2, #212]	; 0xd4
   81546:	4291      	cmp	r1, r2
   81548:	d920      	bls.n	8158c <xTaskCheckForTimeOut+0x70>
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
   8154a:	4a12      	ldr	r2, [pc, #72]	; (81594 <xTaskCheckForTimeOut+0x78>)
   8154c:	f8d2 20d4 	ldr.w	r2, [r2, #212]	; 0xd4
   81550:	6861      	ldr	r1, [r4, #4]
   81552:	1a52      	subs	r2, r2, r1
   81554:	4293      	cmp	r3, r2
   81556:	d80c      	bhi.n	81572 <xTaskCheckForTimeOut+0x56>
			xReturn = pdTRUE;
   81558:	2401      	movs	r4, #1
	taskEXIT_CRITICAL();
   8155a:	4b0f      	ldr	r3, [pc, #60]	; (81598 <xTaskCheckForTimeOut+0x7c>)
   8155c:	4798      	blx	r3
}
   8155e:	4620      	mov	r0, r4
   81560:	bd38      	pop	{r3, r4, r5, pc}
	configASSERT( pxTimeOut );
   81562:	4b0e      	ldr	r3, [pc, #56]	; (8159c <xTaskCheckForTimeOut+0x80>)
   81564:	4798      	blx	r3
   81566:	bf00      	nop
   81568:	e7fd      	b.n	81566 <xTaskCheckForTimeOut+0x4a>
	configASSERT( pxTicksToWait );
   8156a:	4b0c      	ldr	r3, [pc, #48]	; (8159c <xTaskCheckForTimeOut+0x80>)
   8156c:	4798      	blx	r3
   8156e:	bf00      	nop
   81570:	e7fd      	b.n	8156e <xTaskCheckForTimeOut+0x52>
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
   81572:	4a08      	ldr	r2, [pc, #32]	; (81594 <xTaskCheckForTimeOut+0x78>)
   81574:	f8d2 20d4 	ldr.w	r2, [r2, #212]	; 0xd4
   81578:	1a52      	subs	r2, r2, r1
   8157a:	1a9b      	subs	r3, r3, r2
   8157c:	602b      	str	r3, [r5, #0]
			vTaskSetTimeOutState( pxTimeOut );
   8157e:	4620      	mov	r0, r4
   81580:	4b07      	ldr	r3, [pc, #28]	; (815a0 <xTaskCheckForTimeOut+0x84>)
   81582:	4798      	blx	r3
			xReturn = pdFALSE;
   81584:	2400      	movs	r4, #0
   81586:	e7e8      	b.n	8155a <xTaskCheckForTimeOut+0x3e>
				xReturn = pdFALSE;
   81588:	2400      	movs	r4, #0
   8158a:	e7e6      	b.n	8155a <xTaskCheckForTimeOut+0x3e>
			xReturn = pdTRUE;
   8158c:	2401      	movs	r4, #1
   8158e:	e7e4      	b.n	8155a <xTaskCheckForTimeOut+0x3e>
   81590:	00080495 	.word	0x00080495
   81594:	2000a46c 	.word	0x2000a46c
   81598:	000804b5 	.word	0x000804b5
   8159c:	00080485 	.word	0x00080485
   815a0:	000814f9 	.word	0x000814f9

000815a4 <vTaskMissedYield>:
	xMissedYield = pdTRUE;
   815a4:	2201      	movs	r2, #1
   815a6:	4b02      	ldr	r3, [pc, #8]	; (815b0 <vTaskMissedYield+0xc>)
   815a8:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
   815ac:	4770      	bx	lr
   815ae:	bf00      	nop
   815b0:	2000a46c 	.word	0x2000a46c

000815b4 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
   815b4:	4b01      	ldr	r3, [pc, #4]	; (815bc <xTaskGetCurrentTaskHandle+0x8>)
   815b6:	f8d3 00d0 	ldr.w	r0, [r3, #208]	; 0xd0

		return xReturn;
	}
   815ba:	4770      	bx	lr
   815bc:	2000a46c 	.word	0x2000a46c

000815c0 <xTaskGetSchedulerState>:

	portBASE_TYPE xTaskGetSchedulerState( void )
	{
	portBASE_TYPE xReturn;

		if( xSchedulerRunning == pdFALSE )
   815c0:	4b06      	ldr	r3, [pc, #24]	; (815dc <xTaskGetSchedulerState+0x1c>)
   815c2:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
   815c6:	b13b      	cbz	r3, 815d8 <xTaskGetSchedulerState+0x18>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
   815c8:	4b04      	ldr	r3, [pc, #16]	; (815dc <xTaskGetSchedulerState+0x1c>)
   815ca:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
   815ce:	b10b      	cbz	r3, 815d4 <xTaskGetSchedulerState+0x14>
			{
				xReturn = taskSCHEDULER_RUNNING;
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
   815d0:	2002      	movs	r0, #2
			}
		}

		return xReturn;
	}
   815d2:	4770      	bx	lr
				xReturn = taskSCHEDULER_RUNNING;
   815d4:	2001      	movs	r0, #1
   815d6:	4770      	bx	lr
			xReturn = taskSCHEDULER_NOT_STARTED;
   815d8:	2000      	movs	r0, #0
   815da:	4770      	bx	lr
   815dc:	2000a46c 	.word	0x2000a46c

000815e0 <vTaskPriorityInherit>:
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
   815e0:	2800      	cmp	r0, #0
   815e2:	d035      	beq.n	81650 <vTaskPriorityInherit+0x70>
	{
   815e4:	b538      	push	{r3, r4, r5, lr}
   815e6:	4605      	mov	r5, r0
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
   815e8:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
   815ea:	491a      	ldr	r1, [pc, #104]	; (81654 <vTaskPriorityInherit+0x74>)
   815ec:	f8d1 10d0 	ldr.w	r1, [r1, #208]	; 0xd0
   815f0:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
   815f2:	428b      	cmp	r3, r1
   815f4:	d212      	bcs.n	8161c <vTaskPriorityInherit+0x3c>
			{
				/* Adjust the mutex holder state to account for its new priority. */
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
   815f6:	4917      	ldr	r1, [pc, #92]	; (81654 <vTaskPriorityInherit+0x74>)
   815f8:	f8d1 00d0 	ldr.w	r0, [r1, #208]	; 0xd0
   815fc:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
   815fe:	f1c0 0005 	rsb	r0, r0, #5
   81602:	61a8      	str	r0, [r5, #24]

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
   81604:	696c      	ldr	r4, [r5, #20]
   81606:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   8160a:	0098      	lsls	r0, r3, #2
   8160c:	4401      	add	r1, r0
   8160e:	428c      	cmp	r4, r1
   81610:	d005      	beq.n	8161e <vTaskPriorityInherit+0x3e>
					prvAddTaskToReadyQueue( pxTCB );
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
   81612:	4b10      	ldr	r3, [pc, #64]	; (81654 <vTaskPriorityInherit+0x74>)
   81614:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
   81618:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   8161a:	62eb      	str	r3, [r5, #44]	; 0x2c
   8161c:	bd38      	pop	{r3, r4, r5, pc}
					if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
   8161e:	1d2c      	adds	r4, r5, #4
   81620:	4620      	mov	r0, r4
   81622:	4b0d      	ldr	r3, [pc, #52]	; (81658 <vTaskPriorityInherit+0x78>)
   81624:	4798      	blx	r3
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
   81626:	4a0b      	ldr	r2, [pc, #44]	; (81654 <vTaskPriorityInherit+0x74>)
   81628:	f8d2 30d0 	ldr.w	r3, [r2, #208]	; 0xd0
   8162c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   8162e:	62eb      	str	r3, [r5, #44]	; 0x2c
					prvAddTaskToReadyQueue( pxTCB );
   81630:	f8d2 2110 	ldr.w	r2, [r2, #272]	; 0x110
   81634:	4293      	cmp	r3, r2
   81636:	d902      	bls.n	8163e <vTaskPriorityInherit+0x5e>
   81638:	4a06      	ldr	r2, [pc, #24]	; (81654 <vTaskPriorityInherit+0x74>)
   8163a:	f8c2 3110 	str.w	r3, [r2, #272]	; 0x110
   8163e:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   81642:	009a      	lsls	r2, r3, #2
   81644:	4621      	mov	r1, r4
   81646:	4803      	ldr	r0, [pc, #12]	; (81654 <vTaskPriorityInherit+0x74>)
   81648:	4410      	add	r0, r2
   8164a:	4b04      	ldr	r3, [pc, #16]	; (8165c <vTaskPriorityInherit+0x7c>)
   8164c:	4798      	blx	r3
   8164e:	bd38      	pop	{r3, r4, r5, pc}
   81650:	4770      	bx	lr
   81652:	bf00      	nop
   81654:	2000a46c 	.word	0x2000a46c
   81658:	000803fd 	.word	0x000803fd
   8165c:	000803ad 	.word	0x000803ad

00081660 <vTaskPriorityDisinherit>:

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
   81660:	b1f8      	cbz	r0, 816a2 <vTaskPriorityDisinherit+0x42>
	{
   81662:	b538      	push	{r3, r4, r5, lr}
   81664:	4604      	mov	r4, r0
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
   81666:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
   81668:	6c82      	ldr	r2, [r0, #72]	; 0x48
   8166a:	4291      	cmp	r1, r2
   8166c:	d018      	beq.n	816a0 <vTaskPriorityDisinherit+0x40>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
   8166e:	1d05      	adds	r5, r0, #4
   81670:	4628      	mov	r0, r5
   81672:	4b0c      	ldr	r3, [pc, #48]	; (816a4 <vTaskPriorityDisinherit+0x44>)
   81674:	4798      	blx	r3
				}

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
   81676:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   81678:	62e3      	str	r3, [r4, #44]	; 0x2c
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
   8167a:	f1c3 0205 	rsb	r2, r3, #5
   8167e:	61a2      	str	r2, [r4, #24]
				prvAddTaskToReadyQueue( pxTCB );
   81680:	4a09      	ldr	r2, [pc, #36]	; (816a8 <vTaskPriorityDisinherit+0x48>)
   81682:	f8d2 2110 	ldr.w	r2, [r2, #272]	; 0x110
   81686:	4293      	cmp	r3, r2
   81688:	d902      	bls.n	81690 <vTaskPriorityDisinherit+0x30>
   8168a:	4a07      	ldr	r2, [pc, #28]	; (816a8 <vTaskPriorityDisinherit+0x48>)
   8168c:	f8c2 3110 	str.w	r3, [r2, #272]	; 0x110
   81690:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   81694:	009a      	lsls	r2, r3, #2
   81696:	4629      	mov	r1, r5
   81698:	4803      	ldr	r0, [pc, #12]	; (816a8 <vTaskPriorityDisinherit+0x48>)
   8169a:	4410      	add	r0, r2
   8169c:	4b03      	ldr	r3, [pc, #12]	; (816ac <vTaskPriorityDisinherit+0x4c>)
   8169e:	4798      	blx	r3
   816a0:	bd38      	pop	{r3, r4, r5, pc}
   816a2:	4770      	bx	lr
   816a4:	000803fd 	.word	0x000803fd
   816a8:	2000a46c 	.word	0x2000a46c
   816ac:	000803ad 	.word	0x000803ad

000816b0 <prvGetNextExpireTime>:
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
   816b0:	4b06      	ldr	r3, [pc, #24]	; (816cc <prvGetNextExpireTime+0x1c>)
   816b2:	681a      	ldr	r2, [r3, #0]
   816b4:	6813      	ldr	r3, [r2, #0]
   816b6:	fab3 f383 	clz	r3, r3
   816ba:	095b      	lsrs	r3, r3, #5
   816bc:	6003      	str	r3, [r0, #0]
	if( *pxListWasEmpty == pdFALSE )
   816be:	b913      	cbnz	r3, 816c6 <prvGetNextExpireTime+0x16>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
   816c0:	68d3      	ldr	r3, [r2, #12]
   816c2:	6818      	ldr	r0, [r3, #0]
   816c4:	4770      	bx	lr
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( portTickType ) 0U;
   816c6:	2000      	movs	r0, #0
	}

	return xNextExpireTime;
}
   816c8:	4770      	bx	lr
   816ca:	bf00      	nop
   816cc:	2000a594 	.word	0x2000a594

000816d0 <prvInsertTimerInActiveList>:
	return xTimeNow;
}
/*-----------------------------------------------------------*/

static portBASE_TYPE prvInsertTimerInActiveList( xTIMER *pxTimer, portTickType xNextExpiryTime, portTickType xTimeNow, portTickType xCommandTime )
{
   816d0:	b508      	push	{r3, lr}
portBASE_TYPE xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
   816d2:	6041      	str	r1, [r0, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
   816d4:	6100      	str	r0, [r0, #16]

	if( xNextExpiryTime <= xTimeNow )
   816d6:	4291      	cmp	r1, r2
   816d8:	d80c      	bhi.n	816f4 <prvInsertTimerInActiveList+0x24>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( portTickType ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks )
   816da:	1ad2      	subs	r2, r2, r3
   816dc:	6983      	ldr	r3, [r0, #24]
   816de:	429a      	cmp	r2, r3
   816e0:	d301      	bcc.n	816e6 <prvInsertTimerInActiveList+0x16>
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
   816e2:	2001      	movs	r0, #1
   816e4:	bd08      	pop	{r3, pc}
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
   816e6:	1d01      	adds	r1, r0, #4
   816e8:	4b09      	ldr	r3, [pc, #36]	; (81710 <prvInsertTimerInActiveList+0x40>)
   816ea:	6858      	ldr	r0, [r3, #4]
   816ec:	4b09      	ldr	r3, [pc, #36]	; (81714 <prvInsertTimerInActiveList+0x44>)
   816ee:	4798      	blx	r3
portBASE_TYPE xProcessTimerNow = pdFALSE;
   816f0:	2000      	movs	r0, #0
   816f2:	bd08      	pop	{r3, pc}
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
   816f4:	429a      	cmp	r2, r3
   816f6:	d201      	bcs.n	816fc <prvInsertTimerInActiveList+0x2c>
   816f8:	4299      	cmp	r1, r3
   816fa:	d206      	bcs.n	8170a <prvInsertTimerInActiveList+0x3a>
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
   816fc:	1d01      	adds	r1, r0, #4
   816fe:	4b04      	ldr	r3, [pc, #16]	; (81710 <prvInsertTimerInActiveList+0x40>)
   81700:	6818      	ldr	r0, [r3, #0]
   81702:	4b04      	ldr	r3, [pc, #16]	; (81714 <prvInsertTimerInActiveList+0x44>)
   81704:	4798      	blx	r3
portBASE_TYPE xProcessTimerNow = pdFALSE;
   81706:	2000      	movs	r0, #0
   81708:	bd08      	pop	{r3, pc}
			xProcessTimerNow = pdTRUE;
   8170a:	2001      	movs	r0, #1
		}
	}

	return xProcessTimerNow;
}
   8170c:	bd08      	pop	{r3, pc}
   8170e:	bf00      	nop
   81710:	2000a594 	.word	0x2000a594
   81714:	000803c9 	.word	0x000803c9

00081718 <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
   81718:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
   8171a:	4b0d      	ldr	r3, [pc, #52]	; (81750 <prvCheckForValidListAndQueue+0x38>)
   8171c:	4798      	blx	r3
	{
		if( xTimerQueue == NULL )
   8171e:	4b0d      	ldr	r3, [pc, #52]	; (81754 <prvCheckForValidListAndQueue+0x3c>)
   81720:	689b      	ldr	r3, [r3, #8]
   81722:	b113      	cbz	r3, 8172a <prvCheckForValidListAndQueue+0x12>
			pxCurrentTimerList = &xActiveTimerList1;
			pxOverflowTimerList = &xActiveTimerList2;
			xTimerQueue = xQueueCreate( ( unsigned portBASE_TYPE ) configTIMER_QUEUE_LENGTH, sizeof( xTIMER_MESSAGE ) );
		}
	}
	taskEXIT_CRITICAL();
   81724:	4b0c      	ldr	r3, [pc, #48]	; (81758 <prvCheckForValidListAndQueue+0x40>)
   81726:	4798      	blx	r3
   81728:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			vListInitialise( &xActiveTimerList1 );
   8172a:	4c0a      	ldr	r4, [pc, #40]	; (81754 <prvCheckForValidListAndQueue+0x3c>)
   8172c:	f104 060c 	add.w	r6, r4, #12
   81730:	4630      	mov	r0, r6
   81732:	4f0a      	ldr	r7, [pc, #40]	; (8175c <prvCheckForValidListAndQueue+0x44>)
   81734:	47b8      	blx	r7
			vListInitialise( &xActiveTimerList2 );
   81736:	f104 0520 	add.w	r5, r4, #32
   8173a:	4628      	mov	r0, r5
   8173c:	47b8      	blx	r7
			pxCurrentTimerList = &xActiveTimerList1;
   8173e:	6026      	str	r6, [r4, #0]
			pxOverflowTimerList = &xActiveTimerList2;
   81740:	6065      	str	r5, [r4, #4]
			xTimerQueue = xQueueCreate( ( unsigned portBASE_TYPE ) configTIMER_QUEUE_LENGTH, sizeof( xTIMER_MESSAGE ) );
   81742:	2200      	movs	r2, #0
   81744:	210c      	movs	r1, #12
   81746:	2005      	movs	r0, #5
   81748:	4b05      	ldr	r3, [pc, #20]	; (81760 <prvCheckForValidListAndQueue+0x48>)
   8174a:	4798      	blx	r3
   8174c:	60a0      	str	r0, [r4, #8]
   8174e:	e7e9      	b.n	81724 <prvCheckForValidListAndQueue+0xc>
   81750:	00080495 	.word	0x00080495
   81754:	2000a594 	.word	0x2000a594
   81758:	000804b5 	.word	0x000804b5
   8175c:	00080391 	.word	0x00080391
   81760:	000808f5 	.word	0x000808f5

00081764 <xTimerCreateTimerTask>:
{
   81764:	b510      	push	{r4, lr}
   81766:	b084      	sub	sp, #16
	prvCheckForValidListAndQueue();
   81768:	4b0c      	ldr	r3, [pc, #48]	; (8179c <xTimerCreateTimerTask+0x38>)
   8176a:	4798      	blx	r3
	if( xTimerQueue != NULL )
   8176c:	4b0c      	ldr	r3, [pc, #48]	; (817a0 <xTimerCreateTimerTask+0x3c>)
   8176e:	689b      	ldr	r3, [r3, #8]
   81770:	b173      	cbz	r3, 81790 <xTimerCreateTimerTask+0x2c>
			xReturn = xTaskCreate( prvTimerTask, ( const signed char * ) "Tmr Svc", ( unsigned short ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( unsigned portBASE_TYPE ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, NULL);
   81772:	2300      	movs	r3, #0
   81774:	9303      	str	r3, [sp, #12]
   81776:	9302      	str	r3, [sp, #8]
   81778:	9301      	str	r3, [sp, #4]
   8177a:	2204      	movs	r2, #4
   8177c:	9200      	str	r2, [sp, #0]
   8177e:	f44f 7282 	mov.w	r2, #260	; 0x104
   81782:	4908      	ldr	r1, [pc, #32]	; (817a4 <xTimerCreateTimerTask+0x40>)
   81784:	4808      	ldr	r0, [pc, #32]	; (817a8 <xTimerCreateTimerTask+0x44>)
   81786:	4c09      	ldr	r4, [pc, #36]	; (817ac <xTimerCreateTimerTask+0x48>)
   81788:	47a0      	blx	r4
	configASSERT( xReturn );
   8178a:	b118      	cbz	r0, 81794 <xTimerCreateTimerTask+0x30>
}
   8178c:	b004      	add	sp, #16
   8178e:	bd10      	pop	{r4, pc}
portBASE_TYPE xReturn = pdFAIL;
   81790:	2000      	movs	r0, #0
   81792:	e7fa      	b.n	8178a <xTimerCreateTimerTask+0x26>
	configASSERT( xReturn );
   81794:	4b06      	ldr	r3, [pc, #24]	; (817b0 <xTimerCreateTimerTask+0x4c>)
   81796:	4798      	blx	r3
   81798:	bf00      	nop
   8179a:	e7fd      	b.n	81798 <xTimerCreateTimerTask+0x34>
   8179c:	00081719 	.word	0x00081719
   817a0:	2000a594 	.word	0x2000a594
   817a4:	000825a0 	.word	0x000825a0
   817a8:	00081a69 	.word	0x00081a69
   817ac:	00080e29 	.word	0x00080e29
   817b0:	00080485 	.word	0x00080485

000817b4 <xTimerGenericCommand>:
{
   817b4:	b530      	push	{r4, r5, lr}
   817b6:	b085      	sub	sp, #20
	if( xTimerQueue != NULL )
   817b8:	4c12      	ldr	r4, [pc, #72]	; (81804 <xTimerGenericCommand+0x50>)
   817ba:	68a5      	ldr	r5, [r4, #8]
   817bc:	b305      	cbz	r5, 81800 <xTimerGenericCommand+0x4c>
   817be:	461c      	mov	r4, r3
		xMessage.xMessageID = xCommandID;
   817c0:	9101      	str	r1, [sp, #4]
		xMessage.xMessageValue = xOptionalValue;
   817c2:	9202      	str	r2, [sp, #8]
		xMessage.pxTimer = ( xTIMER * ) xTimer;
   817c4:	9003      	str	r0, [sp, #12]
		if( pxHigherPriorityTaskWoken == NULL )
   817c6:	b13b      	cbz	r3, 817d8 <xTimerGenericCommand+0x24>
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
   817c8:	2300      	movs	r3, #0
   817ca:	4622      	mov	r2, r4
   817cc:	a901      	add	r1, sp, #4
   817ce:	4628      	mov	r0, r5
   817d0:	4c0d      	ldr	r4, [pc, #52]	; (81808 <xTimerGenericCommand+0x54>)
   817d2:	47a0      	blx	r4
}
   817d4:	b005      	add	sp, #20
   817d6:	bd30      	pop	{r4, r5, pc}
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
   817d8:	4b0c      	ldr	r3, [pc, #48]	; (8180c <xTimerGenericCommand+0x58>)
   817da:	4798      	blx	r3
   817dc:	2801      	cmp	r0, #1
   817de:	d007      	beq.n	817f0 <xTimerGenericCommand+0x3c>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
   817e0:	2300      	movs	r3, #0
   817e2:	461a      	mov	r2, r3
   817e4:	a901      	add	r1, sp, #4
   817e6:	4807      	ldr	r0, [pc, #28]	; (81804 <xTimerGenericCommand+0x50>)
   817e8:	6880      	ldr	r0, [r0, #8]
   817ea:	4c09      	ldr	r4, [pc, #36]	; (81810 <xTimerGenericCommand+0x5c>)
   817ec:	47a0      	blx	r4
   817ee:	e7f1      	b.n	817d4 <xTimerGenericCommand+0x20>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xBlockTime );
   817f0:	2300      	movs	r3, #0
   817f2:	9a08      	ldr	r2, [sp, #32]
   817f4:	a901      	add	r1, sp, #4
   817f6:	4803      	ldr	r0, [pc, #12]	; (81804 <xTimerGenericCommand+0x50>)
   817f8:	6880      	ldr	r0, [r0, #8]
   817fa:	4c05      	ldr	r4, [pc, #20]	; (81810 <xTimerGenericCommand+0x5c>)
   817fc:	47a0      	blx	r4
   817fe:	e7e9      	b.n	817d4 <xTimerGenericCommand+0x20>
portBASE_TYPE xReturn = pdFAIL;
   81800:	2000      	movs	r0, #0
	return xReturn;
   81802:	e7e7      	b.n	817d4 <xTimerGenericCommand+0x20>
   81804:	2000a594 	.word	0x2000a594
   81808:	00080a89 	.word	0x00080a89
   8180c:	000815c1 	.word	0x000815c1
   81810:	00080959 	.word	0x00080959

00081814 <prvSwitchTimerLists>:
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
   81814:	4b1e      	ldr	r3, [pc, #120]	; (81890 <prvSwitchTimerLists+0x7c>)
   81816:	681b      	ldr	r3, [r3, #0]
   81818:	681a      	ldr	r2, [r3, #0]
   8181a:	2a00      	cmp	r2, #0
   8181c:	d033      	beq.n	81886 <prvSwitchTimerLists+0x72>
{
   8181e:	b570      	push	{r4, r5, r6, lr}
   81820:	b082      	sub	sp, #8
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
   81822:	68da      	ldr	r2, [r3, #12]
   81824:	6816      	ldr	r6, [r2, #0]
		pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
   81826:	68db      	ldr	r3, [r3, #12]
   81828:	68dc      	ldr	r4, [r3, #12]
		uxListRemove( &( pxTimer->xTimerListItem ) );
   8182a:	1d25      	adds	r5, r4, #4
   8182c:	4628      	mov	r0, r5
   8182e:	4b19      	ldr	r3, [pc, #100]	; (81894 <prvSwitchTimerLists+0x80>)
   81830:	4798      	blx	r3
		pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
   81832:	6a63      	ldr	r3, [r4, #36]	; 0x24
   81834:	4620      	mov	r0, r4
   81836:	4798      	blx	r3
		if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
   81838:	69e3      	ldr	r3, [r4, #28]
   8183a:	2b01      	cmp	r3, #1
   8183c:	d00a      	beq.n	81854 <prvSwitchTimerLists+0x40>
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
   8183e:	4b14      	ldr	r3, [pc, #80]	; (81890 <prvSwitchTimerLists+0x7c>)
   81840:	681b      	ldr	r3, [r3, #0]
   81842:	681a      	ldr	r2, [r3, #0]
   81844:	2a00      	cmp	r2, #0
   81846:	d1ec      	bne.n	81822 <prvSwitchTimerLists+0xe>
	pxCurrentTimerList = pxOverflowTimerList;
   81848:	4a11      	ldr	r2, [pc, #68]	; (81890 <prvSwitchTimerLists+0x7c>)
   8184a:	6851      	ldr	r1, [r2, #4]
   8184c:	6011      	str	r1, [r2, #0]
	pxOverflowTimerList = pxTemp;
   8184e:	6053      	str	r3, [r2, #4]
}
   81850:	b002      	add	sp, #8
   81852:	bd70      	pop	{r4, r5, r6, pc}
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
   81854:	69a3      	ldr	r3, [r4, #24]
   81856:	4433      	add	r3, r6
			if( xReloadTime > xNextExpireTime )
   81858:	429e      	cmp	r6, r3
   8185a:	d207      	bcs.n	8186c <prvSwitchTimerLists+0x58>
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
   8185c:	6063      	str	r3, [r4, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
   8185e:	6124      	str	r4, [r4, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
   81860:	4629      	mov	r1, r5
   81862:	4b0b      	ldr	r3, [pc, #44]	; (81890 <prvSwitchTimerLists+0x7c>)
   81864:	6818      	ldr	r0, [r3, #0]
   81866:	4b0c      	ldr	r3, [pc, #48]	; (81898 <prvSwitchTimerLists+0x84>)
   81868:	4798      	blx	r3
   8186a:	e7e8      	b.n	8183e <prvSwitchTimerLists+0x2a>
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
   8186c:	2100      	movs	r1, #0
   8186e:	9100      	str	r1, [sp, #0]
   81870:	460b      	mov	r3, r1
   81872:	4632      	mov	r2, r6
   81874:	4620      	mov	r0, r4
   81876:	4c09      	ldr	r4, [pc, #36]	; (8189c <prvSwitchTimerLists+0x88>)
   81878:	47a0      	blx	r4
				configASSERT( xResult );
   8187a:	2800      	cmp	r0, #0
   8187c:	d1df      	bne.n	8183e <prvSwitchTimerLists+0x2a>
   8187e:	4b08      	ldr	r3, [pc, #32]	; (818a0 <prvSwitchTimerLists+0x8c>)
   81880:	4798      	blx	r3
   81882:	bf00      	nop
   81884:	e7fd      	b.n	81882 <prvSwitchTimerLists+0x6e>
	pxCurrentTimerList = pxOverflowTimerList;
   81886:	4a02      	ldr	r2, [pc, #8]	; (81890 <prvSwitchTimerLists+0x7c>)
   81888:	6851      	ldr	r1, [r2, #4]
   8188a:	6011      	str	r1, [r2, #0]
	pxOverflowTimerList = pxTemp;
   8188c:	6053      	str	r3, [r2, #4]
   8188e:	4770      	bx	lr
   81890:	2000a594 	.word	0x2000a594
   81894:	000803fd 	.word	0x000803fd
   81898:	000803c9 	.word	0x000803c9
   8189c:	000817b5 	.word	0x000817b5
   818a0:	00080485 	.word	0x00080485

000818a4 <prvSampleTimeNow>:
{
   818a4:	b538      	push	{r3, r4, r5, lr}
   818a6:	4605      	mov	r5, r0
	xTimeNow = xTaskGetTickCount();
   818a8:	4b08      	ldr	r3, [pc, #32]	; (818cc <prvSampleTimeNow+0x28>)
   818aa:	4798      	blx	r3
   818ac:	4604      	mov	r4, r0
	if( xTimeNow < xLastTime )
   818ae:	4b08      	ldr	r3, [pc, #32]	; (818d0 <prvSampleTimeNow+0x2c>)
   818b0:	6b58      	ldr	r0, [r3, #52]	; 0x34
   818b2:	4284      	cmp	r4, r0
   818b4:	d305      	bcc.n	818c2 <prvSampleTimeNow+0x1e>
		*pxTimerListsWereSwitched = pdFALSE;
   818b6:	2300      	movs	r3, #0
   818b8:	602b      	str	r3, [r5, #0]
	xLastTime = xTimeNow;
   818ba:	4b05      	ldr	r3, [pc, #20]	; (818d0 <prvSampleTimeNow+0x2c>)
   818bc:	635c      	str	r4, [r3, #52]	; 0x34
}
   818be:	4620      	mov	r0, r4
   818c0:	bd38      	pop	{r3, r4, r5, pc}
		prvSwitchTimerLists( xLastTime );
   818c2:	4b04      	ldr	r3, [pc, #16]	; (818d4 <prvSampleTimeNow+0x30>)
   818c4:	4798      	blx	r3
		*pxTimerListsWereSwitched = pdTRUE;
   818c6:	2301      	movs	r3, #1
   818c8:	602b      	str	r3, [r5, #0]
   818ca:	e7f6      	b.n	818ba <prvSampleTimeNow+0x16>
   818cc:	00080ffd 	.word	0x00080ffd
   818d0:	2000a594 	.word	0x2000a594
   818d4:	00081815 	.word	0x00081815

000818d8 <prvProcessExpiredTimer>:
{
   818d8:	b570      	push	{r4, r5, r6, lr}
   818da:	b082      	sub	sp, #8
   818dc:	4605      	mov	r5, r0
   818de:	460e      	mov	r6, r1
	pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
   818e0:	4b12      	ldr	r3, [pc, #72]	; (8192c <prvProcessExpiredTimer+0x54>)
   818e2:	681b      	ldr	r3, [r3, #0]
   818e4:	68db      	ldr	r3, [r3, #12]
   818e6:	68dc      	ldr	r4, [r3, #12]
	uxListRemove( &( pxTimer->xTimerListItem ) );
   818e8:	1d20      	adds	r0, r4, #4
   818ea:	4b11      	ldr	r3, [pc, #68]	; (81930 <prvProcessExpiredTimer+0x58>)
   818ec:	4798      	blx	r3
	if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
   818ee:	69e3      	ldr	r3, [r4, #28]
   818f0:	2b01      	cmp	r3, #1
   818f2:	d004      	beq.n	818fe <prvProcessExpiredTimer+0x26>
	pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
   818f4:	6a63      	ldr	r3, [r4, #36]	; 0x24
   818f6:	4620      	mov	r0, r4
   818f8:	4798      	blx	r3
}
   818fa:	b002      	add	sp, #8
   818fc:	bd70      	pop	{r4, r5, r6, pc}
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
   818fe:	69a1      	ldr	r1, [r4, #24]
   81900:	462b      	mov	r3, r5
   81902:	4632      	mov	r2, r6
   81904:	4429      	add	r1, r5
   81906:	4620      	mov	r0, r4
   81908:	4e0a      	ldr	r6, [pc, #40]	; (81934 <prvProcessExpiredTimer+0x5c>)
   8190a:	47b0      	blx	r6
   8190c:	2801      	cmp	r0, #1
   8190e:	d1f1      	bne.n	818f4 <prvProcessExpiredTimer+0x1c>
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
   81910:	2100      	movs	r1, #0
   81912:	9100      	str	r1, [sp, #0]
   81914:	460b      	mov	r3, r1
   81916:	462a      	mov	r2, r5
   81918:	4620      	mov	r0, r4
   8191a:	4d07      	ldr	r5, [pc, #28]	; (81938 <prvProcessExpiredTimer+0x60>)
   8191c:	47a8      	blx	r5
			configASSERT( xResult );
   8191e:	2800      	cmp	r0, #0
   81920:	d1e8      	bne.n	818f4 <prvProcessExpiredTimer+0x1c>
   81922:	4b06      	ldr	r3, [pc, #24]	; (8193c <prvProcessExpiredTimer+0x64>)
   81924:	4798      	blx	r3
   81926:	bf00      	nop
   81928:	e7fd      	b.n	81926 <prvProcessExpiredTimer+0x4e>
   8192a:	bf00      	nop
   8192c:	2000a594 	.word	0x2000a594
   81930:	000803fd 	.word	0x000803fd
   81934:	000816d1 	.word	0x000816d1
   81938:	000817b5 	.word	0x000817b5
   8193c:	00080485 	.word	0x00080485

00081940 <prvProcessTimerOrBlockTask>:
{
   81940:	b570      	push	{r4, r5, r6, lr}
   81942:	b082      	sub	sp, #8
   81944:	4605      	mov	r5, r0
   81946:	460e      	mov	r6, r1
	vTaskSuspendAll();
   81948:	4b10      	ldr	r3, [pc, #64]	; (8198c <prvProcessTimerOrBlockTask+0x4c>)
   8194a:	4798      	blx	r3
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
   8194c:	a801      	add	r0, sp, #4
   8194e:	4b10      	ldr	r3, [pc, #64]	; (81990 <prvProcessTimerOrBlockTask+0x50>)
   81950:	4798      	blx	r3
		if( xTimerListsWereSwitched == pdFALSE )
   81952:	9b01      	ldr	r3, [sp, #4]
   81954:	b9bb      	cbnz	r3, 81986 <prvProcessTimerOrBlockTask+0x46>
   81956:	4604      	mov	r4, r0
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
   81958:	b90e      	cbnz	r6, 8195e <prvProcessTimerOrBlockTask+0x1e>
   8195a:	42a8      	cmp	r0, r5
   8195c:	d209      	bcs.n	81972 <prvProcessTimerOrBlockTask+0x32>
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
   8195e:	1b29      	subs	r1, r5, r4
   81960:	4b0c      	ldr	r3, [pc, #48]	; (81994 <prvProcessTimerOrBlockTask+0x54>)
   81962:	6898      	ldr	r0, [r3, #8]
   81964:	4b0c      	ldr	r3, [pc, #48]	; (81998 <prvProcessTimerOrBlockTask+0x58>)
   81966:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
   81968:	4b0c      	ldr	r3, [pc, #48]	; (8199c <prvProcessTimerOrBlockTask+0x5c>)
   8196a:	4798      	blx	r3
   8196c:	b140      	cbz	r0, 81980 <prvProcessTimerOrBlockTask+0x40>
}
   8196e:	b002      	add	sp, #8
   81970:	bd70      	pop	{r4, r5, r6, pc}
				xTaskResumeAll();
   81972:	4b0a      	ldr	r3, [pc, #40]	; (8199c <prvProcessTimerOrBlockTask+0x5c>)
   81974:	4798      	blx	r3
				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
   81976:	4621      	mov	r1, r4
   81978:	4628      	mov	r0, r5
   8197a:	4b09      	ldr	r3, [pc, #36]	; (819a0 <prvProcessTimerOrBlockTask+0x60>)
   8197c:	4798      	blx	r3
   8197e:	e7f6      	b.n	8196e <prvProcessTimerOrBlockTask+0x2e>
					portYIELD_WITHIN_API();
   81980:	4b08      	ldr	r3, [pc, #32]	; (819a4 <prvProcessTimerOrBlockTask+0x64>)
   81982:	4798      	blx	r3
   81984:	e7f3      	b.n	8196e <prvProcessTimerOrBlockTask+0x2e>
			xTaskResumeAll();
   81986:	4b05      	ldr	r3, [pc, #20]	; (8199c <prvProcessTimerOrBlockTask+0x5c>)
   81988:	4798      	blx	r3
}
   8198a:	e7f0      	b.n	8196e <prvProcessTimerOrBlockTask+0x2e>
   8198c:	00080fe9 	.word	0x00080fe9
   81990:	000818a5 	.word	0x000818a5
   81994:	2000a594 	.word	0x2000a594
   81998:	00080c9d 	.word	0x00080c9d
   8199c:	00081125 	.word	0x00081125
   819a0:	000818d9 	.word	0x000818d9
   819a4:	00080475 	.word	0x00080475

000819a8 <prvProcessReceivedCommands>:
{
   819a8:	b570      	push	{r4, r5, r6, lr}
   819aa:	b086      	sub	sp, #24
	xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
   819ac:	a802      	add	r0, sp, #8
   819ae:	4b26      	ldr	r3, [pc, #152]	; (81a48 <prvProcessReceivedCommands+0xa0>)
   819b0:	4798      	blx	r3
   819b2:	4605      	mov	r5, r0
	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
   819b4:	e010      	b.n	819d8 <prvProcessReceivedCommands+0x30>
				pxTimer->xTimerPeriodInTicks = xMessage.xMessageValue;
   819b6:	9904      	ldr	r1, [sp, #16]
   819b8:	61a1      	str	r1, [r4, #24]
				configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
   819ba:	b131      	cbz	r1, 819ca <prvProcessReceivedCommands+0x22>
				prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
   819bc:	462b      	mov	r3, r5
   819be:	462a      	mov	r2, r5
   819c0:	4429      	add	r1, r5
   819c2:	4620      	mov	r0, r4
   819c4:	4c21      	ldr	r4, [pc, #132]	; (81a4c <prvProcessReceivedCommands+0xa4>)
   819c6:	47a0      	blx	r4
				break;
   819c8:	e006      	b.n	819d8 <prvProcessReceivedCommands+0x30>
				configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
   819ca:	4b21      	ldr	r3, [pc, #132]	; (81a50 <prvProcessReceivedCommands+0xa8>)
   819cc:	4798      	blx	r3
   819ce:	bf00      	nop
   819d0:	e7fd      	b.n	819ce <prvProcessReceivedCommands+0x26>
				vPortFree( pxTimer );
   819d2:	4620      	mov	r0, r4
   819d4:	4b1f      	ldr	r3, [pc, #124]	; (81a54 <prvProcessReceivedCommands+0xac>)
   819d6:	4798      	blx	r3
	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
   819d8:	2300      	movs	r3, #0
   819da:	461a      	mov	r2, r3
   819dc:	a903      	add	r1, sp, #12
   819de:	481e      	ldr	r0, [pc, #120]	; (81a58 <prvProcessReceivedCommands+0xb0>)
   819e0:	6880      	ldr	r0, [r0, #8]
   819e2:	4c1e      	ldr	r4, [pc, #120]	; (81a5c <prvProcessReceivedCommands+0xb4>)
   819e4:	47a0      	blx	r4
   819e6:	2800      	cmp	r0, #0
   819e8:	d02c      	beq.n	81a44 <prvProcessReceivedCommands+0x9c>
		pxTimer = xMessage.pxTimer;
   819ea:	9c05      	ldr	r4, [sp, #20]
		if( pxTimer != NULL )
   819ec:	b124      	cbz	r4, 819f8 <prvProcessReceivedCommands+0x50>
			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
   819ee:	6963      	ldr	r3, [r4, #20]
   819f0:	b113      	cbz	r3, 819f8 <prvProcessReceivedCommands+0x50>
				uxListRemove( &( pxTimer->xTimerListItem ) );
   819f2:	1d20      	adds	r0, r4, #4
   819f4:	4b1a      	ldr	r3, [pc, #104]	; (81a60 <prvProcessReceivedCommands+0xb8>)
   819f6:	4798      	blx	r3
		switch( xMessage.xMessageID )
   819f8:	9b03      	ldr	r3, [sp, #12]
   819fa:	2b02      	cmp	r3, #2
   819fc:	d0db      	beq.n	819b6 <prvProcessReceivedCommands+0xe>
   819fe:	2b03      	cmp	r3, #3
   81a00:	d0e7      	beq.n	819d2 <prvProcessReceivedCommands+0x2a>
   81a02:	2b00      	cmp	r3, #0
   81a04:	d1e8      	bne.n	819d8 <prvProcessReceivedCommands+0x30>
				if( prvInsertTimerInActiveList( pxTimer,  xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.xMessageValue ) == pdTRUE )
   81a06:	9904      	ldr	r1, [sp, #16]
   81a08:	69a0      	ldr	r0, [r4, #24]
   81a0a:	460b      	mov	r3, r1
   81a0c:	462a      	mov	r2, r5
   81a0e:	4401      	add	r1, r0
   81a10:	4620      	mov	r0, r4
   81a12:	4e0e      	ldr	r6, [pc, #56]	; (81a4c <prvProcessReceivedCommands+0xa4>)
   81a14:	47b0      	blx	r6
   81a16:	2801      	cmp	r0, #1
   81a18:	d1de      	bne.n	819d8 <prvProcessReceivedCommands+0x30>
					pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
   81a1a:	6a63      	ldr	r3, [r4, #36]	; 0x24
   81a1c:	4620      	mov	r0, r4
   81a1e:	4798      	blx	r3
					if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
   81a20:	69e3      	ldr	r3, [r4, #28]
   81a22:	2b01      	cmp	r3, #1
   81a24:	d1d8      	bne.n	819d8 <prvProcessReceivedCommands+0x30>
						xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
   81a26:	69a2      	ldr	r2, [r4, #24]
   81a28:	2100      	movs	r1, #0
   81a2a:	9100      	str	r1, [sp, #0]
   81a2c:	460b      	mov	r3, r1
   81a2e:	9804      	ldr	r0, [sp, #16]
   81a30:	4402      	add	r2, r0
   81a32:	4620      	mov	r0, r4
   81a34:	4c0b      	ldr	r4, [pc, #44]	; (81a64 <prvProcessReceivedCommands+0xbc>)
   81a36:	47a0      	blx	r4
						configASSERT( xResult );
   81a38:	2800      	cmp	r0, #0
   81a3a:	d1cd      	bne.n	819d8 <prvProcessReceivedCommands+0x30>
   81a3c:	4b04      	ldr	r3, [pc, #16]	; (81a50 <prvProcessReceivedCommands+0xa8>)
   81a3e:	4798      	blx	r3
   81a40:	bf00      	nop
   81a42:	e7fd      	b.n	81a40 <prvProcessReceivedCommands+0x98>
}
   81a44:	b006      	add	sp, #24
   81a46:	bd70      	pop	{r4, r5, r6, pc}
   81a48:	000818a5 	.word	0x000818a5
   81a4c:	000816d1 	.word	0x000816d1
   81a50:	00080485 	.word	0x00080485
   81a54:	000806ed 	.word	0x000806ed
   81a58:	2000a594 	.word	0x2000a594
   81a5c:	00080b25 	.word	0x00080b25
   81a60:	000803fd 	.word	0x000803fd
   81a64:	000817b5 	.word	0x000817b5

00081a68 <prvTimerTask>:
{
   81a68:	b500      	push	{lr}
   81a6a:	b083      	sub	sp, #12
		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
   81a6c:	a801      	add	r0, sp, #4
   81a6e:	4b04      	ldr	r3, [pc, #16]	; (81a80 <prvTimerTask+0x18>)
   81a70:	4798      	blx	r3
		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
   81a72:	9901      	ldr	r1, [sp, #4]
   81a74:	4b03      	ldr	r3, [pc, #12]	; (81a84 <prvTimerTask+0x1c>)
   81a76:	4798      	blx	r3
		prvProcessReceivedCommands();
   81a78:	4b03      	ldr	r3, [pc, #12]	; (81a88 <prvTimerTask+0x20>)
   81a7a:	4798      	blx	r3
   81a7c:	e7f6      	b.n	81a6c <prvTimerTask+0x4>
   81a7e:	bf00      	nop
   81a80:	000816b1 	.word	0x000816b1
   81a84:	00081941 	.word	0x00081941
   81a88:	000819a9 	.word	0x000819a9

00081a8c <Toggle_Output>:

void Toggle_Output(Pio *PORT,uint8_t PIN)
{
	static uint32_t t;

	t = (PORT->PIO_ODSR>>(PIN))&(0x1);
   81a8c:	6b83      	ldr	r3, [r0, #56]	; 0x38
   81a8e:	40cb      	lsrs	r3, r1
	if (t)//tests if LED PIO is active
   81a90:	f013 0f01 	tst.w	r3, #1
   81a94:	d104      	bne.n	81aa0 <Toggle_Output+0x14>
	{
		PORT->PIO_CODR = 0x1 << PIN;
	}
	else
	{
		PORT->PIO_SODR= 0x1 << PIN;
   81a96:	2301      	movs	r3, #1
   81a98:	fa03 f101 	lsl.w	r1, r3, r1
   81a9c:	6301      	str	r1, [r0, #48]	; 0x30
   81a9e:	4770      	bx	lr
		PORT->PIO_CODR = 0x1 << PIN;
   81aa0:	2301      	movs	r3, #1
   81aa2:	fa03 f101 	lsl.w	r1, r3, r1
   81aa6:	6341      	str	r1, [r0, #52]	; 0x34
   81aa8:	4770      	bx	lr
	...

00081aac <Set_Duty_Cycle_Synchronous_Channels>:
	PWM_sel->PWM_CDTYUPDx &= ~PWM_CDTYUPD_CDTYUPD_Msk;//reset
	PWM_sel->PWM_CDTYUPDx |= PWM_CDTYUPD_CDTYUPD(t);//set PWM
}

void Set_Duty_Cycle_Synchronous_Channels(uint8_t Duty_Cycle, PWMx *PWM_sel)
{
   81aac:	b082      	sub	sp, #8
	volatile uint32_t t ;
	if (Duty_Cycle>100)
   81aae:	2864      	cmp	r0, #100	; 0x64
   81ab0:	d900      	bls.n	81ab4 <Set_Duty_Cycle_Synchronous_Channels+0x8>
	{
		Duty_Cycle=100;
   81ab2:	2064      	movs	r0, #100	; 0x64
	}
	t=PWM0->PWM_CPRDx&0xFFF;//grab channel PWM period
   81ab4:	4b0d      	ldr	r3, [pc, #52]	; (81aec <Set_Duty_Cycle_Synchronous_Channels+0x40>)
   81ab6:	68db      	ldr	r3, [r3, #12]
   81ab8:	f3c3 030b 	ubfx	r3, r3, #0, #12
   81abc:	9301      	str	r3, [sp, #4]
	t = (int)((long)Duty_Cycle*(long)t/100);//calculate Duty Cycle update value as ratio of channel period
   81abe:	9b01      	ldr	r3, [sp, #4]
   81ac0:	fb03 f000 	mul.w	r0, r3, r0
   81ac4:	4b0a      	ldr	r3, [pc, #40]	; (81af0 <Set_Duty_Cycle_Synchronous_Channels+0x44>)
   81ac6:	fb83 2300 	smull	r2, r3, r3, r0
   81aca:	17c0      	asrs	r0, r0, #31
   81acc:	ebc0 1063 	rsb	r0, r0, r3, asr #5
   81ad0:	9001      	str	r0, [sp, #4]
	PWM_sel->PWM_CDTYUPDx &= ~PWM_CDTYUPD_CDTYUPD_Msk;//reset
   81ad2:	688b      	ldr	r3, [r1, #8]
   81ad4:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
   81ad8:	608b      	str	r3, [r1, #8]
	PWM_sel->PWM_CDTYUPDx |= PWM_CDTYUPD_CDTYUPD(t);//set PWM
   81ada:	9b01      	ldr	r3, [sp, #4]
   81adc:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
   81ae0:	688a      	ldr	r2, [r1, #8]
   81ae2:	4313      	orrs	r3, r2
   81ae4:	608b      	str	r3, [r1, #8]
   81ae6:	b002      	add	sp, #8
   81ae8:	4770      	bx	lr
   81aea:	bf00      	nop
   81aec:	40094200 	.word	0x40094200
   81af0:	51eb851f 	.word	0x51eb851f

00081af4 <SPI_transfer>:
 *  Author: hanno
 */ 
#include "SPI_SAM.h"

void SPI_transfer(void)
{
   81af4:	b082      	sub	sp, #8
	volatile uint32_t temp;
	
	temp = (SPI0->SPI_SR>>1)&(0x0001);
   81af6:	4b0f      	ldr	r3, [pc, #60]	; (81b34 <SPI_transfer+0x40>)
   81af8:	691b      	ldr	r3, [r3, #16]
   81afa:	f3c3 0340 	ubfx	r3, r3, #1, #1
   81afe:	9301      	str	r3, [sp, #4]
	if (temp==0)//tests data register is ready
   81b00:	9b01      	ldr	r3, [sp, #4]
   81b02:	b923      	cbnz	r3, 81b0e <SPI_transfer+0x1a>
	{
		temp = (SPI0->SPI_SR>>1)&(0x0001);//Data has been written to SPI_TDR and not yet transferred to the serializer		
   81b04:	4b0b      	ldr	r3, [pc, #44]	; (81b34 <SPI_transfer+0x40>)
   81b06:	691b      	ldr	r3, [r3, #16]
   81b08:	f3c3 0340 	ubfx	r3, r3, #1, #1
   81b0c:	9301      	str	r3, [sp, #4]
	}
	//set data to be transferred
	SPI0->SPI_TDR |= SPI_TDR_TD(0xA6);
   81b0e:	4b09      	ldr	r3, [pc, #36]	; (81b34 <SPI_transfer+0x40>)
   81b10:	68da      	ldr	r2, [r3, #12]
   81b12:	f042 02a6 	orr.w	r2, r2, #166	; 0xa6
   81b16:	60da      	str	r2, [r3, #12]
	temp = (SPI0->SPI_SR>>1)&(0x0001);
   81b18:	691b      	ldr	r3, [r3, #16]
   81b1a:	f3c3 0340 	ubfx	r3, r3, #1, #1
   81b1e:	9301      	str	r3, [sp, #4]
	if (temp==0)//tests data register is ready
   81b20:	9b01      	ldr	r3, [sp, #4]
   81b22:	b923      	cbnz	r3, 81b2e <SPI_transfer+0x3a>
	{
			temp = (SPI0->SPI_SR>>1)&(0x0001);//Data has been written to SPI_TDR and not yet transferred to the serializer		
   81b24:	4b03      	ldr	r3, [pc, #12]	; (81b34 <SPI_transfer+0x40>)
   81b26:	691b      	ldr	r3, [r3, #16]
   81b28:	f3c3 0340 	ubfx	r3, r3, #1, #1
   81b2c:	9301      	str	r3, [sp, #4]
	}
	
	
   81b2e:	b002      	add	sp, #8
   81b30:	4770      	bx	lr
   81b32:	bf00      	nop
   81b34:	40008000 	.word	0x40008000

00081b38 <Task2_task>:
	/* Should never go there */
	vTaskDelete(NULL);
}

static void Task2_task(void *pvParameters)
{
   81b38:	b500      	push	{lr}
   81b3a:	b083      	sub	sp, #12
	portTickType xLastWakeTime;
	const portTickType xFrequency = 150;

	// Initialise the xLastWakeTime variable with the current time.
	xLastWakeTime = xTaskGetTickCount();
   81b3c:	4b05      	ldr	r3, [pc, #20]	; (81b54 <Task2_task+0x1c>)
   81b3e:	4798      	blx	r3
   81b40:	9001      	str	r0, [sp, #4]
	for(;;)
	{
		/* task application*/
		
		//DELAY(150);
		vTaskDelayUntil( &xLastWakeTime, xFrequency );
   81b42:	2196      	movs	r1, #150	; 0x96
   81b44:	a801      	add	r0, sp, #4
   81b46:	4b04      	ldr	r3, [pc, #16]	; (81b58 <Task2_task+0x20>)
   81b48:	4798      	blx	r3
		Toggle_Output(OUT_A0_PA16_PORT,OUT_A0_PA16_PIN);
   81b4a:	2110      	movs	r1, #16
   81b4c:	4803      	ldr	r0, [pc, #12]	; (81b5c <Task2_task+0x24>)
   81b4e:	4b04      	ldr	r3, [pc, #16]	; (81b60 <Task2_task+0x28>)
   81b50:	4798      	blx	r3
   81b52:	e7f6      	b.n	81b42 <Task2_task+0xa>
   81b54:	00080ffd 	.word	0x00080ffd
   81b58:	0008121d 	.word	0x0008121d
   81b5c:	400e0e00 	.word	0x400e0e00
   81b60:	00081a8d 	.word	0x00081a8d

00081b64 <Task1_task>:
{
   81b64:	b500      	push	{lr}
   81b66:	b083      	sub	sp, #12
	xLastWakeTime = xTaskGetTickCount();
   81b68:	4b05      	ldr	r3, [pc, #20]	; (81b80 <Task1_task+0x1c>)
   81b6a:	4798      	blx	r3
   81b6c:	9001      	str	r0, [sp, #4]
		vTaskDelayUntil( &xLastWakeTime, xFrequency );
   81b6e:	2164      	movs	r1, #100	; 0x64
   81b70:	a801      	add	r0, sp, #4
   81b72:	4b04      	ldr	r3, [pc, #16]	; (81b84 <Task1_task+0x20>)
   81b74:	4798      	blx	r3
		Toggle_Output(OUT_A1_PA24_PORT,OUT_A1_PA24_PIN);
   81b76:	2118      	movs	r1, #24
   81b78:	4803      	ldr	r0, [pc, #12]	; (81b88 <Task1_task+0x24>)
   81b7a:	4b04      	ldr	r3, [pc, #16]	; (81b8c <Task1_task+0x28>)
   81b7c:	4798      	blx	r3
   81b7e:	e7f6      	b.n	81b6e <Task1_task+0xa>
   81b80:	00080ffd 	.word	0x00080ffd
   81b84:	0008121d 	.word	0x0008121d
   81b88:	400e0e00 	.word	0x400e0e00
   81b8c:	00081a8d 	.word	0x00081a8d

00081b90 <main>:
}



int main(void)
{
   81b90:	b500      	push	{lr}
   81b92:	b087      	sub	sp, #28
	/* Initialize variables */
	struct time_RTC time; 
	volatile uint32_t a = 0;
   81b94:	2400      	movs	r4, #0
   81b96:	9405      	str	r4, [sp, #20]
    /* Initialize the SAM system */
    SystemInit();
   81b98:	4b1b      	ldr	r3, [pc, #108]	; (81c08 <main+0x78>)
   81b9a:	4798      	blx	r3
	SystemCoreClockUpdate();
   81b9c:	4b1b      	ldr	r3, [pc, #108]	; (81c0c <main+0x7c>)
   81b9e:	4798      	blx	r3

	/* Initialize the peripherals */
	PIO_INIT();//works
   81ba0:	4b1b      	ldr	r3, [pc, #108]	; (81c10 <main+0x80>)
   81ba2:	4798      	blx	r3
	//TWI_init();
	USART0_init();//works
   81ba4:	4b1b      	ldr	r3, [pc, #108]	; (81c14 <main+0x84>)
   81ba6:	4798      	blx	r3
	DAC_init();//works
   81ba8:	4b1b      	ldr	r3, [pc, #108]	; (81c18 <main+0x88>)
   81baa:	4798      	blx	r3
	ADC_init();//works
   81bac:	4b1b      	ldr	r3, [pc, #108]	; (81c1c <main+0x8c>)
   81bae:	4798      	blx	r3
	PWM_init();//works  
   81bb0:	4b1b      	ldr	r3, [pc, #108]	; (81c20 <main+0x90>)
   81bb2:	4798      	blx	r3
	SPI_init();//works
   81bb4:	4b1b      	ldr	r3, [pc, #108]	; (81c24 <main+0x94>)
   81bb6:	4798      	blx	r3
	time.month_int= 3;
	time.year= 2022;
	time.Day_of_Week_int= 4;*/
	//xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions ) PRIVILEGED_FUNCTION;
	/* Create Worker 1 task */
	xTaskCreate(Task1_task,NULL,configMINIMAL_STACK_SIZE+400,NULL, 1,& Task1_id);
   81bb8:	9403      	str	r4, [sp, #12]
   81bba:	9402      	str	r4, [sp, #8]
   81bbc:	4b1a      	ldr	r3, [pc, #104]	; (81c28 <main+0x98>)
   81bbe:	9301      	str	r3, [sp, #4]
   81bc0:	2301      	movs	r3, #1
   81bc2:	9300      	str	r3, [sp, #0]
   81bc4:	4623      	mov	r3, r4
   81bc6:	f240 2212 	movw	r2, #530	; 0x212
   81bca:	4621      	mov	r1, r4
   81bcc:	4817      	ldr	r0, [pc, #92]	; (81c2c <main+0x9c>)
   81bce:	4d18      	ldr	r5, [pc, #96]	; (81c30 <main+0xa0>)
   81bd0:	47a8      	blx	r5
	xTaskCreate(Task2_task,NULL,configMINIMAL_STACK_SIZE+400,NULL, 2,& Task2_id);
   81bd2:	9403      	str	r4, [sp, #12]
   81bd4:	9402      	str	r4, [sp, #8]
   81bd6:	4b17      	ldr	r3, [pc, #92]	; (81c34 <main+0xa4>)
   81bd8:	9301      	str	r3, [sp, #4]
   81bda:	2302      	movs	r3, #2
   81bdc:	9300      	str	r3, [sp, #0]
   81bde:	4623      	mov	r3, r4
   81be0:	f240 2212 	movw	r2, #530	; 0x212
   81be4:	4621      	mov	r1, r4
   81be6:	4814      	ldr	r0, [pc, #80]	; (81c38 <main+0xa8>)
   81be8:	47a8      	blx	r5
	/*Start Scheduler*/
	vTaskStartScheduler();
   81bea:	4b14      	ldr	r3, [pc, #80]	; (81c3c <main+0xac>)
   81bec:	4798      	blx	r3
   81bee:	e008      	b.n	81c02 <main+0x72>
    while (1)
    {
		a = 0;
		while(a<=500)
		{
		a =a+1;
   81bf0:	9b05      	ldr	r3, [sp, #20]
   81bf2:	3301      	adds	r3, #1
   81bf4:	9305      	str	r3, [sp, #20]
		while(a<=500)
   81bf6:	9b05      	ldr	r3, [sp, #20]
   81bf8:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
   81bfc:	d9f8      	bls.n	81bf0 <main+0x60>
		}
		//Toggle_Output(RED_PB26_PORT,RED_PB27_PIN);
		SPI_transfer();
   81bfe:	4b10      	ldr	r3, [pc, #64]	; (81c40 <main+0xb0>)
   81c00:	4798      	blx	r3
		a = 0;
   81c02:	2300      	movs	r3, #0
   81c04:	9305      	str	r3, [sp, #20]
		while(a<=500)
   81c06:	e7f6      	b.n	81bf6 <main+0x66>
   81c08:	000801d1 	.word	0x000801d1
   81c0c:	00080275 	.word	0x00080275
   81c10:	00081fed 	.word	0x00081fed
   81c14:	00082185 	.word	0x00082185
   81c18:	00081c8d 	.word	0x00081c8d
   81c1c:	00081c49 	.word	0x00081c49
   81c20:	00082041 	.word	0x00082041
   81c24:	00082115 	.word	0x00082115
   81c28:	2000a5cc 	.word	0x2000a5cc
   81c2c:	00081b65 	.word	0x00081b65
   81c30:	00080e29 	.word	0x00080e29
   81c34:	2000a5d0 	.word	0x2000a5d0
   81c38:	00081b39 	.word	0x00081b39
   81c3c:	00080f7d 	.word	0x00080f7d
   81c40:	00081af5 	.word	0x00081af5

00081c44 <vApplicationMallocFailedHook>:
		cnt =cnt+1;
	}
}

void vApplicationMallocFailedHook( void )
{
   81c44:	e7fe      	b.n	81c44 <vApplicationMallocFailedHook>
	...

00081c48 <ADC_init>:
#include "ADC_init_SAM.h"

void ADC_init(void)
{
	//Disable DAC Write Protect Mode Register
	ADC->ADC_WPMR =ADC_WPMR_WPKEY_PASSWD|~(ADC_WPMR_WPEN);
   81c48:	4b0e      	ldr	r3, [pc, #56]	; (81c84 <ADC_init+0x3c>)
   81c4a:	f06f 0201 	mvn.w	r2, #1
   81c4e:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
	//Enable Peripheral Clock
	PMC->PMC_PCER1 |= (PMC_PCER1_PID37);//enable clock for ADC
   81c52:	490d      	ldr	r1, [pc, #52]	; (81c88 <ADC_init+0x40>)
   81c54:	f8d1 2100 	ldr.w	r2, [r1, #256]	; 0x100
   81c58:	f042 0220 	orr.w	r2, r2, #32
   81c5c:	f8c1 2100 	str.w	r2, [r1, #256]	; 0x100
	// set sampling speed 100us
	ADC -> ADC_MR	&= ~(ADC_MR_PRESCAL_Msk);//reset
   81c60:	685a      	ldr	r2, [r3, #4]
   81c62:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
   81c66:	605a      	str	r2, [r3, #4]
	ADC -> ADC_MR	|= ADC_MR_PRESCAL(3999);// set
   81c68:	685a      	ldr	r2, [r3, #4]
   81c6a:	f442 421f 	orr.w	r2, r2, #40704	; 0x9f00
   81c6e:	605a      	str	r2, [r3, #4]
	// enable AD channel 
	ADC -> ADC_CHDR &= ~(0xFF);//reset
   81c70:	695a      	ldr	r2, [r3, #20]
   81c72:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
   81c76:	615a      	str	r2, [r3, #20]
	ADC -> ADC_CHER |= ADC_CHER_CH0;//set AD0
   81c78:	691a      	ldr	r2, [r3, #16]
   81c7a:	f042 0201 	orr.w	r2, r2, #1
   81c7e:	611a      	str	r2, [r3, #16]
   81c80:	4770      	bx	lr
   81c82:	bf00      	nop
   81c84:	400c0000 	.word	0x400c0000
   81c88:	400e0600 	.word	0x400e0600

00081c8c <DAC_init>:
 *  Author: hanno
 */ 
#include "DAC_init_SAM.h"

void DAC_init(void)
{
   81c8c:	b082      	sub	sp, #8
	volatile uint32_t temp;
	//Disable DAC Write Protect Mode Register
	DACC->DACC_WPMR =DACC_WPMR_WPKEY(0x444143)|~(DACC_WPMR_WPEN);
   81c8e:	4b1d      	ldr	r3, [pc, #116]	; (81d04 <DAC_init+0x78>)
   81c90:	f06f 0201 	mvn.w	r2, #1
   81c94:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
	//Enable Peripheral Clock
	PMC->PMC_PCER1 |= (PMC_PCER1_PID38);//enable clock for DAC
   81c98:	491b      	ldr	r1, [pc, #108]	; (81d08 <DAC_init+0x7c>)
   81c9a:	f8d1 2100 	ldr.w	r2, [r1, #256]	; 0x100
   81c9e:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   81ca2:	f8c1 2100 	str.w	r2, [r1, #256]	; 0x100
	/*//Select Channel 1
	DACC->DACC_MR |= DACC_MR_USER_SEL_CHANNEL1;*/
	//set startup time
	DACC->DACC_MR &= ~(DACC_MR_STARTUP_Msk);
   81ca6:	685a      	ldr	r2, [r3, #4]
   81ca8:	f022 527c 	bic.w	r2, r2, #1056964608	; 0x3f000000
   81cac:	605a      	str	r2, [r3, #4]
	DACC->DACC_MR |= (DACC_MR_STARTUP_1344);
   81cae:	685a      	ldr	r2, [r3, #4]
   81cb0:	f042 52a8 	orr.w	r2, r2, #352321536	; 0x15000000
   81cb4:	605a      	str	r2, [r3, #4]
	/*//set refresh period
	DACC->DACC_MR &= ~(DACC_MR_REFRESH_Msk);
	DACC->DACC_MR |= (DACC_MR_REFRESH(0x30));*/
	// Disable channel 0 and enable channel 1
	DACC->DACC_CHDR|= DACC_CHER_CH0;
   81cb6:	695a      	ldr	r2, [r3, #20]
   81cb8:	f042 0201 	orr.w	r2, r2, #1
   81cbc:	615a      	str	r2, [r3, #20]
	DACC->DACC_CHER|= DACC_CHER_CH1;
   81cbe:	691a      	ldr	r2, [r3, #16]
   81cc0:	f042 0202 	orr.w	r2, r2, #2
   81cc4:	611a      	str	r2, [r3, #16]
	
	// check if DACC is ready to accept new conversion requests
	temp = (DACC->DACC_ISR>>0)&(0x0001);
   81cc6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   81cc8:	f003 0301 	and.w	r3, r3, #1
   81ccc:	9301      	str	r3, [sp, #4]
	if (temp==0)//wait for DAC complete
   81cce:	9b01      	ldr	r3, [sp, #4]
   81cd0:	b92b      	cbnz	r3, 81cde <DAC_init+0x52>
	{
		while (1)
		{
			temp = (DACC->DACC_ISR>>0)&(0x0001);//DAC not complete
   81cd2:	4b0c      	ldr	r3, [pc, #48]	; (81d04 <DAC_init+0x78>)
   81cd4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   81cd6:	f003 0301 	and.w	r3, r3, #1
   81cda:	9301      	str	r3, [sp, #4]
   81cdc:	e7f9      	b.n	81cd2 <DAC_init+0x46>
		}
	}
	
	// Set data to be converted
	DACC->DACC_CDR |= 0xFF/2; //Vref/2 
   81cde:	4b09      	ldr	r3, [pc, #36]	; (81d04 <DAC_init+0x78>)
   81ce0:	6a1a      	ldr	r2, [r3, #32]
   81ce2:	f042 027f 	orr.w	r2, r2, #127	; 0x7f
   81ce6:	621a      	str	r2, [r3, #32]
	
	// check EOC
	temp = (DACC->DACC_ISR>>0)&(0x0001);
   81ce8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   81cea:	f003 0301 	and.w	r3, r3, #1
   81cee:	9301      	str	r3, [sp, #4]
	if (temp==0)//wait for DAC complete
   81cf0:	9b01      	ldr	r3, [sp, #4]
   81cf2:	b92b      	cbnz	r3, 81d00 <DAC_init+0x74>
	{
		while (1)
		{
			temp = (DACC->DACC_ISR>>0)&(0x0001);//DAC not complete
   81cf4:	4b03      	ldr	r3, [pc, #12]	; (81d04 <DAC_init+0x78>)
   81cf6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   81cf8:	f003 0301 	and.w	r3, r3, #1
   81cfc:	9301      	str	r3, [sp, #4]
   81cfe:	e7f9      	b.n	81cf4 <DAC_init+0x68>
		}
	} 
	
	
   81d00:	b002      	add	sp, #8
   81d02:	4770      	bx	lr
   81d04:	400c8000 	.word	0x400c8000
   81d08:	400e0600 	.word	0x400e0600

00081d0c <PIO_IO_init>:
 */ 

#include "pio_init.h"

void PIO_IO_init(uint8_t IO, Pio *PORT, uint8_t PIN, uint8_t PIO)//initialize pin as Input (1) or Output(0); PIO -> 0=PIO control, 1=A peripheral, 2=B peripheral
{
   81d0c:	b430      	push	{r4, r5}
   81d0e:	b082      	sub	sp, #8
	volatile uint32_t t1;
	// Disables the Write Protect
	PORT ->PIO_WPMR =(PIO_WPMR_WPKEY(0x50494F))|~(PIO_WPMR_WPEN);
   81d10:	f06f 0401 	mvn.w	r4, #1
   81d14:	f8c1 40e4 	str.w	r4, [r1, #228]	; 0xe4
	// Grabs PIO Write Protect Status
	t1 =  PORT->PIO_PSR;
   81d18:	688c      	ldr	r4, [r1, #8]
   81d1a:	9401      	str	r4, [sp, #4]
	t1 = (t1>>(PIN))&(0x1);//
   81d1c:	9c01      	ldr	r4, [sp, #4]
   81d1e:	40d4      	lsrs	r4, r2
   81d20:	f004 0401 	and.w	r4, r4, #1
   81d24:	9401      	str	r4, [sp, #4]
	t1=(~t1)&(0x1);
   81d26:	9c01      	ldr	r4, [sp, #4]
   81d28:	f084 0401 	eor.w	r4, r4, #1
   81d2c:	f004 0401 	and.w	r4, r4, #1
   81d30:	9401      	str	r4, [sp, #4]
	if (t1)//tests if PIO is active
   81d32:	9c01      	ldr	r4, [sp, #4]
   81d34:	b104      	cbz	r4, 81d38 <PIO_IO_init+0x2c>
   81d36:	e7fe      	b.n	81d36 <PIO_IO_init+0x2a>
		while (1)
		{
			//fault pins PIO is inactive
		}
	}
	if (PIO==0)
   81d38:	b9a3      	cbnz	r3, 81d64 <PIO_IO_init+0x58>
	{
		// Enables the PIO to control
		PORT->PIO_PER |=((0x1u << PIN));//set
   81d3a:	680c      	ldr	r4, [r1, #0]
   81d3c:	2501      	movs	r5, #1
   81d3e:	4095      	lsls	r5, r2
   81d40:	432c      	orrs	r4, r5
   81d42:	600c      	str	r4, [r1, #0]
		
		// Grabs PIO Controller status for respective pins
		t1 =  PORT->PIO_PSR;
   81d44:	688c      	ldr	r4, [r1, #8]
   81d46:	9401      	str	r4, [sp, #4]
		t1 = (t1>>(PIN)&(0x1));//
   81d48:	9c01      	ldr	r4, [sp, #4]
   81d4a:	40d4      	lsrs	r4, r2
   81d4c:	f004 0401 	and.w	r4, r4, #1
   81d50:	9401      	str	r4, [sp, #4]
		t1=(~t1)&(0x1);
   81d52:	9c01      	ldr	r4, [sp, #4]
   81d54:	f084 0401 	eor.w	r4, r4, #1
   81d58:	f004 0401 	and.w	r4, r4, #1
   81d5c:	9401      	str	r4, [sp, #4]
		if (t1)//tests if PIO is active
   81d5e:	9c01      	ldr	r4, [sp, #4]
   81d60:	b1e4      	cbz	r4, 81d9c <PIO_IO_init+0x90>
   81d62:	e7fe      	b.n	81d62 <PIO_IO_init+0x56>
		}
	}
	else
	{
		// Disables the PIO to control
		PORT->PIO_PDR |=((0x1u << PIN));//set
   81d64:	684c      	ldr	r4, [r1, #4]
   81d66:	2501      	movs	r5, #1
   81d68:	4095      	lsls	r5, r2
   81d6a:	432c      	orrs	r4, r5
   81d6c:	604c      	str	r4, [r1, #4]
		// Grabs PIO Controller status for respective pin
		t1 = (PORT->PIO_PSR>>(PIN)&(0x1));//
   81d6e:	688c      	ldr	r4, [r1, #8]
   81d70:	40d4      	lsrs	r4, r2
   81d72:	f004 0401 	and.w	r4, r4, #1
   81d76:	9401      	str	r4, [sp, #4]
		if (t1)//tests if PIO is active
   81d78:	9c01      	ldr	r4, [sp, #4]
   81d7a:	b104      	cbz	r4, 81d7e <PIO_IO_init+0x72>
   81d7c:	e7fe      	b.n	81d7c <PIO_IO_init+0x70>
			{
				//fault pins PIO is inactive
			}
		}
		
		if (PIO == 1)//PIO Peripheral AB
   81d7e:	2b01      	cmp	r3, #1
   81d80:	d105      	bne.n	81d8e <PIO_IO_init+0x82>
		{
			PORT->PIO_ABSR&=(~0x1)<<PIN;//set peripheral to A
   81d82:	6f0c      	ldr	r4, [r1, #112]	; 0x70
   81d84:	f06f 0501 	mvn.w	r5, #1
   81d88:	4095      	lsls	r5, r2
   81d8a:	402c      	ands	r4, r5
   81d8c:	670c      	str	r4, [r1, #112]	; 0x70
		}
		if (PIO == 2)
   81d8e:	2b02      	cmp	r3, #2
   81d90:	d104      	bne.n	81d9c <PIO_IO_init+0x90>
		{
			PORT->PIO_ABSR|=(0x1)<<PIN;//set peripheral to B
   81d92:	6f0c      	ldr	r4, [r1, #112]	; 0x70
   81d94:	2501      	movs	r5, #1
   81d96:	4095      	lsls	r5, r2
   81d98:	432c      	orrs	r4, r5
   81d9a:	670c      	str	r4, [r1, #112]	; 0x70
		}
	}
	
	
	if (IO)
   81d9c:	b160      	cbz	r0, 81db8 <PIO_IO_init+0xac>
	{	// Disable the output line
		PORT->PIO_ODR |=(0x1u << PIN);//set
   81d9e:	694c      	ldr	r4, [r1, #20]
   81da0:	2501      	movs	r5, #1
   81da2:	4095      	lsls	r5, r2
   81da4:	432c      	orrs	r4, r5
   81da6:	614c      	str	r4, [r1, #20]
		// Grabs PIO Controller Output Status for respective pins
		t1 = (PORT->PIO_OSR>>PIN)&(0x1);
   81da8:	698c      	ldr	r4, [r1, #24]
   81daa:	40d4      	lsrs	r4, r2
   81dac:	f004 0401 	and.w	r4, r4, #1
   81db0:	9401      	str	r4, [sp, #4]
		if (t1)//tests if I/O is set correctly
   81db2:	9c01      	ldr	r4, [sp, #4]
   81db4:	b18c      	cbz	r4, 81dda <PIO_IO_init+0xce>
   81db6:	e7fe      	b.n	81db6 <PIO_IO_init+0xaa>
			}
		}	
	} 
	else
	{	//Enable the output line
		PORT->PIO_OER |=((0x1u << PIN));//set
   81db8:	690c      	ldr	r4, [r1, #16]
   81dba:	2501      	movs	r5, #1
   81dbc:	4095      	lsls	r5, r2
   81dbe:	432c      	orrs	r4, r5
   81dc0:	610c      	str	r4, [r1, #16]
		// Grabs PIO Controller Output Status for respective pins
		t1 = (PORT->PIO_OSR>>PIN);//
   81dc2:	698c      	ldr	r4, [r1, #24]
   81dc4:	40d4      	lsrs	r4, r2
   81dc6:	9401      	str	r4, [sp, #4]
		t1=(~(t1&(0x1)))&(0x1);
   81dc8:	9c01      	ldr	r4, [sp, #4]
   81dca:	f084 0401 	eor.w	r4, r4, #1
   81dce:	f004 0401 	and.w	r4, r4, #1
   81dd2:	9401      	str	r4, [sp, #4]
		if (t1)//tests if I/O is set correctly
   81dd4:	9c01      	ldr	r4, [sp, #4]
   81dd6:	b104      	cbz	r4, 81dda <PIO_IO_init+0xce>
   81dd8:	e7fe      	b.n	81dd8 <PIO_IO_init+0xcc>
	}
	
	
	
	// Grabs PIO Controller Input Filter Status for respective pins
	t1 = (PORT->PIO_IFER>>(PIN)&(0x0001));
   81dda:	6a0c      	ldr	r4, [r1, #32]
   81ddc:	40d4      	lsrs	r4, r2
   81dde:	f004 0401 	and.w	r4, r4, #1
   81de2:	9401      	str	r4, [sp, #4]
	if (t1)//test if input glitch filter is disabled on the I/O line 
   81de4:	9c01      	ldr	r4, [sp, #4]
   81de6:	b104      	cbz	r4, 81dea <PIO_IO_init+0xde>
   81de8:	e7fe      	b.n	81de8 <PIO_IO_init+0xdc>
		{
			//fault input glitch filter is enabled on the I/O line
		}
	}
	
	if ((~IO)&(0x1)&(PIO==0))
   81dea:	f080 0001 	eor.w	r0, r0, #1
   81dee:	2b00      	cmp	r3, #0
   81df0:	bf14      	ite	ne
   81df2:	2300      	movne	r3, #0
   81df4:	f000 0301 	andeq.w	r3, r0, #1
   81df8:	b1a3      	cbz	r3, 81e24 <PIO_IO_init+0x118>
	{
		// Enables Output Write Enable Register
		PORT->PIO_OWER |=((0x1u << PIN));//set
   81dfa:	f8d1 00a0 	ldr.w	r0, [r1, #160]	; 0xa0
   81dfe:	2401      	movs	r4, #1
   81e00:	4094      	lsls	r4, r2
   81e02:	4320      	orrs	r0, r4
   81e04:	f8c1 00a0 	str.w	r0, [r1, #160]	; 0xa0

		// GrabsPIO Output Write Status Register for respective pins
		t1 = (PORT->PIO_OWSR>>(PIN))&(0x1);
   81e08:	f8d1 10a8 	ldr.w	r1, [r1, #168]	; 0xa8
   81e0c:	fa21 f202 	lsr.w	r2, r1, r2
   81e10:	f002 0201 	and.w	r2, r2, #1
   81e14:	9201      	str	r2, [sp, #4]
		if ((~t1)&(0x1))// Writing PIO_ODSR affects the I/O line. 
   81e16:	9a01      	ldr	r2, [sp, #4]
   81e18:	f012 0f01 	tst.w	r2, #1
   81e1c:	d000      	beq.n	81e20 <PIO_IO_init+0x114>
   81e1e:	2300      	movs	r3, #0
   81e20:	b103      	cbz	r3, 81e24 <PIO_IO_init+0x118>
   81e22:	e7fe      	b.n	81e22 <PIO_IO_init+0x116>
				//fault Writing PIO_ODSR does not affect the I/O line 
			}
		}
	}	
	
}
   81e24:	b002      	add	sp, #8
   81e26:	bc30      	pop	{r4, r5}
   81e28:	4770      	bx	lr
	...

00081e2c <LED_PIO_init>:

void LED_PIO_init(void)
{
   81e2c:	b538      	push	{r3, r4, r5, lr}
	//Disable PMC Write Protect Mode Register
	PMC->PMC_WPMR =PMC_WPMR_WPKEY_PASSWD|~(PMC_WPMR_WPEN);
   81e2e:	4b12      	ldr	r3, [pc, #72]	; (81e78 <LED_PIO_init+0x4c>)
   81e30:	f06f 0201 	mvn.w	r2, #1
   81e34:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
	//Enable Peripheral Clock
	PMC->PMC_PCER0 |= (PMC_PCER0_PID11);//enable clock for port A
   81e38:	691a      	ldr	r2, [r3, #16]
   81e3a:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
   81e3e:	611a      	str	r2, [r3, #16]
	PMC->PMC_PCER0 |= (PMC_PCER0_PID12);//enable clock for port B
   81e40:	691a      	ldr	r2, [r3, #16]
   81e42:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
   81e46:	611a      	str	r2, [r3, #16]
	
	PIO_IO_init(Output,RED_PB26_PORT,RED_PB26_PIN,PIO_control);
   81e48:	2300      	movs	r3, #0
   81e4a:	221a      	movs	r2, #26
   81e4c:	490b      	ldr	r1, [pc, #44]	; (81e7c <LED_PIO_init+0x50>)
   81e4e:	4618      	mov	r0, r3
   81e50:	4c0b      	ldr	r4, [pc, #44]	; (81e80 <LED_PIO_init+0x54>)
   81e52:	47a0      	blx	r4
	PIO_IO_init(Output,GREEN_PA15_PORT,GREEN_PA15_PIN,PIO_control);
   81e54:	4d0b      	ldr	r5, [pc, #44]	; (81e84 <LED_PIO_init+0x58>)
   81e56:	2300      	movs	r3, #0
   81e58:	220f      	movs	r2, #15
   81e5a:	4629      	mov	r1, r5
   81e5c:	4618      	mov	r0, r3
   81e5e:	47a0      	blx	r4
	PIO_IO_init(Output,OUT_A0_PA16_PORT,OUT_A0_PA16_PIN,PIO_control);
   81e60:	2300      	movs	r3, #0
   81e62:	2210      	movs	r2, #16
   81e64:	4629      	mov	r1, r5
   81e66:	4618      	mov	r0, r3
   81e68:	47a0      	blx	r4
	PIO_IO_init(Output,OUT_A1_PA24_PORT,OUT_A1_PA24_PIN,PIO_control);
   81e6a:	2300      	movs	r3, #0
   81e6c:	2218      	movs	r2, #24
   81e6e:	4629      	mov	r1, r5
   81e70:	4618      	mov	r0, r3
   81e72:	47a0      	blx	r4
   81e74:	bd38      	pop	{r3, r4, r5, pc}
   81e76:	bf00      	nop
   81e78:	400e0600 	.word	0x400e0600
   81e7c:	400e1000 	.word	0x400e1000
   81e80:	00081d0d 	.word	0x00081d0d
   81e84:	400e0e00 	.word	0x400e0e00

00081e88 <USART_PIO_init>:
	
}

void USART_PIO_init(void)
{
   81e88:	b538      	push	{r3, r4, r5, lr}
	//Disable PMC Write Protect Mode Register
	PMC->PMC_WPMR =PMC_WPMR_WPKEY_PASSWD|~(PMC_WPMR_WPEN);
   81e8a:	4b0b      	ldr	r3, [pc, #44]	; (81eb8 <USART_PIO_init+0x30>)
   81e8c:	f06f 0201 	mvn.w	r2, #1
   81e90:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
	//Enable Peripheral Clock
	PMC->PMC_PCER0 |= (PMC_PCER0_PID17);//enable clock for USART0
   81e94:	691a      	ldr	r2, [r3, #16]
   81e96:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
   81e9a:	611a      	str	r2, [r3, #16]
	
	PIO_IO_init(Output,TXD0_PA11_PORT,TXD0_PA11_PIN,Peripheral_A);
   81e9c:	4d07      	ldr	r5, [pc, #28]	; (81ebc <USART_PIO_init+0x34>)
   81e9e:	2301      	movs	r3, #1
   81ea0:	220b      	movs	r2, #11
   81ea2:	4629      	mov	r1, r5
   81ea4:	2000      	movs	r0, #0
   81ea6:	4c06      	ldr	r4, [pc, #24]	; (81ec0 <USART_PIO_init+0x38>)
   81ea8:	47a0      	blx	r4
	PIO_IO_init(Input,RDX0_PA10_PORT,RDX0_PA10_PIN,Peripheral_A);
   81eaa:	2301      	movs	r3, #1
   81eac:	220a      	movs	r2, #10
   81eae:	4629      	mov	r1, r5
   81eb0:	4618      	mov	r0, r3
   81eb2:	47a0      	blx	r4
   81eb4:	bd38      	pop	{r3, r4, r5, pc}
   81eb6:	bf00      	nop
   81eb8:	400e0600 	.word	0x400e0600
   81ebc:	400e0e00 	.word	0x400e0e00
   81ec0:	00081d0d 	.word	0x00081d0d

00081ec4 <TWI0_PIO_init>:
	
}

void TWI0_PIO_init(void)
{
   81ec4:	b538      	push	{r3, r4, r5, lr}
	//Disable PMC Write Protect Mode Register
	PMC->PMC_WPMR =PMC_WPMR_WPKEY_PASSWD|~(PMC_WPMR_WPEN);
   81ec6:	4b0b      	ldr	r3, [pc, #44]	; (81ef4 <TWI0_PIO_init+0x30>)
   81ec8:	f06f 0201 	mvn.w	r2, #1
   81ecc:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
	//Enable Peripheral Clock
	PMC->PMC_PCER0 |= (PMC_PCER0_PID22);//enable clock for TWI0
   81ed0:	691a      	ldr	r2, [r3, #16]
   81ed2:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
   81ed6:	611a      	str	r2, [r3, #16]
	
	PIO_IO_init(Output,TWD0_SCL_PA18_PORT,TWD0_SCL_PA18_PIN,Peripheral_A);
   81ed8:	4d07      	ldr	r5, [pc, #28]	; (81ef8 <TWI0_PIO_init+0x34>)
   81eda:	2301      	movs	r3, #1
   81edc:	2212      	movs	r2, #18
   81ede:	4629      	mov	r1, r5
   81ee0:	2000      	movs	r0, #0
   81ee2:	4c06      	ldr	r4, [pc, #24]	; (81efc <TWI0_PIO_init+0x38>)
   81ee4:	47a0      	blx	r4
	PIO_IO_init(Output,TWD0_SDA_PA17_PORT,TWD0_SDA_PA17_PIN,Peripheral_A);
   81ee6:	2301      	movs	r3, #1
   81ee8:	2211      	movs	r2, #17
   81eea:	4629      	mov	r1, r5
   81eec:	2000      	movs	r0, #0
   81eee:	47a0      	blx	r4
   81ef0:	bd38      	pop	{r3, r4, r5, pc}
   81ef2:	bf00      	nop
   81ef4:	400e0600 	.word	0x400e0600
   81ef8:	400e0e00 	.word	0x400e0e00
   81efc:	00081d0d 	.word	0x00081d0d

00081f00 <PWM_PIO_init>:

	
}

void PWM_PIO_init(void)
{
   81f00:	b538      	push	{r3, r4, r5, lr}
	//Disable PMC Write Protect Mode Register
	PMC->PMC_WPMR =PMC_WPMR_WPKEY_PASSWD|~(PMC_WPMR_WPEN);
   81f02:	4b0d      	ldr	r3, [pc, #52]	; (81f38 <PWM_PIO_init+0x38>)
   81f04:	f06f 0201 	mvn.w	r2, #1
   81f08:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
	//Enable Peripheral Clock
	PMC->PMC_PCER0 |= (PMC_PCER1_PID36);//enable clock for PWM
   81f0c:	691a      	ldr	r2, [r3, #16]
   81f0e:	f042 0210 	orr.w	r2, r2, #16
   81f12:	611a      	str	r2, [r3, #16]
	
	
	PIO_IO_init(Output,PWMH3_PB15_PORT,PWMH3_PB15_PIN,Peripheral_B);
   81f14:	2302      	movs	r3, #2
   81f16:	220f      	movs	r2, #15
   81f18:	4908      	ldr	r1, [pc, #32]	; (81f3c <PWM_PIO_init+0x3c>)
   81f1a:	2000      	movs	r0, #0
   81f1c:	4c08      	ldr	r4, [pc, #32]	; (81f40 <PWM_PIO_init+0x40>)
   81f1e:	47a0      	blx	r4
	PIO_IO_init(Output,PWML3_PA0_PORT,PWML3_PA0_PIN,Peripheral_B);
   81f20:	4d08      	ldr	r5, [pc, #32]	; (81f44 <PWM_PIO_init+0x44>)
   81f22:	2302      	movs	r3, #2
   81f24:	2200      	movs	r2, #0
   81f26:	4629      	mov	r1, r5
   81f28:	4610      	mov	r0, r2
   81f2a:	47a0      	blx	r4
	//PIO_IO_init(Output,PWMH0_PB12_PORT,PWMH0_PB12_PIN,Peripheral_B);
	PIO_IO_init(Input,PWMFI1_PA3_PORT,PWMFI1_PA3_PIN,Peripheral_B);
   81f2c:	2302      	movs	r3, #2
   81f2e:	2205      	movs	r2, #5
   81f30:	4629      	mov	r1, r5
   81f32:	2001      	movs	r0, #1
   81f34:	47a0      	blx	r4
   81f36:	bd38      	pop	{r3, r4, r5, pc}
   81f38:	400e0600 	.word	0x400e0600
   81f3c:	400e1000 	.word	0x400e1000
   81f40:	00081d0d 	.word	0x00081d0d
   81f44:	400e0e00 	.word	0x400e0e00

00081f48 <SPI_PIO_init>:
	
}

void SPI_PIO_init(void)
{
   81f48:	b538      	push	{r3, r4, r5, lr}
	//Disable PMC Write Protect Mode Register
	PMC->PMC_WPMR =PMC_WPMR_WPKEY_PASSWD|~(PMC_WPMR_WPEN);
   81f4a:	4b0d      	ldr	r3, [pc, #52]	; (81f80 <SPI_PIO_init+0x38>)
   81f4c:	f06f 0201 	mvn.w	r2, #1
   81f50:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
	//Enable Peripheral Clock
	PMC->PMC_PCER0 |= (PMC_PCER0_PID24);//enable clock for SPI0
   81f54:	691a      	ldr	r2, [r3, #16]
   81f56:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
   81f5a:	611a      	str	r2, [r3, #16]
	
	PIO_IO_init(Output,SPI0_SPCK_PA27_PORT,SPI0_SPCK_PA27_PIN,Peripheral_A);
   81f5c:	4d09      	ldr	r5, [pc, #36]	; (81f84 <SPI_PIO_init+0x3c>)
   81f5e:	2301      	movs	r3, #1
   81f60:	221b      	movs	r2, #27
   81f62:	4629      	mov	r1, r5
   81f64:	2000      	movs	r0, #0
   81f66:	4c08      	ldr	r4, [pc, #32]	; (81f88 <SPI_PIO_init+0x40>)
   81f68:	47a0      	blx	r4
	PIO_IO_init(Output,SPI0_MOSI_PA26_PORT,SPI0_MOSI_PA26_PIN,Peripheral_A);
   81f6a:	2301      	movs	r3, #1
   81f6c:	221a      	movs	r2, #26
   81f6e:	4629      	mov	r1, r5
   81f70:	2000      	movs	r0, #0
   81f72:	47a0      	blx	r4
	PIO_IO_init(Input,SPI0_MISO_PA25_PORT,SPI0_MISO_PA25_PIN,Peripheral_A);
   81f74:	2301      	movs	r3, #1
   81f76:	2219      	movs	r2, #25
   81f78:	4629      	mov	r1, r5
   81f7a:	4618      	mov	r0, r3
   81f7c:	47a0      	blx	r4
   81f7e:	bd38      	pop	{r3, r4, r5, pc}
   81f80:	400e0600 	.word	0x400e0600
   81f84:	400e0e00 	.word	0x400e0e00
   81f88:	00081d0d 	.word	0x00081d0d

00081f8c <ADC_PIO_init>:
	
}


void ADC_PIO_init(void)
{
   81f8c:	b510      	push	{r4, lr}
	//Disable PMC Write Protect Mode Register
	PMC->PMC_WPMR =PMC_WPMR_WPKEY_PASSWD|~(PMC_WPMR_WPEN);
   81f8e:	4b08      	ldr	r3, [pc, #32]	; (81fb0 <ADC_PIO_init+0x24>)
   81f90:	f06f 0201 	mvn.w	r2, #1
   81f94:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
	//Enable Peripheral Clock
	PMC->PMC_PCER0 |= (PMC_PCER1_PID37);//enable clock for SPI0
   81f98:	691a      	ldr	r2, [r3, #16]
   81f9a:	f042 0220 	orr.w	r2, r2, #32
   81f9e:	611a      	str	r2, [r3, #16]
	
	PIO_IO_init(Input,REF1V65_AD0_PA2_PORT,REF1V65_AD0_PA2_PIN,Alternate_function);
   81fa0:	2303      	movs	r3, #3
   81fa2:	2202      	movs	r2, #2
   81fa4:	4903      	ldr	r1, [pc, #12]	; (81fb4 <ADC_PIO_init+0x28>)
   81fa6:	2001      	movs	r0, #1
   81fa8:	4c03      	ldr	r4, [pc, #12]	; (81fb8 <ADC_PIO_init+0x2c>)
   81faa:	47a0      	blx	r4
   81fac:	bd10      	pop	{r4, pc}
   81fae:	bf00      	nop
   81fb0:	400e0600 	.word	0x400e0600
   81fb4:	400e0e00 	.word	0x400e0e00
   81fb8:	00081d0d 	.word	0x00081d0d

00081fbc <DAC_PIO_init>:
}

void DAC_PIO_init(void)
{
   81fbc:	b510      	push	{r4, lr}
	//Disable PMC Write Protect Mode Register
	PMC->PMC_WPMR =PMC_WPMR_WPKEY_PASSWD|~(PMC_WPMR_WPEN);
   81fbe:	4b08      	ldr	r3, [pc, #32]	; (81fe0 <DAC_PIO_init+0x24>)
   81fc0:	f06f 0201 	mvn.w	r2, #1
   81fc4:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
	//Enable Peripheral Clock
	PMC->PMC_PCER0 |= (PMC_PCER1_PID38);//enable clock for SPI0
   81fc8:	691a      	ldr	r2, [r3, #16]
   81fca:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   81fce:	611a      	str	r2, [r3, #16]
	
	PIO_IO_init(Output,DAC1_PB16_PORT,DAC1_PB16_PIN,Alternate_function);
   81fd0:	2303      	movs	r3, #3
   81fd2:	2210      	movs	r2, #16
   81fd4:	4903      	ldr	r1, [pc, #12]	; (81fe4 <DAC_PIO_init+0x28>)
   81fd6:	2000      	movs	r0, #0
   81fd8:	4c03      	ldr	r4, [pc, #12]	; (81fe8 <DAC_PIO_init+0x2c>)
   81fda:	47a0      	blx	r4
   81fdc:	bd10      	pop	{r4, pc}
   81fde:	bf00      	nop
   81fe0:	400e0600 	.word	0x400e0600
   81fe4:	400e1000 	.word	0x400e1000
   81fe8:	00081d0d 	.word	0x00081d0d

00081fec <PIO_INIT>:
	
}


void PIO_INIT(void)
{
   81fec:	b508      	push	{r3, lr}
	LED_PIO_init();
   81fee:	4b07      	ldr	r3, [pc, #28]	; (8200c <PIO_INIT+0x20>)
   81ff0:	4798      	blx	r3
	USART_PIO_init();
   81ff2:	4b07      	ldr	r3, [pc, #28]	; (82010 <PIO_INIT+0x24>)
   81ff4:	4798      	blx	r3
	TWI0_PIO_init();
   81ff6:	4b07      	ldr	r3, [pc, #28]	; (82014 <PIO_INIT+0x28>)
   81ff8:	4798      	blx	r3
	SPI_PIO_init();
   81ffa:	4b07      	ldr	r3, [pc, #28]	; (82018 <PIO_INIT+0x2c>)
   81ffc:	4798      	blx	r3
	ADC_PIO_init();
   81ffe:	4b07      	ldr	r3, [pc, #28]	; (8201c <PIO_INIT+0x30>)
   82000:	4798      	blx	r3
	DAC_PIO_init();
   82002:	4b07      	ldr	r3, [pc, #28]	; (82020 <PIO_INIT+0x34>)
   82004:	4798      	blx	r3
	PWM_PIO_init();
   82006:	4b07      	ldr	r3, [pc, #28]	; (82024 <PIO_INIT+0x38>)
   82008:	4798      	blx	r3
   8200a:	bd08      	pop	{r3, pc}
   8200c:	00081e2d 	.word	0x00081e2d
   82010:	00081e89 	.word	0x00081e89
   82014:	00081ec5 	.word	0x00081ec5
   82018:	00081f49 	.word	0x00081f49
   8201c:	00081f8d 	.word	0x00081f8d
   82020:	00081fbd 	.word	0x00081fbd
   82024:	00081f01 	.word	0x00081f01

00082028 <PWM_init_FAULT>:
	
	}

void PWM_init_FAULT(void)
{
	PWM->PWM_FMR &= ~PWM_FMR_FPOL(0b1<<1);
   82028:	4b04      	ldr	r3, [pc, #16]	; (8203c <PWM_init_FAULT+0x14>)
   8202a:	6dda      	ldr	r2, [r3, #92]	; 0x5c
   8202c:	f022 0202 	bic.w	r2, r2, #2
   82030:	65da      	str	r2, [r3, #92]	; 0x5c
	//PWM->PWM_FPE1 |= PWM_FPE1_FPE3(0b1<<1);//enable fault protection for channel 3
	PWM->PWM_FPE1 |= PWM_FPE1_FPE0(0b1<<1);//enable fault protection for channel 0
   82032:	6eda      	ldr	r2, [r3, #108]	; 0x6c
   82034:	f042 0202 	orr.w	r2, r2, #2
   82038:	66da      	str	r2, [r3, #108]	; 0x6c
   8203a:	4770      	bx	lr
   8203c:	40094000 	.word	0x40094000

00082040 <PWM_init>:
	//update synchronous channels
	//PWM ->PWM_SCUC |=PWM_SCUC_UPDULOCK;
}
	
void PWM_init(void)//synchronous mode
{
   82040:	b570      	push	{r4, r5, r6, lr}
	//select and divide PWM clock A and B.PWM_SCUC UPDULOCK
	//PWM ->PWM_CLK = PWM_CLK_DIVA(4)|PWM_CLK_DIVB(4)|PWM_CLK_PREA(0b1010)|PWM_CLK_PREB(0b1010); //0b1010 -> MCK/1024
	
	//Disable PMC Write Protect Mode Register
	PMC->PMC_WPMR =PMC_WPMR_WPKEY_PASSWD|~(PMC_WPMR_WPEN);
   82042:	4b2e      	ldr	r3, [pc, #184]	; (820fc <PWM_init+0xbc>)
   82044:	f06f 0201 	mvn.w	r2, #1
   82048:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
	//Enable Peripheral Clock
	PMC->PMC_PCER1 |= (PMC_PCER1_PID36);//enable clock for PWM
   8204c:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
   82050:	f042 0210 	orr.w	r2, r2, #16
   82054:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
	
	// select mode
	PWM ->PWM_SCM &= ~PWM_SCM_UPDM_Msk;
   82058:	4c29      	ldr	r4, [pc, #164]	; (82100 <PWM_init+0xc0>)
   8205a:	6a23      	ldr	r3, [r4, #32]
   8205c:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
   82060:	6223      	str	r3, [r4, #32]
	PWM ->PWM_SCM |= PWM_SCM_UPDM_MODE0;
   82062:	6a23      	ldr	r3, [r4, #32]
   82064:	6223      	str	r3, [r4, #32]
	//set channels as synchronous channels
	PWM->PWM_SCM |= PWM_SCM_SYNC1;
   82066:	6a23      	ldr	r3, [r4, #32]
   82068:	f043 0302 	orr.w	r3, r3, #2
   8206c:	6223      	str	r3, [r4, #32]
	PWM->PWM_SCM |= PWM_SCM_SYNC2;
   8206e:	6a23      	ldr	r3, [r4, #32]
   82070:	f043 0304 	orr.w	r3, r3, #4
   82074:	6223      	str	r3, [r4, #32]
	PWM->PWM_SCM |= PWM_SCM_SYNC3;
   82076:	6a23      	ldr	r3, [r4, #32]
   82078:	f043 0308 	orr.w	r3, r3, #8
   8207c:	6223      	str	r3, [r4, #32]
	
	//Enable channel 0
	PWM->PWM_ENA |= PWM_ENA_CHID0;
   8207e:	6863      	ldr	r3, [r4, #4]
   82080:	f043 0301 	orr.w	r3, r3, #1
   82084:	6063      	str	r3, [r4, #4]
	//Enable channel 1
	PWM->PWM_ENA |= PWM_ENA_CHID1;
   82086:	6863      	ldr	r3, [r4, #4]
   82088:	f043 0302 	orr.w	r3, r3, #2
   8208c:	6063      	str	r3, [r4, #4]
	//Enable channel 2
	PWM->PWM_ENA |= PWM_ENA_CHID2;
   8208e:	6863      	ldr	r3, [r4, #4]
   82090:	f043 0304 	orr.w	r3, r3, #4
   82094:	6063      	str	r3, [r4, #4]
	//Enable channel 3
	PWM->PWM_ENA |= PWM_ENA_CHID3;
   82096:	6863      	ldr	r3, [r4, #4]
   82098:	f043 0308 	orr.w	r3, r3, #8
   8209c:	6063      	str	r3, [r4, #4]
	//set frequency of PWM channel
	/*
	(MCK_DIV_16)16*(PWM_CPRDUPD_CPRDUPD)0x1f4/(MCK)80e6 =10kHz 
	*/
	//PWM Channel Period Update Register
	PWM0->PWM_CPRDUPDx |= PWM_CPRDUPD_CPRDUPD(0x1f4);//*(uint32_t *)0x40094270
   8209e:	4919      	ldr	r1, [pc, #100]	; (82104 <PWM_init+0xc4>)
   820a0:	690b      	ldr	r3, [r1, #16]
   820a2:	f443 73fa 	orr.w	r3, r3, #500	; 0x1f4
   820a6:	610b      	str	r3, [r1, #16]
	//PWM Channel Prescaler
	PWM0->PWM_CMRx  &= ~PWM_CMR_CPRE_Msk;//*(uint32_t *)0x40094260
   820a8:	680b      	ldr	r3, [r1, #0]
   820aa:	f023 030f 	bic.w	r3, r3, #15
   820ae:	600b      	str	r3, [r1, #0]
	PWM0->PWM_CMRx |= PWM_CMR_CPRE_MCK_DIV_16;
   820b0:	680b      	ldr	r3, [r1, #0]
   820b2:	f043 0304 	orr.w	r3, r3, #4
   820b6:	600b      	str	r3, [r1, #0]
	
	//Channel Alignment
	PWM0->PWM_CMRx |= PWM_CMR_CALG;
   820b8:	680b      	ldr	r3, [r1, #0]
   820ba:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   820be:	600b      	str	r3, [r1, #0]
	// Universal Sync settings stop-------------------------------------------
	
	//PWM Channel Dead Time Update Register CPRD-CDTY
	PWM3->PWM_DTUPDx= PWM_DTUPD_DTHUPD(0xF)|PWM_DTUPD_DTLUPD(0xF);//*(uint32_t *)0x4009427C
   820c0:	4d11      	ldr	r5, [pc, #68]	; (82108 <PWM_init+0xc8>)
   820c2:	f04f 120f 	mov.w	r2, #983055	; 0xf000f
   820c6:	61ea      	str	r2, [r5, #28]
	// Dead Time Generator Enable
	PWM3->PWM_CMRx |= PWM_CMR_DTE; //*(uint32_t *)0x40094260
   820c8:	682b      	ldr	r3, [r5, #0]
   820ca:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   820ce:	602b      	str	r3, [r5, #0]
	//Invert Low signal
	//PWM3->PWM_CMRx |= PWM_CMR_DTLI;

	//PWM Channel Dead Time Update Register CPRD-CDTY
	PWM0->PWM_DTUPDx= PWM_DTUPD_DTHUPD(0xF)|PWM_DTUPD_DTLUPD(0xF);//*(uint32_t *)0x4009427C
   820d0:	61ca      	str	r2, [r1, #28]
	// Dead Time Generator Enable
	PWM0->PWM_CMRx |= PWM_CMR_DTE; //*(uint32_t *)0x40094260
   820d2:	680b      	ldr	r3, [r1, #0]
   820d4:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   820d8:	600b      	str	r3, [r1, #0]
	
	//update synchronous channels
	PWM ->PWM_SCUC |=PWM_SCUC_UPDULOCK;
   820da:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   820dc:	f043 0301 	orr.w	r3, r3, #1
   820e0:	62a3      	str	r3, [r4, #40]	; 0x28
	
	Set_Duty_Cycle_Synchronous_Channels(10,PWM0);
   820e2:	200a      	movs	r0, #10
   820e4:	4e09      	ldr	r6, [pc, #36]	; (8210c <PWM_init+0xcc>)
   820e6:	47b0      	blx	r6
	Set_Duty_Cycle_Synchronous_Channels(10,PWM3);
   820e8:	4629      	mov	r1, r5
   820ea:	200a      	movs	r0, #10
   820ec:	47b0      	blx	r6
	//update synchronous channels
	PWM ->PWM_SCUC |=PWM_SCUC_UPDULOCK;
   820ee:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   820f0:	f043 0301 	orr.w	r3, r3, #1
   820f4:	62a3      	str	r3, [r4, #40]	; 0x28
	PWM_init_FAULT();
   820f6:	4b06      	ldr	r3, [pc, #24]	; (82110 <PWM_init+0xd0>)
   820f8:	4798      	blx	r3
   820fa:	bd70      	pop	{r4, r5, r6, pc}
   820fc:	400e0600 	.word	0x400e0600
   82100:	40094000 	.word	0x40094000
   82104:	40094200 	.word	0x40094200
   82108:	40094260 	.word	0x40094260
   8210c:	00081aad 	.word	0x00081aad
   82110:	00082029 	.word	0x00082029

00082114 <SPI_init>:
#include "SPI_init_SAM.h"

void SPI_init(void)
{
	//Enable Peripheral Clock
	PMC->PMC_PCER0 |= (PMC_PCER0_PID24);//enable clock for SPI0
   82114:	4a19      	ldr	r2, [pc, #100]	; (8217c <SPI_init+0x68>)
   82116:	6913      	ldr	r3, [r2, #16]
   82118:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
   8211c:	6113      	str	r3, [r2, #16]
	//Enable Peripheral SPI0
	SPI0->SPI_CR |= SPI_CR_SPIEN;
   8211e:	4b18      	ldr	r3, [pc, #96]	; (82180 <SPI_init+0x6c>)
   82120:	681a      	ldr	r2, [r3, #0]
   82122:	f042 0201 	orr.w	r2, r2, #1
   82126:	601a      	str	r2, [r3, #0]
	//SCBR: Serial Clock Baud Rate
	SPI0->SPI_CSR[1] &= ~(SPI_CSR_SCBR_Msk);
   82128:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   8212a:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
   8212e:	635a      	str	r2, [r3, #52]	; 0x34
	SPI0->SPI_CSR[1] |= SPI_CSR_SCBR(16);
   82130:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   82132:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
   82136:	635a      	str	r2, [r3, #52]	; 0x34
	//SPI is in Master mode
	SPI0->SPI_MR |= SPI_MR_MSTR;
   82138:	685a      	ldr	r2, [r3, #4]
   8213a:	f042 0201 	orr.w	r2, r2, #1
   8213e:	605a      	str	r2, [r3, #4]
	//The Peripheral Chip Select does not rise after the last transfer is achieved
	//It remains active until a new transfer is requested on a different chip select.
	SPI0->SPI_CSR[1] |= SPI_CSR_CSAAT;
   82140:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   82142:	f042 0208 	orr.w	r2, r2, #8
   82146:	635a      	str	r2, [r3, #52]	; 0x34
	//Fixed Peripheral Select.
	SPI0->SPI_MR &= ~SPI_MR_PS;
   82148:	685a      	ldr	r2, [r3, #4]
   8214a:	f022 0202 	bic.w	r2, r2, #2
   8214e:	605a      	str	r2, [r3, #4]
	//Delay Between Chip Selects
	SPI0->SPI_MR |= SPI_MR_PCS_Msk;//reset
   82150:	685a      	ldr	r2, [r3, #4]
   82152:	f442 2270 	orr.w	r2, r2, #983040	; 0xf0000
   82156:	605a      	str	r2, [r3, #4]
	SPI0->SPI_MR &= ~SPI_MR_DLYBCS_Msk;//reset
   82158:	685a      	ldr	r2, [r3, #4]
   8215a:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
   8215e:	605a      	str	r2, [r3, #4]
	SPI0->SPI_MR |= SPI_MR_DLYBCS(6);//set delay
   82160:	685a      	ldr	r2, [r3, #4]
   82162:	f042 62c0 	orr.w	r2, r2, #100663296	; 0x6000000
   82166:	605a      	str	r2, [r3, #4]
	//Peripheral Chip Select
	SPI0->SPI_MR &= ~SPI_MR_PCS_Msk;//reset
   82168:	685a      	ldr	r2, [r3, #4]
   8216a:	f422 2270 	bic.w	r2, r2, #983040	; 0xf0000
   8216e:	605a      	str	r2, [r3, #4]
	SPI0->SPI_MR |= SPI_MR_PCS(0b1101);//select
   82170:	685a      	ldr	r2, [r3, #4]
   82172:	f442 2250 	orr.w	r2, r2, #851968	; 0xd0000
   82176:	605a      	str	r2, [r3, #4]
   82178:	4770      	bx	lr
   8217a:	bf00      	nop
   8217c:	400e0600 	.word	0x400e0600
   82180:	40008000 	.word	0x40008000

00082184 <USART0_init>:
 */ 

#include "USART_init_SAM.h"

void USART0_init(void)//w
{
   82184:	b082      	sub	sp, #8
	volatile uint32_t t1;
	//clear write protect
	USART0->US_WPMR =US_WPMR_WPKEY_PASSWD|~(PMC_WPMR_WPEN);
   82186:	4b26      	ldr	r3, [pc, #152]	; (82220 <USART0_init+0x9c>)
   82188:	f06f 0201 	mvn.w	r2, #1
   8218c:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
	//select MCK as clock
	USART0->US_MR &= ~(US_MR_USCLKS_Msk);//reset
   82190:	685a      	ldr	r2, [r3, #4]
   82192:	f022 0230 	bic.w	r2, r2, #48	; 0x30
   82196:	605a      	str	r2, [r3, #4]
	USART0->US_MR |= (US_MR_USCLKS_MCK);//set
   82198:	685a      	ldr	r2, [r3, #4]
   8219a:	605a      	str	r2, [r3, #4]
	//set usart to normal mode
	USART0->US_MR &=~(US_MR_USART_MODE_Msk);
   8219c:	685a      	ldr	r2, [r3, #4]
   8219e:	f022 020f 	bic.w	r2, r2, #15
   821a2:	605a      	str	r2, [r3, #4]
	USART0->US_MR |=US_MR_USART_MODE_NORMAL;
   821a4:	685a      	ldr	r2, [r3, #4]
   821a6:	605a      	str	r2, [r3, #4]
	//set character length to 8 bits
	USART0->US_MR &=~(US_MR_CHRL_Msk);
   821a8:	685a      	ldr	r2, [r3, #4]
   821aa:	f022 02c0 	bic.w	r2, r2, #192	; 0xc0
   821ae:	605a      	str	r2, [r3, #4]
	USART0->US_MR |=US_MR_CHRL_8_BIT;
   821b0:	685a      	ldr	r2, [r3, #4]
   821b2:	f042 02c0 	orr.w	r2, r2, #192	; 0xc0
   821b6:	605a      	str	r2, [r3, #4]
	//set parity type to no parity
	USART0->US_MR &=~(US_MR_PAR_Msk);
   821b8:	685a      	ldr	r2, [r3, #4]
   821ba:	f422 6260 	bic.w	r2, r2, #3584	; 0xe00
   821be:	605a      	str	r2, [r3, #4]
	USART0->US_MR |=US_MR_PAR_NO;
   821c0:	685a      	ldr	r2, [r3, #4]
   821c2:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
   821c6:	605a      	str	r2, [r3, #4]
	//set baud rate
	USART0->US_BRGR &=~(US_BRGR_CD_Msk);
   821c8:	6a1a      	ldr	r2, [r3, #32]
   821ca:	0c12      	lsrs	r2, r2, #16
   821cc:	0412      	lsls	r2, r2, #16
   821ce:	621a      	str	r2, [r3, #32]
	USART0->US_BRGR |=0x2B;//115200
   821d0:	6a1a      	ldr	r2, [r3, #32]
   821d2:	f042 022b 	orr.w	r2, r2, #43	; 0x2b
   821d6:	621a      	str	r2, [r3, #32]
	t1= USART0->US_BRGR ;
   821d8:	6a1a      	ldr	r2, [r3, #32]
   821da:	9201      	str	r2, [sp, #4]
	//enable transmit and receive
	USART0->US_CR |=US_CR_RSTRX;//reset receive
   821dc:	681a      	ldr	r2, [r3, #0]
   821de:	f042 0204 	orr.w	r2, r2, #4
   821e2:	601a      	str	r2, [r3, #0]
	USART0->US_CR &=~US_CR_RSTRX;
   821e4:	681a      	ldr	r2, [r3, #0]
   821e6:	f022 0204 	bic.w	r2, r2, #4
   821ea:	601a      	str	r2, [r3, #0]
	USART0->US_CR &=~US_CR_RXDIS;//reset disable
   821ec:	681a      	ldr	r2, [r3, #0]
   821ee:	f022 0220 	bic.w	r2, r2, #32
   821f2:	601a      	str	r2, [r3, #0]
	USART0->US_CR |=US_CR_RXEN;//enable receive
   821f4:	681a      	ldr	r2, [r3, #0]
   821f6:	f042 0210 	orr.w	r2, r2, #16
   821fa:	601a      	str	r2, [r3, #0]
	USART0->US_CR |=US_CR_RSTTX;//reset transmit
   821fc:	681a      	ldr	r2, [r3, #0]
   821fe:	f042 0208 	orr.w	r2, r2, #8
   82202:	601a      	str	r2, [r3, #0]
	USART0->US_CR &=~US_CR_RSTTX;
   82204:	681a      	ldr	r2, [r3, #0]
   82206:	f022 0208 	bic.w	r2, r2, #8
   8220a:	601a      	str	r2, [r3, #0]
	USART0->US_CR &=~US_CR_TXDIS;//reset disable
   8220c:	681a      	ldr	r2, [r3, #0]
   8220e:	f022 0280 	bic.w	r2, r2, #128	; 0x80
   82212:	601a      	str	r2, [r3, #0]
	USART0->US_CR |=US_CR_TXEN;//enable transmit
   82214:	681a      	ldr	r2, [r3, #0]
   82216:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   8221a:	601a      	str	r2, [r3, #0]
	

}
   8221c:	b002      	add	sp, #8
   8221e:	4770      	bx	lr
   82220:	40098000 	.word	0x40098000

00082224 <__libc_init_array>:
   82224:	b570      	push	{r4, r5, r6, lr}
   82226:	4e0f      	ldr	r6, [pc, #60]	; (82264 <__libc_init_array+0x40>)
   82228:	4d0f      	ldr	r5, [pc, #60]	; (82268 <__libc_init_array+0x44>)
   8222a:	1b76      	subs	r6, r6, r5
   8222c:	10b6      	asrs	r6, r6, #2
   8222e:	bf18      	it	ne
   82230:	2400      	movne	r4, #0
   82232:	d005      	beq.n	82240 <__libc_init_array+0x1c>
   82234:	3401      	adds	r4, #1
   82236:	f855 3b04 	ldr.w	r3, [r5], #4
   8223a:	4798      	blx	r3
   8223c:	42a6      	cmp	r6, r4
   8223e:	d1f9      	bne.n	82234 <__libc_init_array+0x10>
   82240:	4e0a      	ldr	r6, [pc, #40]	; (8226c <__libc_init_array+0x48>)
   82242:	4d0b      	ldr	r5, [pc, #44]	; (82270 <__libc_init_array+0x4c>)
   82244:	f000 f9b2 	bl	825ac <_init>
   82248:	1b76      	subs	r6, r6, r5
   8224a:	10b6      	asrs	r6, r6, #2
   8224c:	bf18      	it	ne
   8224e:	2400      	movne	r4, #0
   82250:	d006      	beq.n	82260 <__libc_init_array+0x3c>
   82252:	3401      	adds	r4, #1
   82254:	f855 3b04 	ldr.w	r3, [r5], #4
   82258:	4798      	blx	r3
   8225a:	42a6      	cmp	r6, r4
   8225c:	d1f9      	bne.n	82252 <__libc_init_array+0x2e>
   8225e:	bd70      	pop	{r4, r5, r6, pc}
   82260:	bd70      	pop	{r4, r5, r6, pc}
   82262:	bf00      	nop
   82264:	000825b8 	.word	0x000825b8
   82268:	000825b8 	.word	0x000825b8
   8226c:	000825c0 	.word	0x000825c0
   82270:	000825b8 	.word	0x000825b8

00082274 <memcpy>:
   82274:	4684      	mov	ip, r0
   82276:	ea41 0300 	orr.w	r3, r1, r0
   8227a:	f013 0303 	ands.w	r3, r3, #3
   8227e:	d149      	bne.n	82314 <memcpy+0xa0>
   82280:	3a40      	subs	r2, #64	; 0x40
   82282:	d323      	bcc.n	822cc <memcpy+0x58>
   82284:	680b      	ldr	r3, [r1, #0]
   82286:	6003      	str	r3, [r0, #0]
   82288:	684b      	ldr	r3, [r1, #4]
   8228a:	6043      	str	r3, [r0, #4]
   8228c:	688b      	ldr	r3, [r1, #8]
   8228e:	6083      	str	r3, [r0, #8]
   82290:	68cb      	ldr	r3, [r1, #12]
   82292:	60c3      	str	r3, [r0, #12]
   82294:	690b      	ldr	r3, [r1, #16]
   82296:	6103      	str	r3, [r0, #16]
   82298:	694b      	ldr	r3, [r1, #20]
   8229a:	6143      	str	r3, [r0, #20]
   8229c:	698b      	ldr	r3, [r1, #24]
   8229e:	6183      	str	r3, [r0, #24]
   822a0:	69cb      	ldr	r3, [r1, #28]
   822a2:	61c3      	str	r3, [r0, #28]
   822a4:	6a0b      	ldr	r3, [r1, #32]
   822a6:	6203      	str	r3, [r0, #32]
   822a8:	6a4b      	ldr	r3, [r1, #36]	; 0x24
   822aa:	6243      	str	r3, [r0, #36]	; 0x24
   822ac:	6a8b      	ldr	r3, [r1, #40]	; 0x28
   822ae:	6283      	str	r3, [r0, #40]	; 0x28
   822b0:	6acb      	ldr	r3, [r1, #44]	; 0x2c
   822b2:	62c3      	str	r3, [r0, #44]	; 0x2c
   822b4:	6b0b      	ldr	r3, [r1, #48]	; 0x30
   822b6:	6303      	str	r3, [r0, #48]	; 0x30
   822b8:	6b4b      	ldr	r3, [r1, #52]	; 0x34
   822ba:	6343      	str	r3, [r0, #52]	; 0x34
   822bc:	6b8b      	ldr	r3, [r1, #56]	; 0x38
   822be:	6383      	str	r3, [r0, #56]	; 0x38
   822c0:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
   822c2:	63c3      	str	r3, [r0, #60]	; 0x3c
   822c4:	3040      	adds	r0, #64	; 0x40
   822c6:	3140      	adds	r1, #64	; 0x40
   822c8:	3a40      	subs	r2, #64	; 0x40
   822ca:	d2db      	bcs.n	82284 <memcpy+0x10>
   822cc:	3230      	adds	r2, #48	; 0x30
   822ce:	d30b      	bcc.n	822e8 <memcpy+0x74>
   822d0:	680b      	ldr	r3, [r1, #0]
   822d2:	6003      	str	r3, [r0, #0]
   822d4:	684b      	ldr	r3, [r1, #4]
   822d6:	6043      	str	r3, [r0, #4]
   822d8:	688b      	ldr	r3, [r1, #8]
   822da:	6083      	str	r3, [r0, #8]
   822dc:	68cb      	ldr	r3, [r1, #12]
   822de:	60c3      	str	r3, [r0, #12]
   822e0:	3010      	adds	r0, #16
   822e2:	3110      	adds	r1, #16
   822e4:	3a10      	subs	r2, #16
   822e6:	d2f3      	bcs.n	822d0 <memcpy+0x5c>
   822e8:	320c      	adds	r2, #12
   822ea:	d305      	bcc.n	822f8 <memcpy+0x84>
   822ec:	f851 3b04 	ldr.w	r3, [r1], #4
   822f0:	f840 3b04 	str.w	r3, [r0], #4
   822f4:	3a04      	subs	r2, #4
   822f6:	d2f9      	bcs.n	822ec <memcpy+0x78>
   822f8:	3204      	adds	r2, #4
   822fa:	d008      	beq.n	8230e <memcpy+0x9a>
   822fc:	07d2      	lsls	r2, r2, #31
   822fe:	bf1c      	itt	ne
   82300:	f811 3b01 	ldrbne.w	r3, [r1], #1
   82304:	f800 3b01 	strbne.w	r3, [r0], #1
   82308:	d301      	bcc.n	8230e <memcpy+0x9a>
   8230a:	880b      	ldrh	r3, [r1, #0]
   8230c:	8003      	strh	r3, [r0, #0]
   8230e:	4660      	mov	r0, ip
   82310:	4770      	bx	lr
   82312:	bf00      	nop
   82314:	2a08      	cmp	r2, #8
   82316:	d313      	bcc.n	82340 <memcpy+0xcc>
   82318:	078b      	lsls	r3, r1, #30
   8231a:	d0b1      	beq.n	82280 <memcpy+0xc>
   8231c:	f010 0303 	ands.w	r3, r0, #3
   82320:	d0ae      	beq.n	82280 <memcpy+0xc>
   82322:	f1c3 0304 	rsb	r3, r3, #4
   82326:	1ad2      	subs	r2, r2, r3
   82328:	07db      	lsls	r3, r3, #31
   8232a:	bf1c      	itt	ne
   8232c:	f811 3b01 	ldrbne.w	r3, [r1], #1
   82330:	f800 3b01 	strbne.w	r3, [r0], #1
   82334:	d3a4      	bcc.n	82280 <memcpy+0xc>
   82336:	f831 3b02 	ldrh.w	r3, [r1], #2
   8233a:	f820 3b02 	strh.w	r3, [r0], #2
   8233e:	e79f      	b.n	82280 <memcpy+0xc>
   82340:	3a04      	subs	r2, #4
   82342:	d3d9      	bcc.n	822f8 <memcpy+0x84>
   82344:	3a01      	subs	r2, #1
   82346:	f811 3b01 	ldrb.w	r3, [r1], #1
   8234a:	f800 3b01 	strb.w	r3, [r0], #1
   8234e:	d2f9      	bcs.n	82344 <memcpy+0xd0>
   82350:	780b      	ldrb	r3, [r1, #0]
   82352:	7003      	strb	r3, [r0, #0]
   82354:	784b      	ldrb	r3, [r1, #1]
   82356:	7043      	strb	r3, [r0, #1]
   82358:	788b      	ldrb	r3, [r1, #2]
   8235a:	7083      	strb	r3, [r0, #2]
   8235c:	4660      	mov	r0, ip
   8235e:	4770      	bx	lr

00082360 <memset>:
   82360:	b470      	push	{r4, r5, r6}
   82362:	0786      	lsls	r6, r0, #30
   82364:	d046      	beq.n	823f4 <memset+0x94>
   82366:	1e54      	subs	r4, r2, #1
   82368:	2a00      	cmp	r2, #0
   8236a:	d041      	beq.n	823f0 <memset+0x90>
   8236c:	b2ca      	uxtb	r2, r1
   8236e:	4603      	mov	r3, r0
   82370:	e002      	b.n	82378 <memset+0x18>
   82372:	f114 34ff 	adds.w	r4, r4, #4294967295
   82376:	d33b      	bcc.n	823f0 <memset+0x90>
   82378:	f803 2b01 	strb.w	r2, [r3], #1
   8237c:	079d      	lsls	r5, r3, #30
   8237e:	d1f8      	bne.n	82372 <memset+0x12>
   82380:	2c03      	cmp	r4, #3
   82382:	d92e      	bls.n	823e2 <memset+0x82>
   82384:	b2cd      	uxtb	r5, r1
   82386:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
   8238a:	2c0f      	cmp	r4, #15
   8238c:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
   82390:	d919      	bls.n	823c6 <memset+0x66>
   82392:	4626      	mov	r6, r4
   82394:	f103 0210 	add.w	r2, r3, #16
   82398:	3e10      	subs	r6, #16
   8239a:	2e0f      	cmp	r6, #15
   8239c:	f842 5c10 	str.w	r5, [r2, #-16]
   823a0:	f842 5c0c 	str.w	r5, [r2, #-12]
   823a4:	f842 5c08 	str.w	r5, [r2, #-8]
   823a8:	f842 5c04 	str.w	r5, [r2, #-4]
   823ac:	f102 0210 	add.w	r2, r2, #16
   823b0:	d8f2      	bhi.n	82398 <memset+0x38>
   823b2:	f1a4 0210 	sub.w	r2, r4, #16
   823b6:	f022 020f 	bic.w	r2, r2, #15
   823ba:	f004 040f 	and.w	r4, r4, #15
   823be:	3210      	adds	r2, #16
   823c0:	2c03      	cmp	r4, #3
   823c2:	4413      	add	r3, r2
   823c4:	d90d      	bls.n	823e2 <memset+0x82>
   823c6:	461e      	mov	r6, r3
   823c8:	4622      	mov	r2, r4
   823ca:	3a04      	subs	r2, #4
   823cc:	2a03      	cmp	r2, #3
   823ce:	f846 5b04 	str.w	r5, [r6], #4
   823d2:	d8fa      	bhi.n	823ca <memset+0x6a>
   823d4:	1f22      	subs	r2, r4, #4
   823d6:	f022 0203 	bic.w	r2, r2, #3
   823da:	3204      	adds	r2, #4
   823dc:	4413      	add	r3, r2
   823de:	f004 0403 	and.w	r4, r4, #3
   823e2:	b12c      	cbz	r4, 823f0 <memset+0x90>
   823e4:	b2c9      	uxtb	r1, r1
   823e6:	441c      	add	r4, r3
   823e8:	f803 1b01 	strb.w	r1, [r3], #1
   823ec:	429c      	cmp	r4, r3
   823ee:	d1fb      	bne.n	823e8 <memset+0x88>
   823f0:	bc70      	pop	{r4, r5, r6}
   823f2:	4770      	bx	lr
   823f4:	4614      	mov	r4, r2
   823f6:	4603      	mov	r3, r0
   823f8:	e7c2      	b.n	82380 <memset+0x20>
   823fa:	bf00      	nop

000823fc <strncpy>:
   823fc:	ea40 0301 	orr.w	r3, r0, r1
   82400:	f013 0f03 	tst.w	r3, #3
   82404:	b470      	push	{r4, r5, r6}
   82406:	4603      	mov	r3, r0
   82408:	d024      	beq.n	82454 <strncpy+0x58>
   8240a:	b1a2      	cbz	r2, 82436 <strncpy+0x3a>
   8240c:	780c      	ldrb	r4, [r1, #0]
   8240e:	3a01      	subs	r2, #1
   82410:	701c      	strb	r4, [r3, #0]
   82412:	3101      	adds	r1, #1
   82414:	3301      	adds	r3, #1
   82416:	b13c      	cbz	r4, 82428 <strncpy+0x2c>
   82418:	b16a      	cbz	r2, 82436 <strncpy+0x3a>
   8241a:	f811 4b01 	ldrb.w	r4, [r1], #1
   8241e:	3a01      	subs	r2, #1
   82420:	f803 4b01 	strb.w	r4, [r3], #1
   82424:	2c00      	cmp	r4, #0
   82426:	d1f7      	bne.n	82418 <strncpy+0x1c>
   82428:	b12a      	cbz	r2, 82436 <strncpy+0x3a>
   8242a:	2100      	movs	r1, #0
   8242c:	441a      	add	r2, r3
   8242e:	f803 1b01 	strb.w	r1, [r3], #1
   82432:	429a      	cmp	r2, r3
   82434:	d1fb      	bne.n	8242e <strncpy+0x32>
   82436:	bc70      	pop	{r4, r5, r6}
   82438:	4770      	bx	lr
   8243a:	460e      	mov	r6, r1
   8243c:	f851 5b04 	ldr.w	r5, [r1], #4
   82440:	f1a5 3401 	sub.w	r4, r5, #16843009	; 0x1010101
   82444:	ea24 0405 	bic.w	r4, r4, r5
   82448:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
   8244c:	d105      	bne.n	8245a <strncpy+0x5e>
   8244e:	3a04      	subs	r2, #4
   82450:	f843 5b04 	str.w	r5, [r3], #4
   82454:	2a03      	cmp	r2, #3
   82456:	d8f0      	bhi.n	8243a <strncpy+0x3e>
   82458:	e7d7      	b.n	8240a <strncpy+0xe>
   8245a:	4631      	mov	r1, r6
   8245c:	e7d6      	b.n	8240c <strncpy+0x10>
   8245e:	bf00      	nop

00082460 <register_fini>:
   82460:	4b02      	ldr	r3, [pc, #8]	; (8246c <register_fini+0xc>)
   82462:	b113      	cbz	r3, 8246a <register_fini+0xa>
   82464:	4802      	ldr	r0, [pc, #8]	; (82470 <register_fini+0x10>)
   82466:	f000 b805 	b.w	82474 <atexit>
   8246a:	4770      	bx	lr
   8246c:	00000000 	.word	0x00000000
   82470:	00082481 	.word	0x00082481

00082474 <atexit>:
   82474:	2300      	movs	r3, #0
   82476:	4601      	mov	r1, r0
   82478:	461a      	mov	r2, r3
   8247a:	4618      	mov	r0, r3
   8247c:	f000 b81e 	b.w	824bc <__register_exitproc>

00082480 <__libc_fini_array>:
   82480:	b538      	push	{r3, r4, r5, lr}
   82482:	4c0a      	ldr	r4, [pc, #40]	; (824ac <__libc_fini_array+0x2c>)
   82484:	4d0a      	ldr	r5, [pc, #40]	; (824b0 <__libc_fini_array+0x30>)
   82486:	1b64      	subs	r4, r4, r5
   82488:	10a4      	asrs	r4, r4, #2
   8248a:	d00a      	beq.n	824a2 <__libc_fini_array+0x22>
   8248c:	f104 4380 	add.w	r3, r4, #1073741824	; 0x40000000
   82490:	3b01      	subs	r3, #1
   82492:	eb05 0583 	add.w	r5, r5, r3, lsl #2
   82496:	3c01      	subs	r4, #1
   82498:	f855 3904 	ldr.w	r3, [r5], #-4
   8249c:	4798      	blx	r3
   8249e:	2c00      	cmp	r4, #0
   824a0:	d1f9      	bne.n	82496 <__libc_fini_array+0x16>
   824a2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   824a6:	f000 b88b 	b.w	825c0 <_fini>
   824aa:	bf00      	nop
   824ac:	000825d0 	.word	0x000825d0
   824b0:	000825cc 	.word	0x000825cc

000824b4 <__retarget_lock_acquire_recursive>:
   824b4:	4770      	bx	lr
   824b6:	bf00      	nop

000824b8 <__retarget_lock_release_recursive>:
   824b8:	4770      	bx	lr
   824ba:	bf00      	nop

000824bc <__register_exitproc>:
   824bc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   824c0:	4d2c      	ldr	r5, [pc, #176]	; (82574 <__register_exitproc+0xb8>)
   824c2:	4606      	mov	r6, r0
   824c4:	6828      	ldr	r0, [r5, #0]
   824c6:	4698      	mov	r8, r3
   824c8:	460f      	mov	r7, r1
   824ca:	4691      	mov	r9, r2
   824cc:	f7ff fff2 	bl	824b4 <__retarget_lock_acquire_recursive>
   824d0:	4b29      	ldr	r3, [pc, #164]	; (82578 <__register_exitproc+0xbc>)
   824d2:	681c      	ldr	r4, [r3, #0]
   824d4:	f8d4 3148 	ldr.w	r3, [r4, #328]	; 0x148
   824d8:	2b00      	cmp	r3, #0
   824da:	d03e      	beq.n	8255a <__register_exitproc+0x9e>
   824dc:	685a      	ldr	r2, [r3, #4]
   824de:	2a1f      	cmp	r2, #31
   824e0:	dc1c      	bgt.n	8251c <__register_exitproc+0x60>
   824e2:	f102 0e01 	add.w	lr, r2, #1
   824e6:	b176      	cbz	r6, 82506 <__register_exitproc+0x4a>
   824e8:	2101      	movs	r1, #1
   824ea:	eb03 0482 	add.w	r4, r3, r2, lsl #2
   824ee:	f8c4 9088 	str.w	r9, [r4, #136]	; 0x88
   824f2:	f8d3 0188 	ldr.w	r0, [r3, #392]	; 0x188
   824f6:	4091      	lsls	r1, r2
   824f8:	4308      	orrs	r0, r1
   824fa:	2e02      	cmp	r6, #2
   824fc:	f8c3 0188 	str.w	r0, [r3, #392]	; 0x188
   82500:	f8c4 8108 	str.w	r8, [r4, #264]	; 0x108
   82504:	d023      	beq.n	8254e <__register_exitproc+0x92>
   82506:	3202      	adds	r2, #2
   82508:	f8c3 e004 	str.w	lr, [r3, #4]
   8250c:	6828      	ldr	r0, [r5, #0]
   8250e:	f843 7022 	str.w	r7, [r3, r2, lsl #2]
   82512:	f7ff ffd1 	bl	824b8 <__retarget_lock_release_recursive>
   82516:	2000      	movs	r0, #0
   82518:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   8251c:	4b17      	ldr	r3, [pc, #92]	; (8257c <__register_exitproc+0xc0>)
   8251e:	b30b      	cbz	r3, 82564 <__register_exitproc+0xa8>
   82520:	f44f 70c8 	mov.w	r0, #400	; 0x190
   82524:	f3af 8000 	nop.w
   82528:	4603      	mov	r3, r0
   8252a:	b1d8      	cbz	r0, 82564 <__register_exitproc+0xa8>
   8252c:	2000      	movs	r0, #0
   8252e:	f8d4 1148 	ldr.w	r1, [r4, #328]	; 0x148
   82532:	f04f 0e01 	mov.w	lr, #1
   82536:	6058      	str	r0, [r3, #4]
   82538:	6019      	str	r1, [r3, #0]
   8253a:	4602      	mov	r2, r0
   8253c:	f8c4 3148 	str.w	r3, [r4, #328]	; 0x148
   82540:	f8c3 0188 	str.w	r0, [r3, #392]	; 0x188
   82544:	f8c3 018c 	str.w	r0, [r3, #396]	; 0x18c
   82548:	2e00      	cmp	r6, #0
   8254a:	d0dc      	beq.n	82506 <__register_exitproc+0x4a>
   8254c:	e7cc      	b.n	824e8 <__register_exitproc+0x2c>
   8254e:	f8d3 018c 	ldr.w	r0, [r3, #396]	; 0x18c
   82552:	4301      	orrs	r1, r0
   82554:	f8c3 118c 	str.w	r1, [r3, #396]	; 0x18c
   82558:	e7d5      	b.n	82506 <__register_exitproc+0x4a>
   8255a:	f504 73a6 	add.w	r3, r4, #332	; 0x14c
   8255e:	f8c4 3148 	str.w	r3, [r4, #328]	; 0x148
   82562:	e7bb      	b.n	824dc <__register_exitproc+0x20>
   82564:	6828      	ldr	r0, [r5, #0]
   82566:	f7ff ffa7 	bl	824b8 <__retarget_lock_release_recursive>
   8256a:	f04f 30ff 	mov.w	r0, #4294967295
   8256e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   82572:	bf00      	nop
   82574:	20000438 	.word	0x20000438
   82578:	000825a8 	.word	0x000825a8
   8257c:	00000000 	.word	0x00000000
   82580:	09097325 	.word	0x09097325
   82584:	25096325 	.word	0x25096325
   82588:	75250975 	.word	0x75250975
   8258c:	0d752509 	.word	0x0d752509
   82590:	0000000a 	.word	0x0000000a
   82594:	454c4449 	.word	0x454c4449
   82598:	00000000 	.word	0x00000000
   8259c:	00000a0d 	.word	0x00000a0d
   825a0:	20726d54 	.word	0x20726d54
   825a4:	00637653 	.word	0x00637653

000825a8 <_global_impure_ptr>:
   825a8:	20000010                                ... 

000825ac <_init>:
   825ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   825ae:	bf00      	nop
   825b0:	bcf8      	pop	{r3, r4, r5, r6, r7}
   825b2:	bc08      	pop	{r3}
   825b4:	469e      	mov	lr, r3
   825b6:	4770      	bx	lr

000825b8 <__init_array_start>:
   825b8:	00082461 	.word	0x00082461

000825bc <__frame_dummy_init_array_entry>:
   825bc:	00080119                                ....

000825c0 <_fini>:
   825c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   825c2:	bf00      	nop
   825c4:	bcf8      	pop	{r3, r4, r5, r6, r7}
   825c6:	bc08      	pop	{r3}
   825c8:	469e      	mov	lr, r3
   825ca:	4770      	bx	lr

000825cc <__fini_array_start>:
   825cc:	000800f5 	.word	0x000800f5
